{"title":"IOI 2020: นับเห็ดเปลี่ยนชนิด","link":"https://neizod.github.io/2020/10/25/ioi-2020-count-mushrooms.html","date":1603636283000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><p>โจทย์ข้อที่ยากทีสุดในการแข่งขัน IOI 2020 คงหนีไม่พ้นข้อที่ 2 ในวันที่ 2 ที่มีผู้เข้าแข่งขันเพียงคนเดียวที่ได้ 100 คะแนนเต็ม ตัวโจทย์เป็นแนว<a href=\"https://www.geeksforgeeks.org/interactive-problems-in-competitive-programming/\">โต้ตอบ</a> โดยจะให้คะแนนตามจำนวนครั้งที่โต้ตอบ ยิ่งสามารถทำได้ในจำนวนครั้งที่น้อยลงเท่าไหร่ ก็จะยิ่งได้คะแนนที่มากขึ้นเท่านั้น</p><p>โดยเนื้อหาโจทย์อย่างสรุปเล่าได้ว่า มีเห็ดอยู่สองชนิดที่มนุษย์ไม่สามารถแยกออกได้ด้วยตนเอง ส่วนเครื่องจักรที่มีก็สามารถนับจำนวน<em>การเปลี่ยนแปลงของชนิดเห็ด</em>ที่ใส่เข้าไปเป็นลำดับได้เท่านั้น เช่น เมื่อใส่เห็ด 5 ดอกที่มีชนิด <span>ABBAB</span> เข้าไปตามลำดับจนเสร็จแล้วเดินเครื่อง เครื่องจักรจะตอบว่าเกิดการเปลี่ยนแปลงขึ้น 3 ครั้งนั่นเอง อย่างไรก็ตามการเดินเครื่องจักรแต่ละครั้งจะใช้พลังงานเท่ากับจำนวนเห็ดที่ใส่เข้าไป หากเรามีพลังงานอยู่ <span>100,000</span> หน่วยพร้อมกับเห็ดอีก <span>20,000</span> ดอก ซึ่งเราทราบว่าเห็ดดอกแรกสุดนั้นคือเห็ดตัวอย่างของชนิด <span>A</span> และเราสามารถเรียงลำดับเห็ดใส่เข้าไปในเครื่องจักรอย่างไรก็ได้ จงเขียนโปรแกรมที่นับจำนวนเห็ดชนิด <span>A</span> โดยพยายามลดจำนวนการเดินเครื่องให้เหลือน้อยที่สุดและยังใช้พลังงานไม่เกินที่กำหนด <a href=\"https://ioi2020.sg/ioi-2020-tasks/\">ดูเว็บที่เก็บโจทย์ต้นฉบับ</a></p><blockquote><p><img src=\"https://neizod.dev/images/algorithm/misc/mushrooms.png\" alt=\"\"></p><p>ตัวอย่างการใส่เห็ดแบบต่างๆ และคำตอบจากเครื่องจักรที่บอกจำนวนครั้งที่เห็ดเปลี่ยนชนิด</p></blockquote><h2 id=\"คว้าคะแนนขั้นต่ำจากข้อสังเกตพื้นฐาน\">คว้าคะแนนขั้นต่ำจากข้อสังเกตพื้นฐาน</h2><p>เกณฑ์การให้คะแนนขั้นต่ำสุดที่ 10 คะแนน ยินยอมให้มีการเดินเครื่องจักรได้มากถึง <span>20,000</span> ครั้ง ดังนั้นในแต่ละครั้งเราจะใส่เห็ดเพียง 2 ดอก โดยหนึ่งในนั้นให้เป็นเห็ดดอกแรกที่เรารู้แน่นอนว่าคือชนิด <span>A</span> แล้วจับคู่ทีละคู่กับเห็ดดอกอื่นๆ ที่เหลือ เมื่อนับจำนวนครั้งที่<strong>ไม่มี</strong>การเปลี่ยนแปลงแล้วบวกเพิ่มอีกหนึ่งก็จะได้จำนวนของเห็ดชนิด <span>A</span> ทั้งหมดนั่นเอง</p><p>ส่วนเกณฑ์ 25 คะแนนในบันไดขั้นถัดไปนั้น จะห้ามเดินเครื่องจักรเกิน <span>10,010</span> ครั้ง ซึ่งสามารถทำได้โดยใช้แนวคิดคล้ายกับข้างต้นเลย เพียงแต่ว่าเราจะใส่เห็ดเพิ่มเข้าไปเป็นครั้งละ 3 ดอกแทน โดยต้องใส่เห็ดชนิด <span>A</span> ไว้ตรงกลางระหว่างเห็ดอีกสองดอกที่เราไม่รู้เท่านั้น เมื่อเดินเครื่องจักรแล้วจะพบว่า</p><ul><li>ตอบ 0: เห็ดทั้ง 3 ดอกเป็นชนิด <span>A</span></li><li>ตอบ 1: มีเห็ดชนิด <span>A</span> อยู่ 2 ดอก และเห็ดชนิด <span>B</span> อีก 1 ดอก (ไม่สนใจว่า <span>B</span> คือดอกไหน)</li><li>ตอบ 2: เฉพาะเห็ดตรงกลางเป็นชนิด <span>A</span> ส่วนอีก 2 ดอกเป็นเห็ดชนิด <span>B</span></li></ul><h2 id=\"วางโครงร่างเทคนิคชิงคะแนนที่มากขึ้น\">วางโครงร่างเทคนิคชิงคะแนนที่มากขึ้น</h2><p>สำหรับเกณฑ์การให้คะแนนขั้นถัดไปจะเกิดขึ้นเมื่อสามารถเดินเครื่องจักรได้ไม่เกิน <span>904</span> ครั้ง โดยจะคิดคะแนนเป็นสัดส่วนกับจำนวนครั้งที่เดินเครื่องจักร คือจะได้คะแนน <span>100\\cdot226\\div Q</span> คะแนนเมื่อ <span>Q</span> คือจำนวนครั้งที่เดินเครื่องนั่นเอง (คะแนนสูงสุดตัดที่ 100 คะแนน หรือก็คือได้คะแนนเต็มเมื่อเดินเครื่องไม่เกิน <span>226</span> ครั้ง)</p><p>เทคนิคสำคัญสำหรับการคว้าคะแนนในช่วงนี้จะอาศัยข้อสังเกตจากวิธีพื้นฐานที่ผ่านมา โดยใช้เห็ดที่เรารู้ชนิดอยู่แล้วเป็นจำนวนมากมาวางสับหว่างกับเห็ดที่เราต้องการนับ ซึ่งก็คือ สมมติว่าเรามีเห็ดที่รู้แน่ๆ ว่าเป็นชนิด <span>A</span> อยู่ <span>m</span> ดอก เราจะจัดเห็ดใส่ถาดเป็นลำดับเช่นนี้ก่อนส่งเข้าไปให้เครื่องจักรนับจำนวนครั้งของการเปลี่ยนแปลง</p><p><span>\\underbrace{x_1 \\, A \\; x_2 \\, A \\; x_3 \\, A \\; \\dots \\; x_m \\, A}_{2m\\text{ mushrooms}}</span></p><p>เมื่อ <span>x_i</span> สำหรับ <span>1 \\le i \\le m</span> แทนเห็ดดอกที่เรายังไม่ทราบชนิด เนื่องจากเราแค่ต้องการนับว่าจาก <span>x_1</span> ถึง <span>x_m</span> มีเห็ดชนิด <span>A</span> ทั้งหมดกี่ดอก โดยจำเป็นไม่ต้องสนใจว่าแต่ละ <span>x_i</span> จะเป็นเห็ดชนิดใด สังเกตว่านอกจากที่ <span>x_1</span> แล้ว หาก <span>x_i</span> ดอกอื่นๆ เป็นเห็ดชนิด <span>B</span> เครื่องจักรจะนับการเปลี่ยนแปลง ณ เห็ดดอกนั้นเพิ่มได้ 2 ครั้ง ส่วนเฉพาะที่ <span>x_1</span> จะนับเพิ่มเพียง 1 ครั้ง ดังนั้นหากให้คำตอบที่ได้จากเครื่องจักรคือ <span>R</span> เราจะได้ว่า</p><p><span>\\begin{align} \\text{COUNT}_B(m, R) &amp;= \\left\\lceil \\frac{R}2 \\right\\rceil \\\\ \\text{COUNT}_A(m, R) &amp;= m - \\text{COUNT}_B(m, R) \\end{align}</span></p><p>เทคนิคนี้ทำให้เราสามารถนับชนิดเห็ดจำนวนมากได้โดยไม่ต้องถามเครื่องจักรหลายครั้ง เช่น แม้ในกรณีที่ <span>n = 20,000</span> แต่หากในจำนวนนั้นเรารู้เห็ดชนิดเดียวกันเป็นจำนวน <span>m=100</span> อยู่ก่อนแล้ว เราสามารถใช้เครื่องจักรเพียงอีกแค่ <span>\\frac{n-m}m = 199</span> ครั้งเท่านั้น ก็จะนับจำนวนเห็ดแยกตามชนิดได้จนหมดครบทุกดอก</p><p>อย่างไรก็ตาม เรายังสามารถทำได้ดีกว่านั้นขึ้นไปอีก สังเกตว่าเห็ดดอกที่ <span>x_1</span> นั้นถูกนับอย่างแปลกประหลาดไม่เหมือนเพื่อน ซึ่งก็คือหากคำตอบ <span>R</span> เป็นเลขคู่ นั่นหมายความว่า <span>x_1</span> ต้องเป็นเห็ดชนิด <span>A</span> อย่างแน่นอน ดังนั้นหากในครั้งก่อนเราโชคดีเจอเห็ดชนิด <span>A</span> ครั้งถัดไปเราก็จะสามารถจัดถาดด้วยเห็ดที่ไม่รู้ชนิดได้มากขึ้นเป็น <span>m+1</span> ดอก และยิ่งเราเจอเห็ดชนิด <span>A</span> มากขึ้นเรื่อยๆ เท่าไหร่ เราก็จะยิ่งใช้เครื่องจักรได้อย่างมีประสิทธิภาพมากขึ้นเท่านั้น</p><p>แล้วเราจะโชคร้ายได้แค่ไหนกัน? หากเราไม่เจอเห็ดชนิด <span>A</span> เลย ถึงจุดหนึ่งเห็ดชนิด <span>B</span> จะมีจำนวนมากกว่าเห็ดชนิด <span>A</span> เราก็จะสลับไปใช้เห็ดชนิด <span>B</span> เป็นหลักในการสับหว่างถามเครื่องจักรแทนนั่นเอง พิจารณากรณีเริ่มต้นที่เรามีเห็ดชนิด <span>A</span> กับ <span>B</span> อยู่อย่างละประมาณ <span>m</span> ดอกพอกัน หากใช้เทคนิคในแนวเดียวกับ<a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\">การวิเคราะห์แบบถัวเฉลี่ย (amortized analysis)</a> จะเห็นว่าเมื่อใช้เครื่องจักรไปเรื่อยๆ ขอบเขตล่างของเห็ดกองที่ใหญ่กว่าจะมีเห็ดเพิ่มขึ้นมาหนึ่งดอกต่อการใช้เครื่องจักรสองครั้ง นั่นหมายความว่าอย่างแย่ที่สุดแล้ว เราจะถามเครื่องจักรด้วยจำนวนครั้งที่น้อยลงเหลือประมาณ</p><p><span>\\begin{align} n - 2m &amp;= \\overbrace{m + m + (m+1) + (m+1) + (m+2) + (m+2) + \\dots + (m+q-1)}^\\text{for simplicity, suppose we use the machine $2q$ times} \\\\ &amp;= 2 \\left( m + (m+1) + (m+2) + \\dots + (m+q-1) \\right) \\\\ &amp;= 2 \\left( qm + 1+2+\\dots+(q-1) \\right) \\\\ &amp;= 2 \\left( qm + \\frac{(q-1)q}2 \\right) \\\\ &amp;= 2qm + (q-1)q \\\\ 0 &amp;= q^2 + (2m-1)q - (2m-n) \\\\ 2q &amp;= 1 - 2m \\pm \\sqrt{4m^2 -12m + 4n + 1} \\\\ \\end{align}</span></p><p>ซึ่งก็คือ ที่ <span>n=20,000</span> และ <span>m=100</span> จะได้ว่าต้องถามเครื่องจักรอย่างมากที่สุด <span>2q \\approx 145.7</span> ครั้งเท่านั้น</p><p>คำถามตอนนี้จะเหลือเพียงแค่ว่า ก่อนที่จะใช้ขั้นตอนวิธีที่เล่ามาเพื่อนับเห็ดแยกชนิดในระยะที่สอง เราควรทำอย่างไรเพื่อหาเห็ดชนิดเดียวกันมาให้ได้ <span>m</span> ดอกในระยะที่หนึ่ง หากเราใช้วิธีพื้นฐานที่สุด (10 คะแนน) ที่ค่อยๆ ถามเห็ดที่ยังไม่รู้ชนิดครั้งละดอก จะเห็นว่าเราต้องถามอย่างมากสุด <span>2m-1</span> ครั้งถึงจะมั่นใจได้ว่าได้เห็ดชนิดใดชนิดหนึ่งอย่างน้อย <span>m</span> ดอก เมื่อนำขั้นตอนย่อยในระยะที่หนึ่งกับระยะที่สองมารวมกันก็จะได้ขั้นตอนวิธีสำหรับนับเห็ดทั้งหมด อย่างไรก็ตามเราจะพบว่าขั้นตอนวิธีนี้ยังมีประสิทธิภาพไม่ดีพอ เพราะด้วยกรณีที่ผ่านมาเราอาจยังต้องถามมากถึง <span>199 + 146 = 345</span> ครั้ง หรือคิดออกมาเป็นคะแนนได้ <span>100 \\cdot 226 \\div 345 \\approx 77</span> คะแนน</p><h2 id=\"เก็บงานให้เรียบร้อยมุ่งสู่คะแนนเต็ม\">เก็บงานให้เรียบร้อยมุ่งสู่คะแนนเต็ม</h2><p>จากหัวข้อที่ผ่านมา จะเห็นว่าการหาเห็ดชนิดเดียวกันให้ได้ <span>m</span> ดอกในระยะที่หนึ่งนั้นยังมีประสิทธิภาพไม่ดีนัก เราจะปรับปรุงส่วนนี้ด้วยการใช้เครื่องจักรเพียง 1 ครั้งแล้วพยายามบอกชนิดของเห็ดให้ได้ 2.5 ดอกโดยเฉลี่ย</p><p>เนื่องจากเริ่มต้นมาเรารู้ชนิดเห็ดที่แน่ชัดอยู่เพียงแค่ดอกเดียว ดังนั้นการถามครั้งแรกๆ คงเลี่ยงไม่ได้ที่ต้องถามเห็ดครั้งละหนึ่งดอก (จัดถาดเห็ดอยู่ในรูป <span>x_1A</span>) เราจะใช้เทคนิค<strong>ถามหนึ่งรู้หนึ่ง</strong>ไม่เกิน 2 ครั้ง เพื่อรับประกันว่าจะมีเห็ดชนิดใดชนิดหนึ่งจำนวน 2 ดอก</p><p>เมื่อมีเห็ดชนิดเดียวกัน 2 ดอกแล้ว (ต่อไปนี้เพื่อความสะดวกจะสมมติให้เห็ดชนิดที่มีมากกว่าเป็นชนิด <span>A</span> ไปเลย) เราจะจัดถาดเห็ดถามในรูป <span>x_1A\\,x_2A</span> ซึ่งก็คือถามครั้งเดียวระบุชนิดเห็ดได้ถึงสองดอก เพราะคำตอบในเลขฐานสองของการถามเช่นนี้จะสามารถบอกได้ทันทีว่าเห็ดดอกใดเป็นชนิดไหน ซึ่งก็คือ</p><ol><li>บิตที่ 0 ของคำตอบเป็น 0 เมื่อและก็ต่อเมื่อ <span>x_1</span> เป็นเห็ดชนิด <span>A</span></li><li>บิตที่ 1 ของคำตอบเป็น 0 เมื่อและก็ต่อเมื่อ <span>x_2</span> เป็นเห็ดชนิด <span>A</span></li></ol><p>เราจะใช้เทคนิค<strong>ถามสองรู้สอง</strong>อีกเพียงไม่เกิน 2 ครั้ง ก็จะได้เห็ดชนิด <span>A</span> มาอย่างน้อย 3 ดอก</p><p>หลังจากนั้นเราจะจัดถาดด้วยเห็ดที่ไม่รู้ชนิดครั้งละสามดอกเช่นนี้ <span>x_1A\\,x_2A\\,x_3A</span> จากเทคนิคที่เคยเห็นผ่านมาแล้ว เราคงบอกได้ไม่ยากว่า <span>x_1</span> คือเห็ดชนิด <span>A</span> หรือไม่ อย่างไรก็ตามสำหรับ <span>x_2</span> และ <span>x_3</span> นั้น เราพบว่า</p><ol><li>หากคำตอบเป็น 0 หรือ 1 นั่นคือ <span>x_2</span> และ <span>x_3</span> เป็นเห็ดชนิด <span>A</span> ทั้งคู่</li><li>หากคำตอบเป็น 4 หรือ 5 นั่นคือ <span>x_2</span> และ <span>x_3</span> เป็นเห็ดชนิด <span>B</span> ทั้งคู่</li><li>หากคำตอบเป็น 2 หรือ 3 จะบอกได้แค่ว่า <span>x_2</span> กับ <span>x_3</span> เป็นเห็ดชนิดต่างกัน</li></ol><p>เทคนิคดังกล่าวคือการ<strong>ถามสามอาจรู้หนึ่งหรือสาม</strong> หากมันล้มเหลวโดยระบุชนิดเห็ดได้เพียงดอกเดียว อย่างน้อยเราจะรู้ว่าเห็ดอีกสองดอกต้องไม่เป็นชนิดเดียวกัน ถึงตอนนี้เราจะจัดการกับความกำกวมนี้โดยใช้เห็ดชนิด <span>B</span> เข้ามาช่วย ซึ่งแบ่งได้เป็น 2 กรณี คือ</p><p>กรณีแรกเมื่อเรามีเห็ดชนิด <span>B</span> อยู่น้อยกว่า 2 ดอก เราจะใช้เทคนิคแบบเดียวกับ<strong>ถามสองรู้สอง</strong>เลย เพียงแต่เปลี่ยนไปจัดถาดเห็ดด้วย <span>x_3A\\,x_4A</span> นอกจากนี้อย่าลืมว่าชนิดของเห็ด <span>x_3</span> ที่หาได้ก็จะบ่งบอกย้อนไปถึงชนิดของเห็ด <span>x_2</span> ด้วย เราจะเรียกเทคนิคนี้ว่า<strong>แก้กำกวมถามสองรู้สาม</strong></p><p>ส่วนอีกกรณีเราจะจัดถาดเห็ด <span>B\\,x_2BA\\,x_3A\\,x_4A\\,x_5</span> เพื่อถามเครื่องจักร เมื่อนำคำตอบที่ได้ไปลบหนึ่ง (เพราะมีการเปลี่ยนแปลงแน่ๆ จากคู่เห็ดที่เราตั้งใจใส่เข้าไปหนึ่งครั้ง) คำตอบใหม่จะมีค่าได้ตั้งแต่ 0 ถึง 7 พิจารณาคำตอบใหม่นี้ในเลขฐานสองจะพบว่า</p><ol><li>บิตที่ 2 ของคำตอบใหม่เป็น 0 เมื่อและก็ต่อเมื่อ <span>x_3</span> เป็นเห็ดชนิด <span>A</span></li><li>บิตที่ 1 ของคำตอบใหม่เป็น 0 เมื่อและก็ต่อเมื่อ <span>x_4</span> เป็นเห็ดชนิด <span>A</span></li><li>บิตที่ 0 ของคำตอบใหม่เป็น 0 เมื่อและก็ต่อเมื่อ <span>x_5</span> เป็นเห็ดชนิด <span>A</span></li></ol><p>เรียกกระบวนการนี้ว่า<strong>แก้กำกวมถามสี่รู้สี่</strong> (และเช่นเคย ชนิดเห็ดของ <span>x_3</span> จะบ่งบอกชนิดเห็ด <span>x_2</span>) ดังนั้นในภาพรวม เราจะใช้เทคนิค<strong>ถามสามอาจรู้หนึ่งหรือสาม</strong>ไปเรื่อยๆ แล้วสลับไปเลือกใช้เทคนิค<strong>แก้กำกวมถามสองรู้สาม</strong>หรือ<strong>แก้กำกวมถามสี่รู้สี่</strong> จนกระทั่งเราได้เห็ดชนิด <span>A</span> มาอย่างน้อย <span>m</span> ดอก</p><p>แล้วเราจะต้องใช้เครื่องจักรในระยะที่หนึ่งด้วยเทคนิคเหล่าไปเป็นจำนวนเท่าไหร่? สมมติว่าเราสนใจ <span>m</span> ขนาดใหญ่ๆ เราอาจตัดการ<strong>ถามหนึ่งรู้หนึ่ง</strong>และ<strong>ถามสองรู้สอง</strong>ที่จะเกิดขึ้นเพียงไม่กี่ครั้งออกจากการวิเคราะห์ไปเลย หลังจากนั้นเราจะ<strong>ถามสามอาจรู้หนึ่งหรือสาม</strong>เป็นส่วนใหญ่ ซึ่งอาจให้ประสิทธิภาพแย่ได้หากต้องแก้กำกวมเป็นจำนวนมาก แต่เนื่องจากการ<strong>แก้กำกวมถามสองรู้สาม</strong>เกิดขึ้นได้อย่างมากที่สุดเพียง 2 ครั้ง เราอาจตัดมันออกจากการวิเคราะห์ได้ด้วยเช่นกัน เหลือเพียงแค่การ<strong>แก้กำกวมถามสี่รู้สี่</strong> ดังนั้นด้วยคู่ของการ<strong>ถามสามอาจรู้หนึ่งหรือสาม</strong>และ<strong>แก้กำกวมถามสี่รู้สี่</strong>จะระบุชนิดเห็ดได้ 5 ดอกต่อการถาม 2 ครั้ง และเนื่องจากเราอาจต้องระบุชนิดเห็ดมากถึง <span>2m</span> ดอก ดังนั้นเราจะต้องถามประมาณ <span>2m/2.5 = 0.8m</span> ครั้งนั่นเอง</p><p>ให้ <span>Q_n(m)</span> เป็นจำนวนครั้งทั้งหมดที่ต้องถามเครื่องจักร ก็จะได้ว่า</p><p><span>\\begin{align} Q_n(m) &amp;= 0.8m + 1 - 2m \\pm \\sqrt{4m^2 -12m + 4n + 1} \\\\ Q'_n(m) &amp;= \\frac{4m-6}{\\sqrt{4m^2 - 12m + 4n + 1}} - \\frac65 \\end{align}</span></p><p>แก้อนุพันธ์ <span>Q’_n(m) = 0</span> เพื่อหาค่า <span>m</span> ที่เหมาะสมที่สุด จะได้</p><p><span>m = \\frac34\\left( 2 \\pm \\sqrt{n-2} \\right)</span></p><p>นั่นก็คือ ในกรณีที่ <span>n=20,000</span> เราควรหาเห็ดชนิดเดียวกันในระยะที่หนึ่งไว้ประมาณ <span>m \\approx 107.6</span> ดอก แล้วหลังจากนั้นจึงแค่นับชนิดเห็ดที่สนใจพร้อมค่อยๆ ขยายปริมาณเห็ดที่รู้ชนิดในระยะที่สอง ซึ่งทั้งหมดนี้จะทำให้เครื่องจักรถูกเรียกใช้รวมไม่เกิน <span>Q_n(108) \\approx 225.5</span> ครั้ง</p><h2 id=\"โค้ด\">โค้ด</h2><div><pre><code><span>#include \"mushrooms.h\"\n#include &lt;bits/stdc++.h&gt;\n</span><span>using</span> <span>namespace</span> <span>std</span><span>;</span>\n\n<span>bool</span> <span>swapped</span> <span>=</span> <span>false</span><span>;</span>\n<span>bool</span> <span>conflict</span> <span>=</span> <span>false</span><span>;</span>\n<span>int</span> <span>i</span> <span>=</span> <span>1</span><span>;</span>\n<span>int</span> <span>just_count_A</span> <span>=</span> <span>0</span><span>;</span>\n<span>int</span> <span>just_count_B</span> <span>=</span> <span>0</span><span>;</span>\n<span>vector</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>A</span> <span>=</span> <span>{</span> <span>0</span> <span>};</span>\n<span>vector</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>B</span> <span>=</span> <span>{</span> <span>};</span>\n\n<span>int</span> <span>calc_pivots_size</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span>\n    <span>return</span> <span>1.5</span> <span>+</span> <span>(</span><span>3</span><span>*</span><span>sqrt</span><span>(</span><span>n</span><span>-</span><span>2</span><span>)</span><span>/</span><span>4</span><span>);</span>\n<span>}</span>\n\n<span>void</span> <span>make_swap</span><span>()</span> <span>{</span>\n    <span>swapped</span> <span>=</span> <span>not</span> <span>swapped</span><span>;</span>\n    <span>swap</span><span>(</span><span>just_count_A</span><span>,</span> <span>just_count_B</span><span>);</span>\n    <span>swap</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>);</span>\n<span>}</span>\n\n<span>bool</span> <span>decide_swap</span><span>()</span> <span>{</span>\n    <span>if</span> <span>(</span><span>A</span><span>.</span><span>size</span><span>()</span> <span>&lt;</span> <span>B</span><span>.</span><span>size</span><span>())</span> <span>{</span>\n        <span>make_swap</span><span>();</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>handle_parity</span><span>(</span><span>int</span> <span>parity</span><span>)</span> <span>{</span>\n    <span>(</span><span>parity</span> <span>==</span> <span>0</span> <span>?</span> <span>A</span> <span>:</span> <span>B</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>);</span>\n    <span>return</span> <span>1</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>handle_pair</span><span>(</span><span>int</span> <span>raw_info</span><span>)</span> <span>{</span>\n    <span>int</span> <span>flag2b</span> <span>=</span> <span>raw_info</span> <span>&gt;&gt;</span> <span>1</span><span>;</span>\n    <span>if</span> <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b01</span><span>)</span> <span>{</span>\n        <span>conflict</span> <span>=</span> <span>true</span><span>;</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b10</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>);</span>\n    <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b10</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>1</span><span>);</span>\n    <span>return</span> <span>2</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>handle_conflict_slow</span><span>(</span><span>int</span> <span>flag2b</span><span>)</span> <span>{</span>\n    <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b01</span> <span>?</span> <span>A</span> <span>:</span> <span>B</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>);</span>\n    <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b01</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>1</span><span>);</span>\n    <span>(</span><span>flag2b</span> <span>&amp;</span> <span>0b10</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>2</span><span>);</span>\n    <span>conflict</span> <span>=</span> <span>false</span><span>;</span>\n    <span>return</span> <span>3</span><span>;</span>\n<span>}</span>\n\n<span>int</span> <span>handle_conflict_fast</span><span>(</span><span>int</span> <span>raw_info</span><span>)</span> <span>{</span>\n    <span>int</span> <span>flag3b</span> <span>=</span> <span>raw_info</span> <span>-</span> <span>1</span><span>;</span>\n    <span>(</span><span>flag3b</span> <span>&amp;</span> <span>0b100</span> <span>?</span> <span>A</span> <span>:</span> <span>B</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>);</span>\n    <span>(</span><span>flag3b</span> <span>&amp;</span> <span>0b100</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>1</span><span>);</span>\n    <span>(</span><span>flag3b</span> <span>&amp;</span> <span>0b010</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>2</span><span>);</span>\n    <span>(</span><span>flag3b</span> <span>&amp;</span> <span>0b001</span> <span>?</span> <span>B</span> <span>:</span> <span>A</span><span>).</span><span>push_back</span><span>(</span><span>i</span><span>+</span><span>3</span><span>);</span>\n    <span>conflict</span> <span>=</span> <span>false</span><span>;</span>\n    <span>return</span> <span>4</span><span>;</span>\n<span>}</span>\n\n<span>void</span> <span>get_pivots</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span>\n    <span>int</span> <span>info</span><span>;</span>\n    <span>int</span> <span>size</span> <span>=</span> <span>calc_pivots_size</span><span>(</span><span>n</span><span>);</span>\n    <span>while</span> <span>(</span><span>decide_swap</span><span>()</span> <span>and</span> <span>(</span><span>int</span><span>)</span><span>A</span><span>.</span><span>size</span><span>()</span> <span>&lt;</span> <span>size</span> <span>and</span> <span>i</span><span>+</span><span>4</span> <span>&lt;</span> <span>n</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>not</span> <span>conflict</span><span>)</span> <span>{</span>\n            <span>switch</span> <span>(</span><span>A</span><span>.</span><span>size</span><span>())</span> <span>{</span>\n                <span>case</span> <span>1</span><span>:</span>\n                    <span>i</span> <span>+=</span> <span>handle_parity</span><span>(</span><span>use_machine</span><span>({</span> <span>i</span><span>,</span> <span>A</span><span>[</span><span>0</span><span>]</span> <span>}));</span>\n                    <span>break</span><span>;</span>\n                <span>case</span> <span>2</span><span>:</span>\n                    <span>info</span> <span>=</span> <span>use_machine</span><span>({</span> <span>i</span><span>,</span> <span>A</span><span>[</span><span>0</span><span>],</span> <span>i</span><span>+</span><span>1</span><span>,</span> <span>A</span><span>[</span><span>1</span><span>]</span> <span>});</span>\n                    <span>i</span> <span>+=</span> <span>handle_parity</span><span>(</span><span>info</span><span>%</span><span>2</span><span>);</span>\n                    <span>i</span> <span>+=</span> <span>handle_parity</span><span>(</span><span>info</span><span>/</span><span>2</span><span>);</span>\n                    <span>break</span><span>;</span>\n                <span>default:</span>\n                    <span>info</span> <span>=</span> <span>use_machine</span><span>({</span> <span>i</span><span>,</span> <span>A</span><span>[</span><span>0</span><span>],</span> <span>i</span><span>+</span><span>1</span><span>,</span> <span>A</span><span>[</span><span>1</span><span>],</span> <span>i</span><span>+</span><span>2</span><span>,</span> <span>A</span><span>[</span><span>2</span><span>]</span> <span>});</span>\n                    <span>i</span> <span>+=</span> <span>handle_parity</span><span>(</span><span>info</span><span>%</span><span>2</span><span>);</span>\n                    <span>i</span> <span>+=</span> <span>handle_pair</span><span>(</span><span>info</span><span>);</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>B</span><span>.</span><span>size</span><span>()</span> <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>\n            <span>info</span> <span>=</span> <span>use_machine</span><span>({</span> <span>i</span><span>+</span><span>1</span><span>,</span> <span>A</span><span>[</span><span>0</span><span>],</span> <span>i</span><span>+</span><span>2</span><span>,</span> <span>A</span><span>[</span><span>1</span><span>]</span> <span>});</span>\n            <span>i</span> <span>+=</span> <span>handle_conflict_slow</span><span>(</span><span>info</span><span>);</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>info</span> <span>=</span> <span>use_machine</span><span>({</span> <span>B</span><span>[</span><span>0</span><span>],</span> <span>i</span><span>,</span> <span>B</span><span>[</span><span>1</span><span>],</span> <span>A</span><span>[</span><span>0</span><span>],</span> <span>i</span><span>+</span><span>1</span><span>,</span> <span>A</span><span>[</span><span>1</span><span>],</span> <span>i</span><span>+</span><span>2</span><span>,</span> <span>A</span><span>[</span><span>2</span><span>],</span> <span>i</span><span>+</span><span>3</span> <span>});</span>\n            <span>i</span> <span>+=</span> <span>handle_conflict_fast</span><span>(</span><span>info</span><span>);</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>vector</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>make_sample</span><span>(</span><span>int</span> <span>size</span><span>)</span> <span>{</span>\n    <span>vector</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>sample</span> <span>=</span> <span>{</span> <span>};</span>\n    <span>for</span> <span>(</span><span>int</span> <span>j</span><span>=</span><span>0</span><span>;</span> <span>j</span><span>&lt;</span><span>size</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>\n        <span>sample</span><span>.</span><span>insert</span><span>(</span><span>sample</span><span>.</span><span>end</span><span>(),</span> <span>{</span> <span>i</span><span>+</span><span>j</span><span>,</span> <span>A</span><span>[</span><span>j</span><span>]</span> <span>});</span>\n    <span>}</span>\n    <span>return</span> <span>sample</span><span>;</span>\n<span>}</span>\n\n<span>void</span> <span>count_the_rest</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span>\n    <span>while</span> <span>(</span><span>decide_swap</span><span>()</span> <span>and</span> <span>i</span> <span>&lt;</span> <span>n</span><span>)</span> <span>{</span>\n        <span>int</span> <span>test_size</span> <span>=</span> <span>min</span><span>((</span><span>int</span><span>)</span><span>A</span><span>.</span><span>size</span><span>(),</span> <span>n</span><span>-</span><span>i</span><span>);</span>\n        <span>int</span> <span>info</span> <span>=</span> <span>use_machine</span><span>(</span><span>make_sample</span><span>(</span><span>test_size</span><span>));</span>\n        <span>i</span> <span>+=</span> <span>handle_parity</span><span>(</span><span>info</span><span>%</span><span>2</span><span>);</span>\n        <span>i</span> <span>+=</span> <span>test_size</span><span>-</span><span>1</span><span>;</span>\n        <span>just_count_A</span> <span>+=</span> <span>(</span><span>test_size</span><span>-</span><span>1</span><span>)</span> <span>-</span> <span>(</span><span>info</span><span>/</span><span>2</span><span>);</span>\n        <span>just_count_B</span> <span>+=</span> <span>info</span><span>/</span><span>2</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>int</span> <span>count_mushrooms</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span>\n    <span>get_pivots</span><span>(</span><span>n</span><span>);</span>\n    <span>count_the_rest</span><span>(</span><span>n</span><span>);</span>\n    <span>if</span> <span>(</span><span>swapped</span><span>)</span> <span>{</span>\n        <span>make_swap</span><span>();</span>\n    <span>}</span>\n    <span>return</span> <span>A</span><span>.</span><span>size</span><span>()</span> <span>+</span> <span>just_count_A</span><span>;</span>\n<span>}</span>\n</code></pre></div><div><div><p><img src=\"https://neizod.dev/images/people/neizod.png\" width=\"72\" height=\"72\"></p></div><div><p><img src=\"https://neizod.dev/images/people/nonthaphat.png\" width=\"72\" height=\"72\"></p><div><p>Nonthaphat Wongwattanakij</p><p><em>coauthor, coder</em></p></div></div></div></div></div>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"bb8bf1e22de0862f6e2c3950f6e846a93b4e031c22d7ee5db374557caacd7e61","category":"Thai"}