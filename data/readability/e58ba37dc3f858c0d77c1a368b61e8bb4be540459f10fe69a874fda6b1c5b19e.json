{"title":"Should The Web Expose Hardware Capabilities?","link":"https://smashingmagazine.com/2021/01/web-expose-hardware-capabilities/","date":1609849800000,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"article__content\"><div><div><figure role=\"presentation\"><a href=\"https://www.smashingmagazine.com/author/noam-rosenthal\"><p><img src=\"https://www.gravatar.com/avatar/09b04558fb5eea5e18edca11d811d6b8?s=400&amp;d=mm&amp;r=g\" loading=\"eager\" width=\"100\" height=\"100\" alt=\"Noam Rosenthal\"></p></a></figure></div><div id=\"author__desc\"><p>Noam Rosenthal is an independent web platform consultant, a WebKit reviewer, and a contributor to Chromium and to several web standards. Recently Noam has … <a href=\"https://www.smashingmagazine.com/author/noam-rosenthal\">More about Noam ↬</a></p></div></div><p><section aria-label=\"quick summary\">This article is a response to the <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/\">Platform Adjacency Theory</a> by <a href=\"https://twitter.com/slightlylate\">Alex Russell</a>, with specific takes on <a href=\"https://wicg.github.io/webusb/\">WebUSB</a> and some alternative proposals for a way forward.</section></p><p>I have recently been interested in the difference of opinions between the different browser vendors about the future of the web — specifically in the various efforts to push web platform capabilities closer to native platforms, such as Chromium’s <a href=\"https://www.chromium.org/teams/web-capabilities-fugu\">Project Fugu</a>.</p><p>The main positions can be summarized as:</p><ul><li>Google (together with partners like Intel, Microsoft and Samsung) is aggressively pushing forward and innovating with a plethora of new APIs like the ones in Fugu, and ships them in Chromium;</li><li>Apple is pushing back with a more conservative approach, marking many of the new APIs as <a href=\"https://webkit.org/tracking-prevention/\">raising security &amp; privacy concerns</a>;</li><li>This (together with Apple’s <a href=\"https://developer.apple.com/app-store/review/guidelines/#software-requirements\">restrictions on browser choice in iOS</a>) has created a stance labeling Safari to be the <a href=\"https://www.safari-is-the-new-ie.com/\">new IE</a> while claiming that Apple is slowing down the progress of the web;</li><li>Mozilla seems closer to Apple than to Google on this.</li></ul><p>My intention in this article is to look at claims identified with Google, specifically ones in the <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/\">Platform Adjacency Theory</a> by Project Fugu leader Alex Russell, look at the evidence presented in those claims, and perhaps reach my own conclusion.</p><p>Specifically, I intend to dive into <a href=\"https://wicg.github.io/webusb/\">WebUSB</a> (a particular controversial API from Project Fugu), check whether the security claims against it have merit, and try to see if an alternative emerges.</p><h3 id=\"the-platform-adjacency-theory\">The Platform Adjacency Theory</h3><p>The aforementioned <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/\">theory</a> makes the following claims:</p><ul><li>Software is moving to the web because it is a better version of computing;</li><li>The web is a meta-platform — a platform abstracted from its operating system;</li><li>The success of a meta-platform is based on it accomplishing the things we expect most computers to do;</li><li>Declining to add adjacent capabilities to the web meta-platform on security grounds, while ignoring the same security issues in native platforms, will eventually make the web less and less relevant;</li><li>Apple &amp; Mozilla are doing exactly that — declining to add adjacent computing capabilities to the web, thus “casting the web in amber”.</li></ul><p>I relate with the author’s passion for keeping the open web relevant, and with the concern that going too slow with enhancing the web with new features will make it irrelevant. This is augmented by my dislike of app stores and other <a href=\"https://en.wikipedia.org/wiki/Closed_platform\">walled gardens</a>. But as a user I can relate to the opposite perspective — I get dizzy sometimes when I don’t know what websites I’m browsing are capable or not capable of doing, and I find platform restrictions and auditing to be comforting.</p><h4 id=\"meta-platforms\">Meta-Platforms</h4><p>To understand the term “meta-platform”, I looked at what the theory uses that name for — Java and Flash, both products of the turn of the millennium.</p><p>I find it confusing to compare either Java or Flash to the web. Both Java and Flash, as mentioned in the theory, were widely distributed at the time through browser plug-ins, making them more of an alternative runtime riding on top of the browser platform. Today, Java is used mainly in the server and as part of the Android platform, and both do not share much in common, except the language.</p><p>Today server-side Java is perhaps a meta-platform, and <a href=\"https://nodejs.org/\">node.js</a> is also a good example of a server-side meta-platform. It’s a set of APIs, a cross-platform runtime, and a package ecosystem. Indeed node.js is always adding more capabilities, previously only possible as part of a platform.</p><p>On the client side, <a href=\"https://www.qt.io/\">Qt</a>, a C++-based cross-platform framework, does not come with a separate runtime, it’s merely a (good!) cross-platform library for UI development.</p><p>The same applies for <a href=\"https://www.rust-lang.org/\">Rust</a> — it’s a language and a package manager, but does not depend on pre-installed runtimes.</p><p>The other ways to develop client-side applications are mainly platform-specific, but also include some cross-platform mobile solutions like <a href=\"https://flutter.dev/\">Flutter</a> and <a href=\"https://dotnet.microsoft.com/learn/xamarin/what-is-xamarin\">Xamarin</a>.</p><h4 id=\"marker\">Capabilities vs. Time</h4><p>The main graph in the theory, shows the relevance of meta-platforms on a 2D axis of capabilities vs. time:</p><figure><a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/\"><img loading=\"lazy\" decoding=\"async\" importance=\"low\" srcset=\"https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_400/the-relevance-gap_kzwi6q.png 400w, https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_800/the-relevance-gap_kzwi6q.png 800w, https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_1200/the-relevance-gap_kzwi6q.png 1200w, https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_1600/the-relevance-gap_kzwi6q.png 1600w, https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_2000/the-relevance-gap_kzwi6q.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/upload/f_auto,q_auto/w_400/the-relevance-gap_kzwi6q.png\" sizes=\"100vw\" alt=\"The Relevance Gap\"></a><figcaption>Image credit: <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/\">Alex Russell</a></figcaption></figure><p>I can see how the above graph makes sense when talking about cross-platform development frameworks mentioned above like Qt, Xamarin, Flutter and Rust, and also to server platforms like node.js and Java/Scala.</p><p>But all of the above have a key difference from the web.</p><h3 id=\"the-3rd-dimension\">The 3rd Dimension</h3><p>The meta-platforms mentioned earlier are indeed competing against their host OSes in the race for capabilities, but unlike the web, they are not opinionated about <em>trust</em> and <em>distribution</em> — the 3rd dimension, that in my opinion is missing in the above graph.</p><p>Qt and Rust are good ways to create apps that are distributed via <a href=\"https://webassembly.org/\">WebAssembly</a>, downloaded and installed directly on the host OS, or administered through package managers like <a href=\"https://crates.io/\">Cargo</a> or Linux distributions like <a href=\"https://ubuntu.com/\">Ubuntu</a>. <a href=\"https://reactnative.dev/\">React Native</a>, Flutter and Xamarin are all decent ways to create apps that are distributed via app stores. node.js and Java services are usually distributed via a <a href=\"https://www.docker.com/\">docker</a> container, a virtual machine, or some other server mechanism.</p><p>Users are mostly unaware of what was used to develop their content, but are aware to some degree of how it is distributed. Users don’t know what Xamarin and node.js are, and if their Swift App was replaced one day by a Flutter App, most users wouldn’t and ideally shouldn’t care about it.</p><p>But users <em>do</em> know the web — they know that when they’re “browsing” in Chrome or Firefox, they are “online” and can access content they don’t necessarily trust. They know that downloading software and installing it is a possible hazard, and might be blocked by their IT administrator. In fact, it’s important for the web platform that users know that they’re currently “browsing the web”. That’s why, for example, switching to full-screen mode shows a clear prompt to the user, with instructions of how to get back from it.</p><p>The web has become successful <em>because</em> it’s not transparent — but clearly separated from its host OS. If I can’t trust my browser to keep random websites away from reading files on my hard-drive, I probably wouldn’t go to any website.</p><p>Users also know that their computer software is “Windows” or “Mac”, whether their phones are Android or iOS-based, and whether they’re currently using an <em>app</em> (when on iOS or Android, and on Mac OS to some degree). The <em>OS</em> and the <em>distribution model</em> are generally known to the user — the user trusts their OS and the web to do different things, and to different degrees of trust.</p><p>So, the web cannot be compared to cross-platform development frameworks, without taking its unique distribution model into account.</p><p>On the other hand, web technologies are also used for cross-platform development, with frameworks like <a href=\"https://www.electronjs.org/\">Electron</a> and <a href=\"https://cordova.apache.org/\">Cordova</a>. But those are not exactly “the web”. When compared to Java or node.js, The term “The web” needs to be substituted with “Web Technologies”. And “web technologies” used in this way don’t necessarily need to be standard-based or work on multiple browsers. The conversation about Fugu APIs is somewhat tangential to Electron and Cordova.</p><h4 id=\"native-apps\">Native Apps</h4><p>When adding capabilities to the web platform, the 3rd dimension — the trust and distribution model — cannot be ignored, or taken lightly. When the author claims that <em>“Apple and Mozilla posturing about risks from new capabilities is belied by accepted extant native platform risks”</em>, he is putting the web and native platforms in the same dimension in regards to trust.</p><p>Granted, native apps have their <a href=\"https://www.imore.com/malicious-apps-ios-and-android-clock-24-million-downloads-500000-revenue\">own security issues</a> and challenges. But I don’t see how that’s an argument in favor of more web capabilities, like <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/#fn-platform-adjacency-theory-25\">here</a>. This is a fallacy — the conclusion should be fixing security issues with native apps, not relaxing security for web apps because they’re in a relevance catch-up game with OS capabilities.</p><p>Native and web cannot be compared in terms of capabilities, without taking the 3rd dimension of trust and distribution model into account.</p><h4 id=\"app-store-limitations\">App Store Limitations</h4><p>One of the criticisms about native apps in the theory is about <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/#fn-platform-adjacency-theory-22\">lack of browser engine choice</a> on iOS. This is a common thread of criticism against Apple, but there is more than one perspective to this.</p><p>The criticism is specifically about <a href=\"https://developer.apple.com/app-store/review/guidelines/#software-requirements\">Item 2.5.6</a> of Apple’s app store review guidelines:</p><blockquote>“Apps that browse the web must use the appropriate WebKit framework and WebKit JavaScript.”</blockquote><p>This might seem anti-competitive, and I do have my own reservation about how restrictive iOS is. But item 2.5.6 cannot be read without the context of the rest of the app-store review guidelines, for example <a href=\"https://developer.apple.com/app-store/review/guidelines/#accurate-metadata\">Item 2.3.12</a>:</p><blockquote>“Apps must clearly describe new features and product changes in their ‘What’s New’ text.”</blockquote><p>If an app could receive device access permissions, and then included its own framework that could execute code from any web site out there, those items in the app store review guidelines would become meaningless. Unlike apps, web sites don’t have to describe their features and product changes with every revision.</p><p>This becomes an even bigger problem when browsers ship experimental features, like the ones in project Fugu, which are not yet considered a standard. Who defines what a browser is? By allowing apps to ship any web framework, the app store would essentially allow the “app” to run any unaudited code, or change the product completely, circumventing the store’s review process.</p><p>As a user of both web sites and apps, I think both of them have space in the computing world, although I hope as much as possible could move to the web. But when considering the current state of web standards, and how the dimension of trust and sandboxing around things like Bluetooth and USB is far from being solved, I don’t see how allowing apps to freely execute content from the web would be beneficial for users.</p><h4 id=\"the-pursuit-of-appiness\">The Pursuit Of Appiness</h4><p>In another related <a href=\"https://infrequently.org/2020/09/the-pursuit-of-appiness/\">blog post</a>, the same author addresses some of this, when speaking about native apps:</p><blockquote>“Being ‘an app’ is merely meeting a set of arbitrary and changeable OS conventions.”</blockquote><p>I agree with the notion that the definition of “app” is arbitrary, and that its definition relies on whoever defines the app store policies. But today, the same is true for browsers. The claim from the post that <em>web applications are safe by default</em> is also somewhat arbitrary. Who draws the line in the sand of “what is a browser”? Is the Facebook app with a built-in browser “a browser”?</p><p>The definition of an app is arbitrary, but also important. The fact that every revision of an application using low-level capabilities is audited by <em>someone</em> that I might trust, even if that someone is arbitrary, makes apps what they are. If that <em>someone</em> is the manufacturer of the hardware I’ve paid for, it makes it even less arbitrary — the company that I’ve bought my computer from is the one auditing software with lower capabilities to that computer.</p><h4 id=\"everything-can-be-a-browser\">Everything Can Be A Browser</h4><p>Without drawing a line of “what’s a browser”, which is what the Apple app store essentially does, every app could ship its own web engine, lure the user to browse to any website using its in-app browser, and add whatever tracking code it wants, collapsing the 3rd dimension difference between apps and websites.</p><p>When I use an app on iOS, I know my actions are currently exposed to two players: Apple &amp; the identified app manufacturer. When I use a website on Safari or in a Safari WebView, my actions are exposed to Apple &amp; to the owner of the top-level domain of the web site I’m currently viewing. When I use an in-app browser with an unidentified engine, I am exposed to Apple, the manufacturer of the app, and to the owner of the top-level domain. This can create avoidable same-origin violations, such as the owner of the app tracking all of my clicks on foreign websites.</p><p>I agree that perhaps the line in the sand of “Only WebKit” is too harsh. What would be an alternative definition of a browser that wouldn’t create a backdoor for tracking user browsing?</p><h4 id=\"other-criticism-about-apple\">Other Criticism About Apple</h4><p>The theory claims that Apple’s decline to implement features is not limited to privacy/security concerns. It includes a <a href=\"https://caniuse.com/?compare=chrome+86,chrome+89,safari+TP&amp;compareCats=all\">link</a>, which does indeed show a lot of features that are implemented in Chrome and not in Safari. However, when scrolling down, it also lists a sizable amount of other features that are implemented in Safari and not in Chrome.</p><p>Those two browser projects have different priorities, but it’s far from the categorical statement <a href=\"https://infrequently.org/2020/06/platform-adjacency-theory/#fn-platform-adjacency-theory-18\">“The game becomes clear when zooming out”</a> and from the harsh criticism about Apple trying to cast the web in amber.</p><p>Also, the links titled <strong>it’s hard and we don’t want to try</strong> lead to Apple’s <a href=\"https://twitter.com/othermaciej/status/1277836968605265921?s=20\">statements</a> that they would implement features if security/privacy concerns were met. I feel that putting these links with those titles is misleading.</p><p>I would agree with a more balanced statement, that Google is a lot more bullish than Apple about implementing features and advancing the web.</p><h4 id=\"permission-prompt\">Permission Prompt</h4><p>Google goes long innovative ways in the 3rd dimension, developing new ways to broker trust between the user, the developer and the platform, sometimes with great success, like in the case of <a href=\"https://developers.google.com/web/android/trusted-web-activity\">Trusted Web Activities</a>.</p><p>But still, most of the work in the 3rd dimension as it relates to device APIs is focused around permission prompts and <a href=\"https://twitter.com/reillyeon/status/1321484051006414848\">making them more scary</a>, or things like time-box permission grants, and block-listed domains.</p><p>“Scary” prompts, like the ones in <a href=\"https://emilymstark.com/2020/07/14/debunking-the-users-always-click-yes-myth.html\">this example</a> we see from time to time, look like they are meant to discourage people from going to pages that seem potentially malicious. Because they’re so blatant, those warnings encourage developers to move to safer APIs and to renew their certificates.</p><p>I wish that for device-access capabilities we could come up with prompts that encourage engagement and ensure that the engagement is safe, rather than discourage it and transfer the liability to the user, with no remediation available for the web developer. More on that later.</p><p>I do agree with the argument that Mozilla &amp; Apple should at least try to innovate in that space rather than “decline to implement”. But maybe they are? I think <a href=\"https://github.com/privacycg/is-logged-in\">isLoggedIn</a> from Apple, for example, is an interesting and relevant proposal in the 3rd dimension that future device APIs could build upon — for example, device APIs that are fingerprinting-prone can be made available when the current website already knows the identity of the user.</p><h3 id=\"webusb\">WebUSB</h3><p>In the next section I will dive into WebUSB, check what it allows, and how it’s handled in the 3rd dimension — what is the trust and distribution model? Is it sufficient? What are the alternatives?</p><h4 id=\"the-premise\">The Premise</h4><p>The <a href=\"https://wicg.github.io/webusb/\">WebUSB API</a> allows full access to the USB protocol for device-classes that are not <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/LZXocaeCwDw\">block-listed</a>.</p><p>It can achieve powerful things like connecting to an <a href=\"https://github.com/webusb/arduino\">Arduino</a> board or <a href=\"https://webadb.github.io/\">debugging an Android phone</a>.</p><p>It’s exciting to see <a href=\"https://www.youtube.com/watch?v=IpfZ8Nj3uiE\">Suz Hinton’s videos</a> on how this API can help achieve things that were very expensive to achieve before.</p><p>I truly wish platforms found ways to be more open and allow quick iterations on educational hardware/software projects, as an example.</p><h4 id=\"funny-feeling\">Funny Feeling</h4><p>But still, I get a funny feeling when I look at what WebUSB enables, and the <a href=\"https://srlabs.de/badusb/\">existing security issues</a> with USB in general.</p><p>USB feels too powerful as a protocol exposed to the web, even with permission prompts.</p><p>So I’ve researched further.</p><h4 id=\"mozilla-s-official-view\">Mozilla’s Official View</h4><p>I started by reading what <a href=\"https://dbaron.org/\">David Baron</a> had to say about why Mozilla ended up rejecting WebUSB, in Mozilla’s <a href=\"https://github.com/mozilla/standards-positions/issues/100\">official standards position</a>:</p><blockquote>“Because many USB devices are not designed to handle potentially-malicious interactions over the USB protocols and because those devices can have significant effects on the computer they’re connected to, we believe that the security risks of exposing USB devices to the Web are too broad to risk exposing users to them or to explain properly to end users to obtain meaningful informed consent.”</blockquote><h4 id=\"the-current-permission-prompt\">The Current Permission Prompt</h4><p>This is what Chrome’s WebUSB permission prompt looks like at the time of publishing this post:</p><figure><a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png\"><img loading=\"lazy\" decoding=\"async\" importance=\"low\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png 400w, https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png 800w, https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png 1200w, https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png 1600w, https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png\" sizes=\"100vw\" alt=\"Permission Prompt\"></a><figcaption>Permission Prompt. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/75452ff6-887e-4bc2-baa2-8674f58100cc/1-web-expose-hardware-capabilities.png\">Large preview</a>)</figcaption></figure><p>Particular domain Foo wants to connect to particular device Bar. To do what? and how can I know for sure?</p><p>When granting access to the printer, camera, microphone, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API\">GPS</a>, or even to a few of the more contained <a href=\"https://web.dev/bluetooth/\">WebBluetooth</a> GATT profiles like <a href=\"https://www.bluetooth.com/specifications/gatt/\">heart rate monitoring</a>, this question is relatively clear, and focuses on the <em>content</em> or <em>action</em> rather than on the <em>device</em>. There is a clear understanding of what information I want from the peripheral or what action I want to perform with it, and the user-agent mediates and makes sure that this particular action is handled.</p><h4 id=\"usb-is-generic\">USB Is Generic</h4><p>Unlike the devices mentioned above that are exposed via special APIs, USB is not content-specific. As mentioned in <a href=\"https://wicg.github.io/webusb/#introduction\">the intro of the spec</a>, WebUSB goes further and is intentionally designed for unknown or not-yet-invented types of devices, not for well-known device classes like keyboards or external drives.</p><p>So, unlike the cases of the printer, GPS and camera, I cannot think of a prompt that would inform the user of what granting a page permission to connect to a device with WebUSB would allow in the content realm, without a deep understanding of the particular device and auditing the code that’s accessing it.</p><h4 id=\"the-yubikey-incident-and-mitigation\">The Yubikey Incident And Mitigation</h4><p>A good example from not too long ago is the <a href=\"https://www.wired.com/story/chrome-yubikey-phishing-webusb/\">Yubikey incident</a>, where Chrome’s WebUSB was used to phish data from a USB-powered authentication device.</p><p>Since this is a security issue that is said to be resolved, I was curious to dive into Chrome’s <a href=\"https://www.yubico.com/support/security-advisories/ysa-2018-02/\">mitigation efforts</a> in Chrome 67, which include blocking <a href=\"https://github.com/chromium/chromium/blob/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/chrome/browser/usb/usb_blocklist.cc#L59\">a specific set of devices</a> and <a href=\"https://github.com/chromium/chromium/blob/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/modules/webusb/usb_device.cc#L520\">a specific set of classes</a>.</p><h4 id=\"class-device-block-list\">Class/Device Block-List</h4><p>So Chrome’s actual defense against WebUSB exploits that happened in the wild, in addition to the currently very general permission prompt, was to block specific devices and device classes.</p><p>This may be a straightforward solution for a new technology or experiment, but will become harder and harder to accomplish when (and if) WebUSB becomes more popular.</p><p>I’m afraid that the people innovating on educational devices via WebUSB might reach a difficult situation. By the time they’re done prototyping, they could be facing a set of ever-changing non-standard block lists, that only update together with browser versions, based on security issues that have nothing to do with them.</p><p>I think that standardizing this API without addressing this will end up being counterproductive to the developers relying on it. For example, someone could spend cycles developing a WebUSB application for motion detectors, only to find out later that motion detectors become a blocked class, either due to security reasons or because the OS decides to handle them, causing their entire WebUSB effort to go to waste.</p><h4 id=\"marker\">Security vs. Features</h4><p>The platform adjacency theory, in some ways, considers capabilities and security to be a zero-sum game, and that being too conservative on security &amp; privacy concerns would cause platforms to lose their relevance.</p><p>Let’s take Arduino as an example. Arduino communication is possible with WebUSB and is a <a href=\"https://webusb.github.io/arduino/demos/\">major use case</a>. Someone developing an Arduino device will now have to consider a new threat scenario, where a site tries to access their device using WebUSB (with some user permission). As per <a href=\"https://wicg.github.io/webusb/#attacking-the-host\">the spec</a>, this device manufacturer now has to “design their devices to only accept signed firmware”. This can add burden to firmware developers, and increase development costs, while the whole purpose of the spec is to do the opposite.</p><h4 id=\"what-makes-webusb-different-from-other-peripherals\">What Makes WebUSB Different From Other Peripherals</h4><p>In browsers, there is a clear distinction between user interactions and synthetic interactions (interactions instantiated by the web page).</p><p>For example, a web page can’t decide on its own to click a link on or wake up the CPU/display. But external devices can — for example, a mouse device can click a link on behalf of the user and almost any USB device can wake up the CPU, depending on the OS.</p><p>So even with the current WebUSB specification, devices can choose to implement several interfaces, e.g. debug for <a href=\"https://developer.android.com/studio/command-line/adb\">adb</a> and <a href=\"https://www.usb.org/hid\">HID</a> for pointer input, and using malicious code that takes advantage of ADB, become a keylogger and browse websites on behalf of the user, given the right exploitable firmware flashing mechanism.</p><p>Adding that device to a blocklist would be too late for devices with firmware that was compromised using ADB or other allowed forms of flashing, and would make device manufacturers even more reliant than before on browser versions for security fixes associated with their devices.</p><h4 id=\"informed-consent-content\">Informed Consent &amp; Content</h4><p>The problem with informed consent and USB, as mentioned before, is that USB (specifically in the extra-generic WebUSB use-cases) is not content-specific. Users know what a printer is, what a camera is, but “USB” for most users is merely a cable (or a socket) — a means to an end — very few users know that USB is a protocol and what enabling it between websites and devices means.</p><p>One suggestion was to have a “scary” prompt, something along the lines of “Allow this web page to take over the device” (which is an improvement over the seemingly harmless “wants to connect”).</p><p>But as scary as prompts get, they cannot explain the breadth of possible things that can be done with raw access to a USB peripheral that the browser doesn’t know intimately, and if they did, no user in their right mind would click “Yes”, unless it’s a device that they fully trust to be bug-free and a website they truly trust to be up-to-date and not malicious.</p><p>A possible prompt like that would read “Allow this web page to potentially take over your computer”. I don’t think that a scary prompt like this one would be beneficial for the WebUSB community, and constant changes to these dialogs will leave the community confused.</p><h4 id=\"marker\">Prototyping vs. Product</h4><p>I can see a possible exception to this. If the premise of WebUSB and the other project Fugu APIs was to support prototyping rather than product-grade devices, all-encompassing generic prompts could make sense.</p><p>In order to make that viable, though, I think the following must happen:</p><ol><li>Use language in the specs that set expectations about this being for prototyping;</li><li>Have these APIs available only after some opt-in gesture, like having the user enable them manually in the browser settings;</li><li>Have “scary” permission prompts, like the ones for invalid SSL certificates.</li></ol><p>Not having the above makes me think that these APIs are for real products rather than for prototypes, and as such, the feedback holds.</p><h3 id=\"an-alternative-proposal\">An Alternative Proposal</h3><p>One of the parts in the original blog post that I agree with is that it’s not enough to say “no” — major players in the web world who decline certain APIs for being harmful should also play offense and propose ways in which these capabilities that matter to users and developers can be safely exposed. I don’t represent any major player, but I’m going to give it a humble go.</p><p>I believe that the answer to this lies in the 3rd dimension of trust and relationship, and that it’s outside the box of permission prompts and block-lists.</p><h4 id=\"straightforward-and-verified-prompt\">Straightforward And Verified Prompt</h4><p>The main case I’m going to make is that the prompt should be about the content or action, and not about the peripheral, and that informed consent can be granted for a specific straightforward action with a specific set of verified parameters, not for a general action like “taking over” or “connecting to” a device.</p><h4 id=\"the-3d-printer-example\">The 3D Printer Example</h4><p>In the <a href=\"https://wicg.github.io/webusb/#app-drivers\">WebUSB spec</a>, 3D printers are brought as an example, so I’m going to use it here.</p><p>When developing a WebUSB application for a 3D printer, I want the browser/OS prompt to ask me something along the lines of <strong>Allow AutoDesk 3ds-mask to print a model to your CreatBot 3D printer?</strong>, be shown a browser/OS dialog with some print parameters, like refinement, thickness and output dimensions, and with a preview of what’s going to be printed. All of these parameters should be verified by a trusted user agent, not by a drive-by web page.</p><p>Currently, the browser doesn’t know the printer, and it can verify only some of the claims in the prompt:</p><ul><li>The requesting domain has a certificate registered to AutoDesk, so there is some certainty that this is AutoDesk Inc;</li><li>The requested peripheral calls itself “CreatBot 3d printer”;</li><li>This device, device class and domain are not found in the browser’s block-lists;</li><li>The user responded “Yes” or “No” to a general question they were asked.</li></ul><p>But in order to show a truthful prompt and dialog with the above details, the browser would also have to verify the following:</p><ul><li>When permission is granted, the action performed will be printing a 3D model, and nothing but that;</li><li>The selected parameters (refinement/thickness/dimensions etc.) are going to be respected;</li><li>A verified preview of what is going to be printed was shown to the user;</li><li>In certain sensitive cases, an additional verification that this is in fact AutoDesk, maybe with something like a revokable short-lived token.</li></ul><p>Without verifying the above, a website that was granted permission to “connect to” or “take over” a 3D printer can start printing huge 3D models due to a bug (or malicious code in one of its dependencies).</p><p>Also, an imagined full-blown web 3D printing capability would do a lot more than what WebUSB can provide — for example, spooling and queuing different print requests. How would that be handled if the browser window is closed? I haven’t researched all the possible WebUSB peripheral use-cases, but I’m guessing that when looking at them from a content/action perspective, most will need more than USB access.</p><p>Because of the above, using WebUSB for 3D printing will probably be hacky and short-lived, and developers relying on it will have to provide a “real” driver for their printer at some point. For example, if OS vendors decide to add built-in support for 3D printers, all sites using that printer with WebUSB would stop working.</p><h4 id=\"proposal-driver-auditing-authority\">Proposal: Driver Auditing Authority</h4><p>So, overarching permissions like “take over the peripheral” are problematic, we don’t have enough information in order to show a full-fledged parameter dialog and verify that its results are going to be respected, and we don’t want to send the user on an unsafe trip to download a random executable from the web.</p><p>But what if there was an <em>audited</em> piece of code, a driver, that used the WebUSB API internally and did the following:</p><ul><li>Implemented the “print” command;</li><li>Displayed an out-of-page print dialog;</li><li>Connected to a particular set of USB devices;</li><li>Performed some of its actions when the page is in the background (e.g. in a service worker), or even when the browser is closed.</li></ul><p>An auditing of a driver like this can make sure that what it does amounts to “printing”, that it respects the parameters, and that it shows the print preview.</p><p>I see this as being similar to <a href=\"https://en.wikipedia.org/wiki/Certificate_authority\">certificate authorities</a>, an important piece in the web ecosystem that is somewhat disconnected from the browser vendors.</p><h4 id=\"driver-syndication\">Driver Syndication</h4><p>The drivers don’t have to be audited by Google/Apple, though the browser/OS vendor can choose to audit drivers on its own. It can work like SSL certificate authorities — the issuer is a highly trusted organization; for example, the manufacturer of the particular peripheral or an organization that certifies many drivers, or a platform like Arduino. (I imagine organizations popping up similar to <a href=\"https://letsencrypt.org/\">Let’s Encrypt</a>.)</p><p>It might be enough to say to users: “Arduino trusts that this code is going to flash your Uno with <em>this</em> firmware” (with a preview of the firmware).</p><h4 id=\"caveats\">Caveats</h4><p>This is of course not free of potential problems:</p><ul><li>The driver itself can be buggy or malicious. But at least it’s audited;</li><li>It’s less “webby” and generates an additional development burden;</li><li>It doesn’t exist today, and cannot be solved by internal innovation in browser engines.</li></ul><h4 id=\"other-alternatives\">Other Alternatives</h4><p>Other alternatives could be to somehow standardize and improve the cross-browser <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions\">Web Extensions</a> API, and make the existing browser add-on stores like <a href=\"https://chrome.google.com/webstore/category/extensions\">Chrome Web Store</a> into somewhat of a driver auditing authority, mediating between user requests and peripheral access.</p><h3 id=\"summary-of-opinion\">Summary Of Opinion</h3><p>The author, Google and partners’ bold efforts to keep the open web relevant by enhancing its capabilities are inspirational.</p><p>When I get down to the details, I see Apple and Mozilla’s more conservative view of the web, and their defensive approach to new device capabilities, as carrying technical merit. Core issues with informed consent around open-ended hardware capabilities are far from being solved.</p><p>Apple could be more forthcoming in the discussion to find new ways to enable device capabilities, but I believe this comes from a different perspective about computing, a standpoint that was part of Apple’s identity for decades, not from an anti-competitive standpoint.</p><p>In order to support things like the somewhat open-ended hardware capabilities in project Fugu, and specifically WebUSB, the <em>trust model</em> of the web needs to evolve beyond permission prompts and domain/device block-lists, drawing inspiration from trust ecosystems like certificate authorities and package distributions.</p><h4><span>Further Reading</span> on SmashingMag:</h4><ul><li><a title=\"Read 'How Improving Website Performance Can Help Save The Planet'\" href=\"https://www.smashingmagazine.com/2019/01/save-planet-improving-website-performance/\" rel=\"bookmark\">How Improving Website Performance Can Help Save The Planet</a></li><li><a title=\"Read 'Towards An Ad-Free Web: Diversifying The Online Economy'\" href=\"https://www.smashingmagazine.com/2021/01/towards-ad-free-web-diversifying-online-economy/\" rel=\"bookmark\">Towards An Ad-Free Web: Diversifying The Online Economy</a></li><li><a title=\"Read 'Is There A Future Beyond Writing Great Code?'\" href=\"https://www.smashingmagazine.com/2019/11/future-beyond-writing-great-code/\" rel=\"bookmark\">Is There A Future Beyond Writing Great Code?</a></li><li><a title=\"Read 'Using Ethics In Web Design'\" href=\"https://www.smashingmagazine.com/2018/03/using-ethics-in-web-design/\" rel=\"bookmark\">Using Ethics In Web Design</a></li></ul><p><img src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"> <span>(ra, yk, il)</span></p></div></div>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e58ba37dc3f858c0d77c1a368b61e8bb4be540459f10fe69a874fda6b1c5b19e","category":"Tech"}