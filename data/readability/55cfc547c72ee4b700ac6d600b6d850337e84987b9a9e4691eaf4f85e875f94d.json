{"title":"[LoRa] ตั้งค่า LoRa Server Project เพื่อทำ Private LoRaWAN ครับ (ภาคต่อ)","link":"https://thanapon.info/lora-private-lorawan/","date":1563129570000,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"post-389\"><p><img width=\"800\" height=\"375\" src=\"https://thanapon.info/wp-content/uploads/2020/11/New-Project10.png\" alt=\"[LoRa] ตั้งค่า LoRa Server Project เพื่อทำ Private LoRaWAN ครับ (ภาคต่อ)\" loading=\"lazy\" srcset=\"https://thanapon.info/wp-content/uploads/2020/11/New-Project10.png 800w, https://thanapon.info/wp-content/uploads/2020/11/New-Project10-300x141.png 300w, https://thanapon.info/wp-content/uploads/2020/11/New-Project10-768x360.png 768w, https://thanapon.info/wp-content/uploads/2020/11/New-Project10-600x281.png 600w\" sizes=\"(max-width: 800px) 100vw, 800px\"></p><div><p>อ้างอิงจากบทความ <a href=\"https://thanapon.info/?p=375\" data-type=\"post\" data-id=\"375\">[LoRa] สร้าง Private LoRaWAN ด้วย LoRa Server Project บน Raspberry Pi 3</a> ผมได้ค้างเรื่องการตั้งค่า LoRa Server Project ไว้ ซึ่งบทความนี้จะแนะนำการตั้งค่า LoRa Server Project เพื่อสร้าง Private LoRaWAN กันครับ</p><h2 id=\"2ca9\">Requirement:</h2><ul><li>Raspberry Pi 3 + Single Channel Packet Forwarding + LoRa Server Project</li><li>Arduino Promini + RFM95w</li><li>USB to Serial</li></ul><h2 id=\"7633\">เริ่มกันเลยละกันครับจะได้ไม่เสียเวลาาา!!!!!</h2><ul><li>Login เข้าไปยัง LoRa App Server ซึ่ง URL ที่ใช้จะเป็น IP Address ของ Raspberry Pi แล้วตามด้วย Port: 8080 เช่น <em>http://192.168.2.10:8080</em> โดยใช้ Username/Password: <strong>admin/admin</strong></li></ul><div><figure><img src=\"https://miro.medium.com/max/1912/1*-hB7tVbxQvSP_AbQCmJ9LQ.png\" alt=\"Image for post\"></figure></div><div><figure><img src=\"https://miro.medium.com/max/1920/1*Hdin3n6eD9hIWSDDkJGQ8Q.png\" alt=\"Image for post\"></figure></div><ul><li>หลังจาก Login เสร็จเรียบร้อยเราจะเข้าไปยังหน้าจัดการ LoRaServer ซึ่งจากตัวอย่างผมได้ทำการสร้าง Application สำหรับทำการทดสอบแล้วนะก็ไม่ต้องสนใจครับ เข้ามายังเรื่องของเราต่อหลังจากนั้นให้ทำเลือก <strong>Network-server</strong> เพื่อทำการ Server สำหรับ LoRaWAN นะครับ แล้วทำการกด <strong>ADD</strong></li></ul><div><figure><img src=\"https://miro.medium.com/max/328/1*OHZViinwG-__-Gr1aGTU9w.png\" alt=\"Image for post\"></figure></div><div><figure><img src=\"https://miro.medium.com/max/1526/1*w17cB1DnVolGmJHIjrsxzQ.png\" alt=\"Image for post\"></figure></div><ul><li>จากนั้นเราจะเข้ามายังหน้าเพิ่ม Network-Server ซึ่ง parameter ที่เราจะต้องกำหนดจะมีอยู่ 2 อย่างคือ<br>– Network-server name คือชื่อ Network-server ที่เราจะใช้เรียกเป็นชื่ออะไรก็ได้ครับ<br>– Network-server server คือ Network-server API ที่เราได้จากการติดตั้ง LoRa Server นั้นเองครับ โดยค่า default คือ <strong>localhost:8000</strong></li><li>หลังจากนั้น <strong>Add Network-Server</strong> ได้เลยครับ</li></ul><div><figure><img src=\"https://miro.medium.com/max/1913/1*VRvsYE1ZEhADVRUWfomCUQ.png\" alt=\"Image for post\"></figure></div><ul><li>ทำการเพิ่ม <strong>Service-profiles </strong>โดยจะมี parameter ที่เราจะต้องกำหนดคือ<br>– <strong>Service-profile name</strong><br>– <strong>Network-Server</strong> (มาจากการเพิ่ม Network-server จากขั้นตอนก่อนหน้านี้)<br>หลังจากนั้นก็ทำการ create service-profile ได้เลยครับ</li></ul><div><figure><img src=\"https://miro.medium.com/max/327/1*Dsx4j_m3CuDrVkQg7rd-AA.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1530/1*GDMOwvCsLBmHJVHgfq3DnA.png\" alt=\"Image for post\"></figure><div><figure><img src=\"https://miro.medium.com/max/1877/1*thbLsTksZLISXO1xVd0XSg.png\" alt=\"Image for post\"></figure></div><ul><li>ขั้นตอนต่อไปทำการสร้าง Device-profiles ซึ่งเราจะต้องกำหนด parameter คือ<br>– Device-profile name<br>– Network-server<br>– LoRaWAN MAC version<br>– LoRaWAN Regional Parameters revision<br><strong>*** เนื่องจากโปรเจคนี้ผมได้ Library Arduino-LMIC ดังนั้นผมต้องกำหนด LoRaWAN MAC version: 1.0.2, LoRaWAN Regional Parameters revision: A ส่วนการ Authentication นั้นผมใช้แบบ ABP ใน tab JOIN(OTAA/ABP) ก็ไม่ต้องเลือก Device support OTTA ครับเสร็จแล้วก็ Create Device-profile ได้เลยครับ</strong></li></ul><div><figure><img src=\"https://miro.medium.com/max/324/1*jNX3lrwsQsgysnbnbC_5kg.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1522/1*Bzf4cnM64R68sNshjz-gNQ.png\" alt=\"Image for post\"></figure><div><figure><img src=\"https://miro.medium.com/max/1879/1*vPxdVL0P_H_qi3cjJpCUvA.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1055/1*DWgWY2Cgf98Oh7yAxWE0Ug.png\" alt=\"Image for post\"></figure><ul><li>จากนั้นก็มาสร้าง Gateway กันครับโดยให้เรากำหนด Gateway-name, Gateway-description, Gateway ID และ Network-Server เรียบร้อยแล้วกด Create Gateway ได้เลยครับ<br><strong>***Gateway ID ได้มาจาก Device ID ที่เราทำการสร้าง Single Channel Gateway นะครับ</strong></li></ul><div><figure><img src=\"https://miro.medium.com/max/330/1*aCI7AxZ4DfIOsYy-f_DUqA.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1518/1*SRNw1Wvq5tENH5dcAHemEQ.png\" alt=\"Image for post\"></figure><div><figure><img src=\"https://miro.medium.com/max/1875/1*7y6_QyNQQR8oBCa_NdEQiw.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1532/1*DmIoeziKKU63INExDzHDRA.png\" alt=\"Image for post\"></figure><ul><li>จากนั้นทำการสร้าง Application สำหรับทดสอบการทำงาน LoRaServer กัน</li></ul><div><figure><img src=\"https://miro.medium.com/max/329/1*6Q_aynGQqMk-nNUa_Nq2Ug.png\" alt=\"Image for post\"></figure></div><figure><img src=\"https://miro.medium.com/max/1523/1*UsYP8x3BlRZ6zrFVnuGg2g.png\" alt=\"Image for post\"></figure><figure><img src=\"https://miro.medium.com/max/1890/1*3jBTLo3YXUQPP4g4cVitDg.png\" alt=\"Image for post\"></figure><ul><li>ขั้นตอนต่อไปเมื่อเราได้ Application มาแล้วให้เข้าไปสร้าง device ที่จะเชื่อมต่อเข้ากับ LoRa Network ของเราโดยกดเข้าไปที่ชื่อของ Application ได้เลยครับ</li></ul><figure><img src=\"https://miro.medium.com/max/1535/1*xy5iKymnRSbNro3AmUq5VQ.png\" alt=\"Image for post\"></figure><ul><li>เราก็จะอยู่ในหน้า Application-PrivateLoRaWAN จากนั้นเลือก Create เพื่อสร้าง Device ของเรา</li></ul><figure><img src=\"https://miro.medium.com/max/1534/1*4KNUR9wrDymGnLSedScH2A.png\" alt=\"Image for post\"></figure><ul><li>กำหนด Device name, Device Description,Device EUI และ Device-profile<br>***Device EUI สามารถให้ระบบ generate ได้ครับส่วน Disable frame-counter validation สามารถติ๊กเลือกได้ครับ เพราะมันคือการ ignore frame-counter ทำให้สามารถส่งข้อมูลได้รัวๆ ถึงแม้ตัว End-Device เราจะ reset แล้วเริ่มนับ frame-counter ใหม่ ซึ่งหลังจากที่ End-Device reset ตัว frame-counter ของระบบจะเท่ากับ 0 ด้วย</li></ul><figure><img src=\"https://miro.medium.com/max/1533/1*m5dhTukFwC4ud4lAnt99PA.png\" alt=\"Image for post\"></figure><figure><img src=\"https://miro.medium.com/max/1556/1*bSj_QKFhCuDy7cFhZ7nywQ.png\" alt=\"Image for post\"></figure><ul><li>เสร็จแล้วเลือก tab Activation เพื่อนำข้อมูล Device Address, Network Session key และ Application Session key ไปใช้ในการกำหนด Authentication แบบ ABP ในฝั่งของ End-Device<br>***หากใครไม่มีข้อมูลสามารถให้ระบบ generate data ออกมาได้เลยครับ เสร็จแล้วอย่าลืมกด <strong>(Re)Activate Device</strong> ด้วยนะครับ</li></ul><figure><img src=\"https://miro.medium.com/max/1535/1*6w-rJonPxk4PaxDjWBIfZA.png\" alt=\"Image for post\"></figure><h2 id=\"2076\">End-Device Section</h2><ul><li>คัดลอกโค๊ดด้านล่างนี้ไปแปะลงใน ArduinoIDE ได้เลย โดยให้เปลี่ยน <strong>DEVADDR, NWKSKEY</strong> และ <strong>APPSKEY</strong> ตามที่เราได้ตั้งไว้ในขั้นตอนก่อนหน้านี้นะครับ</li></ul><div><pre data-lang=\"C++\"><code data-hcb-clip=\"1\"><span>#<span>include</span> <span>&lt;lmic.h&gt;</span></span>\n<span>#<span>include</span> <span>&lt;hal/hal.h&gt;</span></span>\n<span>#<span>include</span> <span>&lt;SPI.h&gt;</span></span>\n\n<span>// LoRaWAN NwkSKey, network session key</span>\n<span>// This is the default Semtech key, which is used by the early prototype TTN</span>\n<span>// network.</span>\n<span>static</span> <span>const</span> u4_t DEVADDR <span>=</span> <span>0x018796ad</span><span>;</span>\n<span>//Set network session key</span>\n<span>static</span> <span>const</span> PROGMEM u1_t NWKSKEY<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0x5f</span><span>,</span> <span>0xe9</span><span>,</span> <span>0x61</span><span>,</span> <span>0x37</span><span>,</span> <span>0x4b</span><span>,</span> <span>0xe8</span><span>,</span> <span>0xaf</span><span>,</span> <span>0xb2</span><span>,</span> <span>0x1a</span><span>,</span> <span>0x7a</span><span>,</span> <span>0x44</span><span>,</span> <span>0xeb</span><span>,</span> <span>0x8d</span><span>,</span> <span>0xb5</span><span>,</span> <span>0xff</span><span>,</span> <span>0x07</span> <span>}</span><span>;</span>\n<span>//Set app session key</span>\n<span>static</span> <span>const</span> u1_t PROGMEM APPSKEY<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0x0a</span><span>,</span> <span>0x4c</span><span>,</span> <span>0x8d</span><span>,</span> <span>0xcc</span><span>,</span> <span>0x31</span><span>,</span> <span>0xf6</span><span>,</span> <span>0xe9</span><span>,</span> <span>0x89</span><span>,</span> <span>0xb0</span><span>,</span> <span>0x09</span><span>,</span> <span>0x97</span><span>,</span> <span>0xca</span><span>,</span> <span>0xfd</span><span>,</span> <span>0x2e</span><span>,</span> <span>0x05</span><span>,</span> <span>0x1b</span> <span>}</span><span>;</span>\n\n<span>// These callbacks are only used in over-the-air activation, so they are</span>\n<span>// left empty here (we cannot leave them out completely unless</span>\n<span>// DISABLE_JOIN is set in config.h, otherwise the linker will complain).</span>\n<span>void</span> os_getArtEui <span>(</span>u1_t<span>*</span> buf<span>)</span> <span>{</span> <span>}</span>\n<span>void</span> os_getDevEui <span>(</span>u1_t<span>*</span> buf<span>)</span> <span>{</span> <span>}</span>\n<span>void</span> os_getDevKey <span>(</span>u1_t<span>*</span> buf<span>)</span> <span>{</span> <span>}</span>\n\n<span>static</span> osjob_t sendjob<span>;</span>\n\n<span>// Schedule TX every this many seconds (might become longer due to duty</span>\n<span>// cycle limitations).</span>\n<span>const</span> <span>unsigned</span> TX_INTERVAL <span>=</span> <span>15</span><span>;</span>\n\n<span>// Pin mapping</span>\n<span>const</span> lmic_pinmap lmic_pins <span>=</span> <span>{</span>\n  <span>.</span>nss <span>=</span> <span>10</span><span>,</span>\n  <span>.</span>rxtx <span>=</span> LMIC_UNUSED_PIN<span>,</span>\n  <span>.</span>rst <span>=</span> <span>6</span><span>,</span>\n  <span>.</span>dio <span>=</span> <span>{</span><span>2</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>}</span><span>,</span>\n<span>}</span><span>;</span>\n\n<span>int</span> channel <span>=</span> <span>0</span><span>;</span>\n\n<span>void</span> onEvent <span>(</span>ev_t ev<span>)</span> <span>{</span>\n  Serial<span>.</span><span>print</span><span>(</span><span>os_getTime</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  Serial<span>.</span><span>print</span><span>(</span><span>\": \"</span><span>)</span><span>;</span>\n  <span>switch</span> <span>(</span>ev<span>)</span> <span>{</span>\n    <span>case</span> EV_SCAN_TIMEOUT<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_SCAN_TIMEOUT\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_BEACON_FOUND<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_BEACON_FOUND\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_BEACON_MISSED<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_BEACON_MISSED\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_BEACON_TRACKED<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_BEACON_TRACKED\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_JOINING<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_JOINING\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_JOINED<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_JOINED\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_RFU1<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_RFU1\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_JOIN_FAILED<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_JOIN_FAILED\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_REJOIN_FAILED<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_REJOIN_FAILED\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_TXCOMPLETE<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_TXCOMPLETE (includes waiting for RX windows)\"</span><span>)</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>LMIC<span>.</span>txrxFlags <span>&amp;</span> TXRX_ACK<span>)</span>\n        Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"Received ack\"</span><span>)</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>LMIC<span>.</span>dataLen<span>)</span> <span>{</span>\n        Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"Received \"</span><span>)</span><span>)</span><span>;</span>\n        Serial<span>.</span><span>println</span><span>(</span>LMIC<span>.</span>dataLen<span>)</span><span>;</span>\n        Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\" bytes of payload\"</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span>// Schedule next transmission</span>\n      <span>os_setTimedCallback</span><span>(</span><span>&amp;</span>sendjob<span>,</span> <span>os_getTime</span><span>(</span><span>)</span> <span>+</span> <span>sec2osticks</span><span>(</span>TX_INTERVAL<span>)</span><span>,</span> do_send<span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_LOST_TSYNC<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_LOST_TSYNC\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_RESET<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_RESET\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_RXCOMPLETE<span>:</span>\n      <span>// data received in ping slot</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_RXCOMPLETE\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_LINK_DEAD<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_LINK_DEAD\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>case</span> EV_LINK_ALIVE<span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"EV_LINK_ALIVE\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n    <span>default</span><span>:</span>\n      Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"Unknown event\"</span><span>)</span><span>)</span><span>;</span>\n      <span>break</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>void</span> <span>do_send</span><span>(</span>osjob_t<span>*</span> j<span>)</span> <span>{</span>\n  <span>int</span> temp <span>=</span> <span>random</span><span>(</span><span>20</span><span>,</span> <span>30</span><span>)</span><span>;</span> <span>//random Temperature Value</span>\n  <span>int</span> hum <span>=</span> <span>random</span><span>(</span><span>50</span><span>,</span> <span>70</span><span>)</span><span>;</span>  <span>//random humidity Value</span>\n  <span>unsigned</span> <span>char</span> buff<span>[</span><span>15</span><span>]</span><span>;</span>\n  <span>dtostrf</span><span>(</span>temp<span>,</span> <span>5</span><span>,</span> <span>1</span><span>,</span> buff<span>)</span><span>;</span>\n  <span>strcat</span><span>(</span>buff<span>,</span> <span>\" \"</span><span>)</span><span>;</span>\n  <span>dtostrf</span><span>(</span>hum<span>,</span> <span>5</span><span>,</span> <span>1</span><span>,</span> buff <span>+</span> <span>strlen</span><span>(</span>buff<span>)</span><span>)</span><span>;</span>\n\n  <span>// Check if there is not a current TX/RX job running</span>\n  <span>if</span> <span>(</span>LMIC<span>.</span>opmode <span>&amp;</span> OP_TXRXPEND<span>)</span> <span>{</span>\n    Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"OP_TXRXPEND, not sending\"</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span> <span>else</span> <span>{</span>\n    <span>// Prepare upstream data transmission at the next possible time.</span>\n    <span>//    LMIC_setTxData2(1, mydata, sizeof(mydata) - 1, 0);</span>\n    <span>LMIC_setTxData2</span><span>(</span><span>1</span><span>,</span> buff<span>,</span> <span>strlen</span><span>(</span>buff<span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"Packet queued\"</span><span>)</span><span>)</span><span>;</span>\n    <span>digitalWrite</span><span>(</span><span>9</span><span>,</span> HIGH<span>)</span><span>;</span>\n    <span>delay</span><span>(</span><span>200</span><span>)</span><span>;</span>\n    <span>digitalWrite</span><span>(</span><span>9</span><span>,</span> LOW<span>)</span><span>;</span>\n  <span>}</span>\n  <span>// Next TX is scheduled after TX_COMPLETE event.</span>\n<span>}</span>\n\n<span>void</span> <span>setup</span><span>(</span><span>)</span> <span>{</span>\n  Serial<span>.</span><span>begin</span><span>(</span><span>115200</span><span>)</span><span>;</span>\n  Serial<span>.</span><span>println</span><span>(</span><span>F</span><span>(</span><span>\"Starting\"</span><span>)</span><span>)</span><span>;</span>\n  <span>pinMode</span><span>(</span><span>9</span><span>,</span> OUTPUT<span>)</span><span>;</span>\n\n<span>#<span>ifdef</span> VCC_ENABLE</span>\n  <span>// For Pinoccio Scout boards</span>\n  <span>pinMode</span><span>(</span>VCC_ENABLE<span>,</span> OUTPUT<span>)</span><span>;</span>\n  <span>digitalWrite</span><span>(</span>VCC_ENABLE<span>,</span> HIGH<span>)</span><span>;</span>\n  <span>delay</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n<span>#<span>endif</span></span>\n\n  <span>// LMIC init</span>\n  <span>os_init</span><span>(</span><span>)</span><span>;</span>\n  <span>// Reset the MAC state. Session and pending data transfers will be discarded.</span>\n  <span>LMIC_reset</span><span>(</span><span>)</span><span>;</span>\n\n  <span>// Set static session parameters. Instead of dynamically establishing a session</span>\n  <span>// by joining the network, precomputed session parameters are be provided.</span>\n<span>#<span>ifdef</span> PROGMEM</span>\n  <span>// On AVR, these values are stored in flash and only copied to RAM</span>\n  <span>// once. Copy them to a temporary buffer here, LMIC_setSession will</span>\n  <span>// copy them into a buffer of its own again.</span>\n  <span>uint8_t</span> appskey<span>[</span><span>sizeof</span><span>(</span>APPSKEY<span>)</span><span>]</span><span>;</span>\n  <span>uint8_t</span> nwkskey<span>[</span><span>sizeof</span><span>(</span>NWKSKEY<span>)</span><span>]</span><span>;</span>\n  <span>memcpy_P</span><span>(</span>appskey<span>,</span> APPSKEY<span>,</span> <span>sizeof</span><span>(</span>APPSKEY<span>)</span><span>)</span><span>;</span>\n  <span>memcpy_P</span><span>(</span>nwkskey<span>,</span> NWKSKEY<span>,</span> <span>sizeof</span><span>(</span>NWKSKEY<span>)</span><span>)</span><span>;</span>\n  LMIC_setSession <span>(</span><span>0x1</span><span>,</span> DEVADDR<span>,</span> nwkskey<span>,</span> appskey<span>)</span><span>;</span>\n<span>#<span>else</span></span>\n  <span>// If not running an AVR with PROGMEM, just use the arrays directly</span>\n  LMIC_setSession <span>(</span><span>0x1</span><span>,</span> DEVADDR<span>,</span> NWKSKEY<span>,</span> APPSKEY<span>)</span><span>;</span>\n<span>#<span>endif</span></span>\n\n  <span>LMIC_setupChannel</span><span>(</span><span>0</span><span>,</span> <span>923200000</span><span>,</span> <span>DR_RANGE_MAP</span><span>(</span>DR_SF12<span>,</span> DR_SF7<span>)</span><span>,</span>  BAND_CENTI<span>)</span><span>;</span>  <span>// g-band</span>\n  <span>forceTxSingleChannelDr</span><span>(</span><span>)</span><span>;</span>\n  <span>// Disable link check validation</span>\n  <span>LMIC_setLinkCheckMode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n  <span>// TTN uses SF9 for its RX2 window.</span>\n  LMIC<span>.</span>dn2Dr <span>=</span> DR_SF9<span>;</span>\n\n  <span>// Set data rate and transmit power for uplink (note: txpow seems to be ignored by the library)</span>\n  <span>LMIC_setDrTxpow</span><span>(</span>DR_SF7<span>,</span> <span>14</span><span>)</span><span>;</span>\n\n  <span>// Start job</span>\n  <span>do_send</span><span>(</span><span>&amp;</span>sendjob<span>)</span><span>;</span>\n<span>}</span>\n\n<span>void</span> <span>loop</span><span>(</span><span>)</span> <span>{</span>\n  <span>os_runloop_once</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// Disables all channels, except for the one defined above, and sets the</span>\n<span>// data rate (SF). This only affects uplinks; for downlinks the default</span>\n<span>// channels or the configuration from the OTAA Join Accept are used.</span>\n<span>//</span>\n<span>// Not LoRaWAN compliant; FOR TESTING ONLY!</span>\n<span>//</span>\n<span>void</span> <span>forceTxSingleChannelDr</span><span>(</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>// For EU; for US use i&lt;71</span>\n    <span>if</span> <span>(</span>i <span>!=</span> channel<span>)</span> <span>{</span>\n      <span>LMIC_disableChannel</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  <span>// Set data rate (SF) and transmit power for uplink</span>\n  <span>//  LMIC_setDrTxpow(dr, 14);</span>\n<span>}</span></code></pre></div><ul><li>หลังจากนั้นก็ทำการ Upload Sketch ไปยัง Arduino Board แล้วก็รอดูผลลัพธ์ได้เลยครับ โดยในฝั่งของ Arduino Board เราจะไม่รับ ACK กลับมาซึ่งจากโค๊ดข้างต้นผมได้กดหนดให้ส่ง interval ทุกๆ 15 วินาทีครับ <strong><em>ย้ำเพื่อทดสอบนะครับถ้าจะใช้งานจริง เราต้องคำนวณ duty cycle ของ LoRa ใหม่นะครับ</em></strong></li></ul><blockquote><p>เท่านี้เราก็มี Private LoRa Server ไว้ใช้กันแล้วครับ สำหรับวันนี้ขอบคุณและสวัสดีครับ <img draggable=\"false\" role=\"img\" alt=\"🙂\" src=\"https://s.w.org/images/core/emoji/13.0.0/svg/1f642.svg\"></p></blockquote></div></div></div>","author":"thanapon.tap","siteTitle":"Thanapon","siteHash":"6a039c2f54d76e4c49227d80968f2a30de5427cc57525c047c383ea3563cde5f","entryHash":"55cfc547c72ee4b700ac6d600b6d850337e84987b9a9e4691eaf4f85e875f94d","category":"Thai"}