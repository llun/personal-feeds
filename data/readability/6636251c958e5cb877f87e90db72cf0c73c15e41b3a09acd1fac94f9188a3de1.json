{"title":"Dynamic Static Typing In TypeScript","link":"https://smashingmagazine.com/2021/01/dynamic-static-typing-typescript/","date":1611932400000,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"article__content\"><div><div><figure role=\"presentation\"><a href=\"https://www.smashingmagazine.com/author/stefan-baumgartner\"><div><picture><source type=\"image/avif\" srcset=\"data:image/avif;base64,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\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1204d090-5175-473e-be7a-59a49fd46dc5/stefan-baumgartner-400px-mpu3xn.jpg\" loading=\"eager\" width=\"100\" height=\"100\" alt=\"Stefan Baumgartner\"></picture></div></a></figure></div><div id=\"author__desc\"><p>Stefan Baumgartner is a software architect based in Austria. He has published online since the late 1990s, writing for Manning, Smashing Magazine, and A List … <a href=\"https://www.smashingmagazine.com/author/stefan-baumgartner\">More about Stefan ↬</a></p></div></div><p><section aria-label=\"quick summary\">In this article, we look at some of the more advanced features of TypeScript, like union types, conditional types, template literal types, and generics. We want to formalize the most dynamic JavaScript behavior in a way that we can catch most bugs before they happen. We apply several learnings from all chapters of <a href=\"https://www.smashingmagazine.com/printed-books/typescript-in-50-lessons/\">TypeScript in 50 Lessons</a>, a book we’ve published here on Smashing Magazine late 2020. If you are interested in learning more, be sure to check it out!</section></p><p>JavaScript is an inherently dynamic programming language. We as developers can express a lot with little effort, and the language and its runtime figure out what we intended to do. This is what makes JavaScript so popular for beginners, and which makes experienced developers productive! There is a caveat, though: We need to be alert! Mistakes, typos, correct program behavior: A lot of that happens in our heads!</p><p>Take a look at the following example.</p><p>We have an <a href=\"https://www.smashingmagazine.com/2021/01/dynamic-static-typing-typescript/Express\">https://expressjs.com/</a>-style server that allows us to define a route (or path), and executes a callback if the URL is requested.</p><p>The callback takes two arguments:</p><ol><li><strong>The <code>request</code> object.</strong> Here we get information on the <a href=\"https://developer.mozilla.org/de/docs/Web/HTTP/Methods\">HTTP method used</a> (e.g GET, POST, PUT, DELETE), and additional parameters that come in. In this example <code>userID</code> should be mapped to a parameter <code>userID</code> that, well, contains the user’s ID!</li><li><strong>The <code>response</code> or <code>reply</code> object.</strong> Here we want to prepare a proper response from the server to the client. We want to send correct status codes (method <code>status</code>) and send JSON output over the wire.</li></ol><p>What we see in this example is heavily simplified, but gives a good idea what we are up to. The example above is also riddled with errors! Have a look:</p><p>Oh wow! Three lines of implementation code, and three errors? What has happened?</p><ol><li>The first error is nuanced. While we tell our app that we want to listen to <em>GET</em> requests (hence <code>app.get</code>), we only do something if the request method is <em>POST</em>. At this particular point in our application, <code>req.method</code> can’t be <em>POST</em>. So we would never send any response, which might lead to unexpected timeouts.</li><li>Great that we explicitly send a status code! <code>20</code> isn’t a valid status code, though. Clients might not understand what’s happening here.</li><li>This is the response we want to send back. We access the parsed arguments but have a mean typo. It’s <code>userID</code> not <code>userId</code>. All our users would be greeted with “Welcome, user undefined!”. Something you definitely have seen in the wild!</li></ol><p>And things like that happen! Especially in JavaScript. We gain expressiveness – not once did we have to bother about types – but have to pay close attention to what we’re doing.</p><p>This is also where JavaScript gets a lot of backlash from programmers who aren’t used to dynamic programming languages. They usually have compilers pointing them to possible problems and catching errors upfront. They might come off as snooty when they frown upon the amount of extra work you have to do in your head to make sure everything works right. They might even tell you that JavaScript has no types. Which is not true.</p><p>Anders Hejlsberg, the lead architect of TypeScript, said in his <a href=\"https://channel9.msdn.com/Events/Build/2017/B8088\">MS Build 2017 keynote</a> that “<em>it’s not that JavaScript has no type system. There is just no way of formalizing it</em>”.</p><p>And this is TypeScript’s main purpose. TypeScript wants to understand your JavaScript code better than you do. And where TypeScript can’t figure out what you mean, you can assist by providing extra type information.</p><h3 id=\"basic-typing\">Basic Typing</h3><p>And this is what we’re going to do right now. Let’s take the <code>get</code> method from our Express-style server and add enough type information so we can exclude as many categories of errors as possible.</p><p>We start with some basic type information. We have an <code>app</code> object that points to a <code>get</code> function. The <code>get</code> function takes <code>path</code>, which is a string, and a callback.</p><p>While <code>string</code> is a basic, so-called <em>primitive</em> type, <code>CallbackFn</code> is a <em>compound</em> type that we have to explicitly define.</p><p><code>CallbackFn</code> is a function type that takes two arguments:</p><ul><li><code>req</code>, which is of type <code>ServerRequest</code></li><li><code>reply</code> which is of type <code>ServerReply</code></li></ul><p><code>CallbackFn</code> returns <code>void</code>.</p><p><code>ServerRequest</code> is a pretty complex object in most frameworks. We do a simplified version for demonstration purposes. We pass in a <code>method</code> string, for <code>\"GET\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"DELETE\"</code>, etc. It also has a <code>params</code> record. Records are objects that associate a set of keys with a set of properties. For now, we want to allow for every <code>string</code> key to be mapped to a <code>string</code> property. We refactor this one later.</p><p>For <code>ServerReply</code>, we lay out some functions, knowing that a real <code>ServerReply</code> object has much more. A <code>send</code> function takes an optional argument with the data we want to send. And we have the possibility to set a status code with the <code>status</code> function.</p><p>That’s already something, and we can rule out a couple of errors:</p><p>But we still can send wrong status codes (any number is possible) and have no clue about the possible HTTP methods (any string is possible). Let’s refine our types.</p><h3 id=\"smaller-sets\">Smaller Sets</h3><p>You can see primitive types as a set of all possible values of that certain category. For example, <code>string</code> includes all possible strings that can be expressed in JavaScript, <code>number</code> includes all possible numbers with double float precision. <code>boolean</code> includes all possible boolean values, which are <code>true</code> and <code>false</code>.</p><p>TypeScript allows you to refine those sets to smaller subsets. For example, we can create a type <code>Method</code> that includes all possible strings we can receive for HTTP methods:</p><p><code>Method</code> is a smaller set of the bigger <code>string</code> set. <code>Method</code> is a union type of literal types. A literal type is the smallest unit of a given set. A literal string. A literal number. There is no ambiguity. It’s just <code>\"GET\"</code>. You put them in a union with other literal types, creating a subset of whatever bigger types you have. You can also do a subset with literal types of both <code>string</code> and <code>number</code>, or different compound object types. There are lots of possibilities to combine and put literal types into unions.</p><p>This has an immediate effect on our server callback. Suddenly, we can differentiate between those four methods (or more if necessary), and can exhaust all possibilites in code. TypeScript will guide us:</p><p>With every <code>case</code> statement you make, TypeScript can give you information on the available options. <a href=\"https://www.typescriptlang.org/play?#code/C4TwDgpgBAshwAsD2ATAzlAvFARAcQFEAVHKAH1wAUB5AZRPKoFUGKcARAgGWIJwG4AUINCQotYAENgAVzQBhVNGwBGAAxrG6lVrUAmRno2G1OikYPm1AZhMAWEwFYTANhMB2EwA5DetxWtjANNGQMsoQNtgh2DnYP8oQShkiLVPYJ8KOyCobLNc-UZsqIKYgriChOz0gsyCgE4i9Sb8uxVwtpK2sraKtqqVGra6uyNGJJTRjr0uvR69Pr8ivRG9RqzrVrseu3Xcx00sx1b6vYPDqAP8g-CDkoOyg4qDhIOag7qJ5IOz5opj671OqOU5CQQAYyQADs0MAoJIwGAsFAAN4TADm8AANIIAL5g0TQWgQABOADdSQAlCBgAA2IGRaOSaAgUJQAC4oAAKJAAIwAVgB+TmSKEgACUWAAfFAyUgAJYoITMqSyNCcrmw6RyRQoCCciTahRKSWYGXE8lUmn0oT44QicDQeSSWm03mScEAawAYlDkVySRAAI4G0kUknUoMyCCwrFQQN0kChy0R60S6WyhVK4SE8Rhq1RmNw7BMqAAW3gyA5sErqDQyqgYEkJMkZfVUGpkJJKAAPLCSfKoei4-3B+ipbawQAzGRQ8HAeXQqCY4BcpuITmjodx8Eut0ez2c52u91e32S0sAekvUGASCgvOg8rLdIgFahwAgKCgAFofzKoSQOFnzAJASSkD943ldEEDhQCAHc8WEBEwAAOhXLkcEvBF5UvORSTQS92XwkkAEl2BwOMZznBclwDYM40DNALwma94ThRB5QwUDB2AOMiEdWhwQHMA4U9BCMEQaR42DVCK0QVBWJvXc-SkT1oGhDSpygKckBkElGyQNA0HlXlaWgMkXWjNAJjQeD5WAcEEG5QMgzk2sUBYlIoF3FlcEIEh2S+FJeUDSRPQbZJfOgHAaHoHAgu85JQogcLIqgPUp0kGRaWARKkrY5BwygJBivkqtguSVz3IU7NklxPFxX4IA\">Try it out for yourself</a>. If you exhausted all options, TypeScript will tell you in your <code>default</code> branch that this can <code>never</code> happen. This is literally the type <code>never</code>, which means that you possibly have reached an error state that you need to handle.</p><p>That’s one category of errors less. We know now exactly which possible HTTP methods are available.</p><p>We can do the same for HTTP status codes, by defining a subset of valid numbers that <code>statusCode</code> can take:</p><p>Type <code>StatusCode</code> is again a union type. And with that, we exclude another category of errors. Suddenly, code like that fails:</p><div><p>And our software becomes a lot safer! But we can do more!</p></div><h3 id=\"enter-generics\">Enter Generics</h3><p>When we define a route with <code>app.get</code>, we implicitly know that the only HTTP method possible is <code>\"GET\"</code>. But with our type definitions, we still have to check for all possible parts of the union.</p><p>The type for <code>CallbackFn</code> is correct, as we could define callback functions for all possible HTTP methods, but if we explicitly call <code>app.get</code>, it would be nice to save some extra steps which are only necessary to comply with typings.</p><p>TypeScript generics can help! Generics are one of the major features in TypeScript that allow you to get the most dynamic behaviour out of static types. In <a href=\"https://www.smashingmagazine.com/printed-books/typescript-in-50-lessons/\">TypeScript in 50 Lessons</a>, we spend the last three chapters digging into all the intricacies of generics and their unique functionality.</p><p>What you need to know right now is that we want to define <code>ServerRequest</code> in a way that we can specify a part of <code>Methods</code> instead of the entire set. For that, we use the generic syntax where we can define parameters as we would do with functions:</p><p>This is what happens:</p><ol><li><code>ServerRequest</code> becomes a generic type, as indicated by the angle brackets</li><li>We define a generic parameter called <code>Met</code>, which is a subset of type <code>Methods</code></li><li>We use this generic parameter as a generic variable to define the method.</li></ol><p>I also encourage you to check out <a href=\"https://fettblog.eu/tidy-typescript-name-your-generics/\">my article on naming generic parameters</a>.</p><p>With that change, we can specify different <code>ServerRequest</code>s without duplicating things:</p><p>Since we changed the interface of <code>ServerRequest</code>, we have to make changes to all our other types that use <code>ServerRequest</code>, like <code>CallbackFn</code> and the <code>get</code> function:</p><p>With the <code>get</code> function, we pass an actual argument to our generic type. We know that this won’t be just a subset of <code>Methods</code>, we know exactly which subset we are dealing with.</p><p>Now, when we use <code>app.get</code>, we only have on possible value for <code>req.method</code>:</p><p>This ensures that we don’t assume that HTTP methods like <code>\"POST\"</code> or similar are available when we create an <code>app.get</code> callback. We know exactly what we are dealing with at this point, so let’s reflect that in our types.</p><p>We already did a lot to make sure that <code>request.method</code> is reasonably typed and represents the actual state of affairs. One nice benefit we get with subsetting the <code>Methods</code> union type is that we can create a general purpose callback function <em>outside</em> of <code>app.get</code> that is type-safe:</p><h3 id=\"typing-params\">Typing Params</h3><p>What we haven’t touched yet is typing the <code>params</code> object. So far, we get a record that allows accessing every <code>string</code> key. It’s our task now to make that a little bit more specific!</p><p>We do that by adding another generic variable. One for methods, one for the possible keys in our <code>Record</code>:</p><p>The generic type variable <code>Par</code> can be a subset of type <code>string</code>, and the default value is every string. With that, we can tell <code>ServerRequest</code> which keys we expect:</p><p>Let’s add the new argument to our <code>get</code> function and the <code>CallbackFn</code> type, so we can set the requested parameters:</p><p>If we don’t set <code>Par</code> explicitly, the type works as we are used to, since <code>Par</code> defaults to <code>string</code>. If we set it though, we suddenly have a proper definition for the <code>req.params</code> object!</p><p>That’s great! There is one little thing that can be improved, though. We still can pass <em>every</em> string to the <code>path</code> argument of <code>app.get</code>. Wouldn’t it be better if we could reflect <code>Par</code> in there as well?</p><p>We can! With the release of version 4.1, TypeScript is able to create <em>template literal types</em>. Syntactically, they work just like string template literals, but on a type level. Where we were able to split the set <code>string</code> into subsets with <em>string literal types</em> (like we did with Methods), template literal types allow us to include an entire spectrum of strings.</p><p>Let’s create a type called <code>IncludesRouteParams</code>, where we want to make sure that <code>Par</code> is properly included in the Express-style way of adding a colon in front of the parameter name:</p><p>The generic type <code>IncludesRouteParams</code> takes one argument, which is a subset of <code>string</code>. It creates a union type of two template literals:</p><ol><li>The first template literal starts with <em>any</em> <code>string</code>, then includes a <code>/</code> character followed by a <code>:</code> character, followed by the parameter name. This makes sure that we catch all cases where the parameter is at the end of the route string.</li><li>The second template literal starts with <em>any</em> <code>string</code>, followed by the same pattern of <code>/</code>, <code>:</code> and the parameter name. Then we have another <code>/</code> character, followed by <em>any</em> string. This branch of the union type makes sure we catch all cases where the parameter is somewhere within a route.</li></ol><p>This is how <code>IncludesRouteParams</code> with the parameter name <code>userID</code> behaves with different test cases:</p><p>Let’s include our new utility type in the <code>get</code> function declaration.</p><p>Great! We get another safety mechanism to ensure that we don’t miss out on adding the parameters to the actual route! How powerful.</p><h3 id=\"generic-bindings\">Generic bindings</h3><p>But guess what, I’m still not happy with it. There are a few issues with that approach that become apparent the moment your routes get a little more complex.</p><ol><li>The first issue I have is that we need to explicitly state our parameters in the generic type parameter. We have to bind <code>Par</code> to <code>\"userID\"</code>, even though we would specify it anyway in the path argument of the function. This is not JavaScript-y!</li><li>This approach only handles one route parameter. The moment we add a union, e.g <code>\"userID\" | \"orderId\"</code> the failsafe check is satisfied with only <em>one</em> of those arguments being available. That’s how sets work. It can be one, or the other.</li></ol><p>There must be a better way. And there is. Otherwise, this article would end on a very bitter note.</p><p>Let’s inverse the order! Let’s not try to define the route params in a generic type variable, but rather extract the variables from the <code>path</code> we pass as the first argument of <code>app.get</code>.</p><p>To get to the actual value, we have to see out how <em>generic binding</em> works in TypeScript. Let’s take this <code>identity</code> function for example:</p><p>It might be the most boring generic function you ever see, but it illustrates one point perfectly. <code>identity</code> takes one argument, and returns the same input again. The type is the generic type <code>T</code>, and it also returns the same type.</p><p>Now we can bind <code>T</code> to <code>string</code>, for example:</p><p>This explicitly generic binding makes sure that we only pass <code>strings</code> to <code>identity</code>, and since we explicitly bind, the return type is also <code>string</code>. If we forget to bind, something interesting happens:</p><p>In that case, TypeScript infers the type from the argument you pass in, and binds <code>T</code> to the <em>string literal type</em> <code>\"yes\"</code>. This is a great way of converting a function argument to a literal type, which we then use in our other generic types.</p><p>Let’s do that by adapting <code>app.get</code>.</p><p>We remove the <code>Par</code> generic type and add <code>Path</code>. <code>Path</code> can be a subset of any <code>string</code>. We set <code>path</code> to this generic type <code>Path</code>, which means the moment we pass a parameter to <code>get</code>, we catch its string literal type. We pass <code>Path</code> to a new generic type <code>ParseRouteParams</code> which we haven’t created yet.</p><p>Let’s work on <code>ParseRouteParams</code>. Here, we switch the order of events around again. Instead of passing the requested route params to the generic to make sure the path is alright, we pass the route path and extract the possible route params. For that, we need to create a conditional type.</p><h3 id=\"conditional-types-and-recursive-template-literal-types\">Conditional Types And Recursive Template Literal Types</h3><p>Conditional types are syntactically similar to the ternary operator in JavaScript. You check for a condition, and if the condition is met, you return branch A, otherwise, you return branch B. For example:</p><p>Here, we check if <code>Rte</code> is a subset of every path that ends with the parameter at the end Express-style (with a preceding <code>\"/:\"</code>). If so, we infer this string. Which means we capture its contents into a new variable. If the condition is met, we return the newly extracted string, otherwise, we return never, as in: “There are no route parameters”,</p><p>If we try it out, we get something like that:</p><p>Great, that’s already much better than we did earlier. Now, we want to catch all other possible parameters. For that, we have to add another condition:</p><p>Our conditional type works now as follows:</p><ol><li>In the first condition, we check if there is a route parameter somewhere in between the route. If so, we extract both the route parameter and everything else that comes after that. We return the newly found route parameter <code>P</code> in a union where we call the same generic type recursively with the <code>Rest</code>. For example, if we pass the route <code>\"/api/users/:userID/orders/:orderID\"</code> to <code>ParseRouteParams</code>, we infer <code>\"userID\"</code> into <code>P</code>, and <code>\"orders/:orderID\"</code> into <code>Rest</code>. We call the same type with <code>Rest</code></li><li>This is where the second condition comes in. Here we check if there is a type at the end. This is the case for <code>\"orders/:orderID\"</code>. We extract <code>\"orderID\"</code> and return this literal type.</li><li>If there is no more route parameter left, we return never.</li></ol><p><a href=\"https://effectivetypescript.com/2020/11/05/template-literal-types/\">Dan Vanderkam</a> shows a similar, and more elaborate type for <code>ParseRouteParams</code>, but the one you see above should work as well. If we try out our newly adapted <code>ParseRouteParams</code>, we get something like this:</p><p>Let’s apply this new type and see what our final usage of <code>app.get</code> looks like.</p><p>Wow. That just looks like the JavaScript code we had at the beginning!</p><h3 id=\"static-types-for-dynamic-behavior\">Static Types For Dynamic Behavior</h3><p>The types we just created for one function <code>app.get</code> make sure that we exclude a ton of possible errors:</p><ol><li>We can only pass proper numeric status codes to <code>res.status()</code></li><li><code>req.method</code> is one of four possible strings, and when we use <code>app.get</code>, we know it only be <code>\"GET\"</code></li><li>We can parse route params and make sure that we don’t have any typos inside our callback</li></ol><p>If we look at the example from the beginning of this article, we get the following error messages:</p><p>And all that before we actually run our code! Express-style servers are a perfect example of the dynamic nature of JavaScript. Depending on the method you call, the string you pass for the first argument, a lot of behavior changes inside the callback. Take another example and all your types look entirely different.</p><p>But with a few well-defined types, we can catch this dynamic behavior while editing our code. At compile time with static types, not at runtime when things go boom!</p><p>And this is the power of TypeScript. A static type system that tries to formalize all the dynamic JavaScript behavior we all know so well. If you want to try the example we just created, head over to the <a href=\"https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgBwTAvDA3gKBjA5gUygBpMBfAbk0ygE8F8YBlfAJwDdWAlfBAGxtQZsMCPjAATAFwwAFCABGAKwD80uGBoBKVAD4YbEAEtxlHNDhQArhGkzzViAGEQ4-NMZQL156+0o9zOxcPPyUFFQA9BEAxCz4uIbgTJ4OPvjUdAweXk4uDCjCAD4wAIwADGVFpWUlVeUATFX1FU01rY04xc0AzK0ALK0ArK0AbK0A7K0AHE31Y50w3S0LS7UrZR0wxUu96wPrw+vzW4tlk+szC33LJ9drtxtV17sP+w+HD8fF1+cPlw8ATie5WB92+JU24Je4Le4I+4K+MD6JV+4P+32aT3qkKR9WhuNhuPhuMRfXq6NxQKu3TBSL6hPpVNug0qV0GtL6AKZxRZrJOLNpLJxLPxLMJLOJLMRLNRMBZFJZ3LlIIW7MFAIVXMoUWiYnEcQS4CotHoMAAsoQABYuCCCABEAHEAKIAFTtJztAAUAPKMN0ez0AVX9xTtABEnQAZV1Ou2UTAAM0sYGAUESYDwhAAPJ6LJaYPgAB5QPW26AsQxgXCCcuV3A6GTCBB56S5qCWkg4YBwXi8eRwYAAa2kjh7fYHg4AYmAs47XXaiDBcyxRJwQJYS8u4ABbCA5vM6HSYbRYHBRGBQEAweQMQzbvj4bdiEviMjGzJLuAr-Brjf4Le7lmnAlnoaDAQwRYlhItoAAYACToLWVakBEkgIZWCasEuKHoWAmEsDA3DQKQMHCMoS4nMuq7rpuX47nuMERAhRFQCRR44NI4EFsWpYwPBiFQBWyGobh+HYaRODkZ6wjSGA+AcCw8Ymgwo69v2Q7TlmFqwJBvHada4gQIuy7cVBhkiIJdagbIwhxAAju4rAKdwdmWPg0BaYQxlfjonYwHEfA0I5QQsNwgXHro+hGCY76moEzn4K57lQJ5Ok8dB5pWja3kEbpGVIdWaAFdZp4wE+7YuNI2mmDAzYsPR0joDAADaADSMCVp+LAALrSAVMDhOEmCIAgAB0BBQDIdoRIghgRNYrAQKhC0sAAkmGqEgCwrhreIC4wEmKZpkkMj2YucQQCetmJaNdX0aNK3rTVF2jfY1gyM0ZSaK9eoyJoYT-ZgQA\">TypeScript playground</a> and fiddle around with it.</p><hr><p><em><a href=\"https://www.smashingmagazine.com/printed-books/typescript-in-50-lessons/\"><img loading=\"lazy\" decoding=\"async\" src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e9832cc8-7166-408e-9dc4-0070761aae5f/smashing-typescript-book-400x400.png\" width=\"200\" height=\"200\" alt=\"TypeScript in 50 Lessons by Stefan Baumgartner\"></a>In this article, we touched upon many concepts. If you’d like to know more, check out <a href=\"https://www.smashingmagazine.com/printed-books/typescript-in-50-lessons/\">TypeScript in 50 Lessons</a>, where you get a gentle introduction to the type system in small, easily digestible lessons. Ebook versions are available immediately, and the print book will make a great reference for your coding library.</em></p><p><img src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"> <span>(vf, il)</span></p></div></div>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"6636251c958e5cb877f87e90db72cf0c73c15e41b3a09acd1fac94f9188a3de1","category":"Tech"}