{"title":"Updates to the Storage Access API","link":"https://webkit.org/blog/11545/updates-to-the-storage-access-api/","date":1612976429000,"content":"<div id=\"readability-page-1\" class=\"page\"><article id=\"post-11545\"><div><p>The Storage Access API allows third-party web content to ask for permission to get access to its unpartitioned storage, typically in order to authenticate the user. In the case of Safari and WebKit, using the Storage Access API enables cookie access under <a href=\"https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp\">Intelligent Tracking Prevention</a>.</p><p>This blog post covers two changes to the Storage Access API in Safari and WebKit as well as a how-to guide on adoption based on questions we’ve been asked the last two years.</p><h2>Changes to API Functionality</h2><p>iOS and iPadOS 14.5, and macOS Big Sur 11.3 betas feature two sought after changes to the Storage Access API in Safari and WebKit – per-page storage access and support for nested iframes. Both of these changes were driven by the standards process in <a href=\"https://github.com/privacycg/storage-access\">W3C Privacy CG</a>.</p><h3>Per-Page Storage Access</h3><p>If a request for storage access is granted to <code>embedee.example</code>, access is now granted to all <code>embedee.example</code> resource loads under the current first party webpage. This includes sibling <code>embedee.example</code> iframes but also other, non-document resources.</p><h3>Nested Iframes Can Request Storage Access</h3><p>Imagine a webpage embedding a cross-site iframe from <code>embedeeOne.example</code> which in turn embeds a cross-site iframe from <code>embedeeTwo.example</code> which makes the latter a so called nested iframe. As of this release, nested iframes such as <code>embedeeTwo.example</code> are also allowed to request storage access. Note that we may require first parties to explicitly delegate this capability through <a href=\"https://w3c.github.io/webappsec-permissions-policy/\">Permissions Policy</a> at a later stage. Mozilla has expressed an interest in such control.</p><h2>How To Use the Storage Access API</h2><p>For the purposes of this guide we will use the domains <code>social.example</code> for the embedded content in need of cookie access and <code>news.example</code> as the first party website embedding <code>social.example</code>.</p><h3>First, Cross-Site Iframes Call the API</h3><p>The Storage Access API is called from inside cross-site, or third-party, iframes. You don’t have to call the API if your website is first party and first party websites cannot call the API on behalf of third-parties.</p><h3>How-To #1: Meet and Greet the User as First Party</h3><p>If you want to make use of the Storage Access API as a third-party, you first need to take these steps as a first party:</p><ol><li>Make sure you are using regular browsing mode, i.e. not Private Browsing. We will cover Private Browsing at the end of this guide.</li><li>Take the user to your domain as first party. This is your website showing itself and giving the user a chance to recognize your brand and domain name. Recognition is important since the prompt for storage access features your embedded iframe’s domain. In our example, this is taking the user to a webpage with <code>social.example</code> in the URL bar, either though a navigation or a popup.</li><li>Have the user interact (tap, click, or use the keyboard) with your website as first party. This tells the browser that the user has <em>actually</em> seen and used the site. <strong>Note</strong>: Navigating to and from your website in a redirect without user interaction does not count. Formally, WebKit’s requirement is user interaction as first party <em>the last 30 days</em> of browser use. Being granted storage access through the Storage Access API counts as such user interaction. In our example, this is having the user tap/click on the webpage with <code>social.example</code> in the URL bar.</li><li>Set cookies when you are first-party. This establishes the website as “visited” for the purposes of the underlying cookie policy. Third parties without cookies cannot set cookies in Safari and never have since Safari 1.0 in 2003. This means you cannot use the Storage Access API as third-party until you have set at least one cookie as first party. In our example, this is setting cookies for <code>social.example</code> with <code>social.example</code> in the URL bar.</li></ol><p>The above requirements are there to make sure the sometimes 50-100 embedded third-parties on a single webpage cannot all prompt the user for storage access, only the ones the user has visited and interacted with can.</p><h3>How-To #2: Use the Storage Access API as Third Party</h3><p>Once you have had the user interact with your website as first party and have set cookies as first party, you are ready to make use of the Storage Access API.</p><ol><li>Your cross-site iframe that is about to request storage access must be a direct child frame of the top frame. Nested iframes cannot request storage access at this point. (This will likely change as a result of the ongoing standardization of the Storage Access API.)</li><li>Make your cross-site iframe call <code>document.hasStorageAccess()</code> as soon as it’s rendered to check your status. <strong>Note</strong>: Don’t call this function upon a user gesture since it’s asynchronous and will consume the gesture. Once the user gesture is consumed, making a subsequent call to <code>document.requestStorageAccess()</code> will fail because it’s not called when processing a user gesture. In our example this is <code>social.example</code>‘s iframe.</li><li>If <code>document.hasStorageAccess()</code> returns false, your iframe doesn’t have storage access. Now set an event handler on elements that represent UI which requires storage access and make the event handler call <code>document.requestStorageAccess()</code> on a tap or click. This is the API that requires a user gesture. In our example this is <code>social.example</code>‘s iframe calling the API.</li><li>Render the page with your cross-site iframe. Tap or click on an element with an event handler in the iframe. In our example this is rendering a page from <code>news.example</code> with the<code>social.example</code>‘s iframe and clicking on an element in the <code>social.example</code> iframe’s document.</li><li>If the user has not yet opted in to storage access for <code>social.example</code> under <code>news.example</code> there will now be a prompt. Choose “Don’t Allow” in the prompt. <strong>Tip</strong>: Don’t choose “Allow” yet because it’ll be remembered and you’ll have to delete browser history to reset it. If you are not getting the prompt, you either have not gotten user interaction as first party and set cookies for <code>social.example</code> yet (see How-To #1) or you have already chosen “Allow” earlier which is remembered.</li><li>Test the behavior for the “Don’t Allow” case. You can do it repeatedly. Do it until you’re happy with how your code handles it. Note that when the user chooses “Don’t Allow” in the prompt, their user gesture is <em>consumed</em> and any further API calls in your iframe that require a user gesture will have to get the user to tap or click again. We’ve deliberately designed it this way to make sure that an explicit deny from the user doesn’t trigger further privileged API calls from the iframe. The user should at this point be able to continue with other things.</li><li>Now tap or click the iframe again and this time choose “Allow” in the prompt. This should open up cookie access on resolution of the promise.</li><li>Test the behavior for the “Allow” case. Note that when the user chooses “Allow” in the prompt, their user gesture is <em>preserved</em> and any further API calls in your iframe that require a user gesture can go right ahead. We’ve deliberately designed it this way so that when you get access to cookies and note that the user is not in the desired state, such as not logged in, you can open a popup or navigate them to your website without further user gestures. In our example this would be a popup or navigation to <code>social.example</code>.</li><li>Now reload the webpage. This will reset your per-page storage access. Tap or click the iframe to trigger the call to <code>document.requestStorageAccess()</code>. This should open up cookie access <em>without a prompt</em> since the user has already opted in and that choice is remembered.</li><li>Finally test the flow in Private Browsing Mode. In that mode, the user must interact with your website as first party (see How-To #1) <em>in the same tab</em> as where you later request storage access as third-party. This is because Private Browsing Mode uses a separate ephemeral session for each new tab the user opens, i.e. the state of those tabs are separate. The rest should work the same as in regular mode.</li></ol></div></article></div>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"2a50d52d8d15ceec59246346f88d5a51e2430d94ef038498eed3c1a7ef6de6be","category":"Tech"}