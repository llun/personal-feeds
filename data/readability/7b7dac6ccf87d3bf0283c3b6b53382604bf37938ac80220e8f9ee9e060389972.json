{"title":"สรุปจากงาน QCon Plus 2020 เรื่อง The Journey from Monolith to Microservices at GitHub","link":"https://www.somkiat.cc/the-journey-from-monolith-to-microservices-at-github/","date":1620875606000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/05/how-to-disassemble-a-monolithic-app-in-notso-microservices-11-638.jpeg\" alt=\"\" width=\"571\" height=\"428\" srcset=\"https://www.somkiat.cc/wp-content/uploads/2021/05/how-to-disassemble-a-monolithic-app-in-notso-microservices-11-638.jpeg 638w, https://www.somkiat.cc/wp-content/uploads/2021/05/how-to-disassemble-a-monolithic-app-in-notso-microservices-11-638-300x225.jpeg 300w\" sizes=\"(max-width: 571px) 100vw, 571px\"></figure><p>จากงาน <a href=\"https://plus.qconferences.com/plus2020/presentation/monolith-microservices\" target=\"_blank\" rel=\"noreferrer noopener\">QCon Plus 2020 :: The Journey from Monolith to Microservices at GitHub</a></p><p>ระบบของ GitHub นั้นมีอายุมากกว่า 12 ปี<br>โดยพัฒนาในรูปแบบของ Monolith architecture เป็นหลัก<br>พัฒนาด้วย RoR หรือ Ruby on Rails<br>ทำการ deploy หลายครั้งต่อวัน<br>ระบบต้อง scale เพื่อรองรับจำนวน request มากกว่า 1,000 ล้านครั้งต่อวัน<br>โดยระบบสามารถทำงานได้ตามที่ต้องการเป็นอย่างดี</p><p><strong>แต่ในช่วงหลัง ๆ มานั้นทีมของ GitHub โตขึ้นแบบก้าวกระโดด</strong></p><p>นั่นคือภายใน 18 เดือนหรือปีครึ่ง จำนวนคนมากกว่า 2,000 คน<br>ซึ่งมีจำนวนมากกว่าเดิม 2 เท่าตัว<br>โดยจำนวนพนักงานที่เพิ่มมา มีสองส่วนคือ</p><ul><li>การรับคนแบบปกติ (Organic)</li><li>จากบริษัทที่ซื้อเข้ามา ทั้ง NPM, Dependabot, Pull panda และ Semmle เป็นต้น</li></ul><p><em><strong>อีกอย่าง พนักงานกว่า 70% ทำงานแยกกันไปตามแต่ละที่<br>ต่าง timezone กันไป (Distributed team)</strong></em></p><p><strong>จากที่กล่าวมาข้างต้น</strong></p><div><p>ทำให้เทคโนโลยีที่ใช้ภายในของ GitHub มีความหลากหลายมาก ๆ<br>จะให้ทุกคนมาเรียนรู้ภาษา Ruby และ RoR ก็ไม่น่าเหมาะสม<br>ทั้งในแง่ของ productivity, efficient และ scale</p><p>รวมทั้ง code ของ GitHub ก็ใหญ่ขึ้นมาก<br>จะทำอะไรสักอย่างประชุมวางแผนก็เยอะ<br>คนที่เกี่ยวข้องก็เยอะ การตัดสินใจในแต่ละเรื่อง ก็ลำบากซับซ้อนขึ้นเรื่อย ๆ<br>ผลกระทบมากมายทั้ง logic และ data ที่ใช้งานร่วมกัน<br>ดังนั้นการแก้ไขแต่ละครั้งต้องระมัดระวังอย่างมาก<br><strong><em>นี่คือปัญหาหรือไม่นะ ?</em></strong></p></div><p><strong>จึงเป็นที่มาของ Monolith vs Microservices ?</strong></p><p>ซึ่งทั้งคู่มีข้อดีและข้อเสียต่างกันไป<br>จะ migrate ไปทั้งหมดเลย ?<br>ถ้าจะทำ ต้องทำอย่างไรบ้าง ?<br>ซึ่งต้องรู้และเข้าใจก่อน</p><p><strong>ก่อนที่ GitHub จะทำการเปลี่ยนแปลงระบบนั้น</strong></p><div><p>ต้องใช้เวลาในการคิด วิเคราะห์ ไตร่ตรองว่า<br><strong><em>ทำไมต้องเปลี่ยนแปลง<br>เป้าหมายของการเปลี่ยนแปลงคืออะไร</em></strong></p><p>ในการเปลี่ยนแปลงนั้น เรื่อง culture สำคัญมาก ๆ<br>แน่นอนว่า มันไม่ง่าย มีงานต่าง ๆ ให้ทำมากมาย</p></div><p><strong><em>โดยจะทำอะไรนั้น ต้องให้ความสนใจ ใส่ใจ<br>ในเรื่องของปัญหา และ pain point เป็นหลัก</em></strong></p><p><strong>เป้าหมายหลักที่ GitHub ต้องการคือ การ enable ไม่ใช่การ replace</strong></p><p>ซึ่งต้องยอมรับก่อนว่าในอนาคตจะมีทั้ง monolith และ microservices ทำงานร่วมกัน<br>ดังนั้นเรื่อง environment จะต้องมีทั้งสองแบบ<br>การปรับปรุง code ใน monolith ก็ยังไม่ความสำคัญ<br>ไม่แพ้กับการสร้าง microservices ขึ้นมา</p><p><strong>Good Architecture start with Modularity</strong></p><p>ในขั้นตอนแรกของการแยกการทำงานของ monolith ออกมา<br>คือการแยกส่วนการทำงานต่าง ๆ ทั้ง business logic, data ออกมา<br>ในรูปแบบของ module (Logical)<br>ก่อนที่จะแยกกันจริง ๆ ในแง่ physical ในรูปแบบ microservices ต่อไป</p><p><strong>ดังนั้นสิ่งที่สำคัญมาก ๆ คือ</strong><br>ต้องทำให้ code มันจัดการได้ง่าย<br>ก่อนที่จะไปคิดเรื่องอื่น ๆ<br>ถ้าพื้นฐานมันแย่แล้ว ต่อไปมันจะแย่ลงเรื่อย ๆ</p><p><strong>จากนั้นเรื่อง data หรือข้อมูลที่ต้องใช้งาน</strong></p><p>ต้องกำหนดให้ชัดเจนเรื่องการเข้าถึงข้อมูลต่าง ๆ<br>เนื่องจากในแต่ละ service ต้องมีหน้าที่ในการดูแลและจัดการข้อมูลของตัวเอง<br>ไม่ไปยุ่งเกี่ยวกับข้อมูลของ service อื่น ๆ โดยปราศจากเหตุผลที่เหมาะสม</p><p>ซึ่งช่วยทำให้แต่ละ service มีการกำหนด API หรือ contract<br>ระหว่างกันได้ชันเจนมากขึ้น</p><p><strong>สิ่งหนึ่งที่เห็นบ่อยมาก ๆ และไม่ถูกต้องคือ</strong></p><p>มักแยกเพียง logic ออกมาเป็น service เท่านั้น<br>แต่ data ยัง share กัน !!<br>เหมือนใน monolith เลย !!<br>นำไปสู่ปัญหาที่เรียกกันว่า <strong>Distributed Monolith</strong></p><p>ผลที่ตามมาคือ แย่ทั้ง monolith และ microservices นั่นเอง<br>ทำให้เราได้ microservices ที่มีความซับซ้อน<br>แต่ไม่ได้ประโยชน์อะไรจากมันเลย</p><p><strong>การแยก data ที่ GitHub ทำอย่างไร ?</strong></p><p>มีขั้นตอนดังนี้</p><p><strong>ขั้นตอนที่ 1</strong></p><p>ทำการระบุ boundary ของ function การทำงานต่าง ๆ<br>พร้อมระบุว่ามี table อะไรบ้างที่ใช้งาน<br>จะเห็นว่ามี table อะไรที่ใช้ร่วมกัน และ แยกกันไปในแต่ละ function การทำงาน<br>และยังมีการพัฒนาเครื่องช่วย monitor ด้วยว่า<br>มี query อะไร ที่ทำการดึงข้อมูลจาก table จากกลุ่มการทำงานอื่น ๆ บ้าง<br>เพื่อทำให้เห็นว่าต้องแก้ไขตรงไหนบ้าง</p><p><strong>ขั้นตอนที่ 2</strong></p><p>แยก schema ออกมาในแต่ละกลุ่มการทำงานให้ชัดเจน<br>พร้อมกับใส่ partition key เข้ามาด้วยเพื่อให้ง่ายต่อการ scale<br>เมื่อแยก schema ไว้แล้ว<br>ทำให้ง่ายต่อการแยกในระดับ database server ต่อไป</p><p><strong>เนื่องจากระบบงานมีขนาดใหญ่ จะเริ่มตรงไหนดี ?</strong></p><p>สิ่งที่ GitHub เริ่มคือ</p><ul><li><strong>Core service</strong> หรือ service หลักของระบบ เช่น Authentication and Authorization</li><li><strong>Share resource</strong> หรือ อะไรก็ตามที่ใช้งานร่วมกันเสมอ เช่น เครื่องมือในการพัฒนาให้ง่ายขึ้น เช่น feature flag เป็นต้น</li></ul><p>การติดต่อสื่อสารระหว่าง service จะใช้งาน gRPC<br>อีกอย่างเมื่อแยกการทำงานอะไรออกไปแล้ว<br>code ในระบบเดิมต้องเอาออกไปด้วยเสมอ<br>รวมทั้งยังสร้างเครื่องมือ<br>สำหรับการดูว่า traffic วิ่งไปยังที่ใหม่ทั้งหมดหรือไม่อีกด้วย<br>เป็นการสร้างเครื่องมือ เพื่อตอบโจทย์ความต้องการ</p><p><strong>เรื่องของ Operation ก็เปลี่ยนไปเช่นกัน ขาดไม่ได้เลย</strong></p><p>ทั้งเรื่องเดิม ๆ คือ Monitoring, CI/CD และ containerization<br>ต้องเปลี่ยนไปเพื่อให้รองรับ microservices ด้วย<br>เพราะว่ามีจำนวน service เยอะขึ้น<br>ความหลากหลายของ technology มากขึ้น<br>ต้องมีการ customize pipeline ให้เหมาะสมกับ monolith และ microservices</p><p>ระบบ Monitoring ก็ต้องเพิ่มอีก<br>ทั้งเรื่องของ metric, contract interface ของ API ระหว่าง service</p><p><strong><em>สิ่งที่ทาง GitHub ทำขึ้นมาคือ template ของ pipeline<br>เพื่อให้สามารถ reuse ได้ง่าย<br>แต่เกิดมาจากการทำงานจริง ๆ ถึงจะมี template ได้</em></strong></p><p><strong>ยกตัวอย่างเช่น</strong></p><p><strong><em>Self-service runtime platform </em></strong>สำหรับการ deliver microservices<br>ช่วยลด overhead ของการทำงานในฝั่ง operation<br>ซึ่งประกอบไปด้วย</p><ul><li>Kubernetes manefest template</li><li>Ingress สำหรับ load balancing</li><li>การเก็บ log</li><li>การ integrate กับส่วนการทำงานอื่น ๆ</li></ul><p>ทำให้ทีมง่ายต่อการทดลองสร้าง microservices ขึ้นมาซึ่งเป็นสิ่งที่ดีมาก ๆ</p><p>ปิดท้ายด้วยประโยคนี้</p><p><em><strong>Start Small and Think about product/business value</strong></em></p><p>น่าจะพอมีประโยชน์สำหรับใครก็ตามที่กำลังจะทำ<br>เป็นอีกหนึ่งแนวทางที่น่าสนใจครับ<br>ก่อนจะทำอะไรก็ตาม ให้เริ่มด้วยคำว่า <strong>why</strong> ไม่ใช่ how</p></div></div>","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"7b7dac6ccf87d3bf0283c3b6b53382604bf37938ac80220e8f9ee9e060389972","category":"Thai"}