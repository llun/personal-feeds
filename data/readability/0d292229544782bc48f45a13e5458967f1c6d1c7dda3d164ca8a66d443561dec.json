{"title":"Linus Torvalds weighs in on Rust language in the Linux kernel","link":"https://arstechnica.com/?p=1752194","date":1616707562000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><h4>safer frameworks —</h4><h2 itemprop=\"description\">\"Memory managed languages? In my kernel?\"—It's more likely than you think</h2></div><div itemprop=\"articleBody\"><figure><img src=\"https://cdn.arstechnica.net/wp-content/uploads/2021/03/GettyImages-919606342-800x795.jpg\" alt=\"Rust coats a pipe in an industrial construction site.\"><figcaption><p><a href=\"https://cdn.arstechnica.net/wp-content/uploads/2021/03/GettyImages-919606342.jpg\" data-height=\"1017\" data-width=\"1024\">Enlarge</a> <span>/</span> No, not <em>that</em> kind of Rust.</p></figcaption></figure><p>This week, ZDNet's Steven J. Vaughan-Nichols asked Linus Torvalds and Greg Kroah-Hartman about the possibility of new Linux kernel code being written in <a href=\"https://www.rust-lang.org/\">Rust</a>—a high performance but memory-safe language&nbsp;<a href=\"https://research.mozilla.org/rust/\">sponsored</a> by the Mozilla project.</p><h2>C versus Rust</h2><p>As of now, the Linux kernel is written in the <a href=\"https://en.wikipedia.org/wiki/C_(programming_language)\">C</a> programming language—essentially, the same language used to write kernels for Unix and Unix-like operating systems since the <a href=\"https://en.wikipedia.org/wiki/Unix#History\">1970s</a>. The great thing about C is that it's not <a href=\"https://en.wikipedia.org/wiki/Low-level_programming_language\">assembly language</a>—it's considerably easier to read and write, and it's generally much closer to directly portable between hardware architectures. However, C still opens you up to nearly the entire range of catastrophic errors possible in assembly.</p><p>In particular, as a nonmemory-managed language, C opens the programmer up to memory leaks and buffer overflows. When you're done with a variable you've created, you must explicitly destroy it—otherwise, old orphaned variables accumulate until the system crashes. Similarly, you must allocate memory to store data in—and if your attempt to put too much data into too-small an area of RAM, you'll end up overwriting locations you shouldn't.</p><p><a href=\"https://en.wikipedia.org/wiki/High-level_programming_language\">High-level languages</a>—such as PHP, Python, or Java—aim to be both easier to read and write and safer to write code in. A large part of the additional safety they offer comes from implicit memory management—the language itself will refuse to allow you to stuff 16K of data into a 2K buffer, thereby avoiding buffer overflows. Similarly, high-level languages automatically reclaim \"orphaned\" RAM via <a href=\"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\">garbage collection</a>—if a function creates a variable which can only be read by that function, then the function terminates, the language will reclaim the variable once it's no longer accessible.</p><p>Rust, like Google's <a href=\"https://en.wikipedia.org/wiki/Go_(programming_language)\">Go</a>, is one of a new generation of languages which aims to hit somewhere in between—it provides the raw speed, flexibility, and most of the direct mapping to hardware functionality that C would, while offering a memory-safe environment.</p><h2>Linux Plumbers 2020</h2><p>At the Linux Plumbers conference in 2020, kernel developers began seriously <a href=\"https://www.phoronix.com/scan.php?page=news_item&amp;px=Torvalds-Rust-Kernel-K-Build\">discussing</a> the idea of Rust language inside the kernel. To be clear, the idea isn't an entire, ground-up rewrite of the kernel in Rust—merely the addition of new code, written in Rust, which interfaces cleanly with existing kernel infrastructure.</p><p>Torvalds didn't seem horrified at the idea—in fact, he requested that Rust compiler availability be <a href=\"https://lkml.org/lkml/2020/7/10/1261\">enabled</a> by default in the kernel-build environment. This didn't mean that Rust-code submissions would be accepted into the kernel willy-nilly. Enabling automatic checks for Rust-compiler presence simply meant that it should be as easy as possible to get any potential submissions built (and automatically tested) properly like any other kernel code would.</p><h2>Fast forward to 2021</h2><p>A significant amount of work has been done on Rust in the kernel since the 2020 Linux Plumber's Conference, including a Rust-language port of GNU <a href=\"https://www.gnu.org/software/coreutils/\">Coreutils</a>. The port's author, Sylvestre Ledru—a Mozilla director and Debian developer—describes it as in working condition, though not yet production ready. Eventually, the Rust port might replace the original GNU Coreutils in some environments—offering built-in thread safety and immunity to memory management errors such as buffer overflows.</p><p>Torvalds says he's in the \"wait and see\" camp about all this:</p><blockquote><p>I'm interested in the project, but I think it's driven by people who are very excited about Rust, and I want to see how it actually then ends up working in practice.</p></blockquote><p>Torvalds goes on to describe device drivers as obvious low-hanging fruit for potential new work to be done in Rust. He says that because there are tons of them, and they're relatively small and independent of other code.</p><p>Kernel maintainer Greg Kroah-Hartman agrees:</p><blockquote><p>... drivers are probably the first place for an attempt like this as they are the \"end leafs\" of the tree of dependencies in the kernel source. They depend on core kernel functionality, but nothing depends on them.</p></blockquote><p>Kroah-Hartman goes on to describe the difficulties which must be overcome for successful production integration of Rust code into a primarily C-language kernel:</p><blockquote><p>It will all come down to how well the interaction between the kernel core structures and lifetime rules that are written in C can be mapped into Rust structures and lifetime rules... That's going to take a lot of careful work by the developers wanting to hook this all up, and I wish them the best of luck.</p></blockquote><h2>An important first step</h2><p>Although we don't expect to see a full implementation of the Linux kernel in Rust anytime soon, this early work on integrating Rust code into the kernel's C infrastructure is likely to be very important.</p><p>Both <a href=\"https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/\">Microsoft</a> and the Linux community <a href=\"https://blog.kernelcare.com/vulnerability/a-guide-to-memory-vulnerabilities-in-the-linux-kernel\">agree</a> that two-thirds or more of security vulnerabilities stem from memory-safety issues. As software complexity continues to <a href=\"https://www.linux.com/news/linux-in-2020-27-8-million-lines-of-code-in-the-kernel-1-3-million-in-systemd/\">increase</a>, making it safer to write in the first place will become more and more important.</p></div></div>","author":"Jim Salter","siteTitle":"Ars Technica","siteHash":"5b0ddf6e8923e49262a7894cfd77962733e43fbcc565a103b48373820b310636","entryHash":"0d292229544782bc48f45a13e5458967f1c6d1c7dda3d164ca8a66d443561dec","category":"Tech"}