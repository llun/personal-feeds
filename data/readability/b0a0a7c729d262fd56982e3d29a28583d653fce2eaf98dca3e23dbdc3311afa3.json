{"title":"Things you don’t know about Protocol Buffers","link":"https://blog.whs.in.th/node/3484","date":1597338138000,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"content\"><main id=\"main\" role=\"main\"><article id=\"post-3484\"><div><p>ช่วงนี้นั่งงม Protocol Buffers ลึกๆ แล้วพบว่า documentation มันไม่ค่อยมีเขียนเท่าไร หลายๆ คนก็คงน่าจะเคยใช้อย่างมากก็ gRPC เลยอยากมาเล่าให้ฟังหน่อยว่า Protobuf ทำอะไรได้อีกบ้าง</p><p>บทความนี้จะพูดถึงเฉพาะ Protobuf 3 เท่านั้น ส่วน 2 ผมไม่ได้ใช้นานแล้ว</p><div><h2>REST API</h2><p>ลองทำ API แล้วคืนเป็น Protobuf ดู พบว่าทำงานง่ายขึ้นมาก</p><ul><li>Protobuf มี schema ชัดเจน และ validate มาแล้ว ไม่ต้องนั่งเขียน JSON Schema บน Swagger อีกรอบ (ตรงไม่ตรงก็ไม่รู้อีกต่างหาก)</li><li>ไม่เสียเวลาเขียน struct หรือ type definition มา parse บน client side ใช้ codegen ออกมาจาก proto definition ได้เลย</li><li>ยังใช้ Django + Django REST Framework Serializer ได้อยู่</li></ul><p>แต่ข้อเสียคือ</p><ul><li>HTTP Library ส่วนมาก parse JSON จาก response ได้เลย พอเป็น Protobuf แล้วต้องเขียน logic ในการ parse เอง</li><li>บน JavaScript frontend ถ้าใช้ Protobuf API ต้อง ship parser ไปด้วยทำให้เปลือง bundle size</li></ul><h2>JSON</h2><p>จากข้อข้างบน ถ้าอยากจะ ship Protobuf แต่ไม่อยากเปลือง bundle size วิธีหนึ่งที่ทำได้คือ Protobuf จะมี <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON representation</a> เราก็อาจจะให้รับส่งเป็น JSON แทนได้</p><p>วิธีนี้คิดว่าได้ข้อดีข้างบนมาหมดทุกข้อเลย</p><p>วิธี encode protobuf เป็น JSON อย่า parse ออกมาแล้วโยนใส่ JSON encoder ปกติ แต่ Protobuf จะมี function ให้ เช่น <a href=\"https://googleapis.dev/python/protobuf/latest/google/protobuf/json_format.html#google.protobuf.json_format.MessageToJson\">google.protobuf.json_format.MessageToJson</a> ใน Python หรือ <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/encoding/protojson?tab=doc#Marshal\">google.golang.org/protobuf/encoding/protojson.Marshal</a> ใน Go เวลาถอดรหัสก็ต้องใช้ function ของ protobuf เช่นกัน</p><p>JSON encoding ของ Protobuf จะไม่เหมือนกับ data structure ตรงๆ นิดนึงคือ</p><ul><li>Key จะกลายเป็น lowerCamelCase เสมอ เช่น field ชื่อ <code>user_name</code> จะกลายเป็น <code>userName</code></li><li>ถ้าไม่ได้แก้ settings อะไร default value ของแต่ละ field จะหายไป เช่นถ้ามี field <code>string username = 1;</code> อยู่มีค่าเป็น string เปล่า มันจะไม่ออกมาใน JSON (ถ้าอยากให้ parse สะดวกอาจจะต้องแก้ config ให้มันส่งออกมาด้วย)</li><li>enum จะแสดงเป็นชื่อ enum field แต่จะแก้ settings ให้ส่งเป็นตัวเลขแทนก็ได้ (default value ของ enum คือ member ตัวแรก)</li><li>bytes กลายเป็น base64 string</li></ul><p><strong>Fun fact:</strong> เวลาแปลง protobuf เป็น JSON ใน Go ไม่ได้ใช้ encoding/json แต่มันจะ build string ออกมาเลย (แต่ตอนถอดกลับใช้ยัง encoding/json นะ)</p><h2>Null value</h2><p>จากข้อข้างบนอาจจะสงสัยว่าทำไม default value ไม่ถูก encode ออกมา</p><p>คำตอบคือ Protobuf ไม่มี null value และนี่น่าจะเป็นสิ่งที่ผมพลาดเยอะที่สุด</p><p>กรณีที่เราเซต field ใดๆ เป็น null นั้น protobuf จะถือว่าใช้ default value ของ field นั้นๆ ได้แก่</p><ul><li>string คือ string เปล่า</li><li>bool คือ false</li><li>ตัวเลขต่างๆ คือ 0</li><li>enum คือ สมาชิกตัวแรกของ enum</li><li>repeated คือ empty list</li><li>เฉพาะ field ที่มี type เป็น message เท่านั้นจะมี null value ได้</li></ul><p>ที่เป็นแบบนี้เพราะ Protobuf จะไม่ encode field ที่มีค่าเป็น default ส่งไป</p><h2>Well Known Type</h2><p>Docs Protobuf เอา <a href=\"https://developers.google.com/protocol-buffers/docs/reference/google.protobuf\">WKT</a> ไปแอบลึกมากจนอาจจะไม่เคยรู้เลยว่ามีสิ่งนี้ด้วย</p><p>Well known type คือ message ต่างๆ ที่ติดมากับ Protobuf ได้แก่</p><ul><li><strong>google.protobuf.Duration</strong> เก็บระยะเวลา</li><li><strong>google.protobuf.Timestamp</strong> เก็บเวลา</li><li><strong>google.protobuf.Empty</strong> ไม่เก็บอะไรเลย</li></ul><p>ดังนั้นเวลาจะ encode เวลาควรจะใช้ WKT เสมอ เนื่องจากว่าใน library ภาษาต่างๆ มักจะมี function ที่ถอดรหัสเข้าออกเป็น native value ของภาษานั้นๆ ให้อยู่แล้ว เช่น <a href=\"https://googleapis.dev/python/protobuf/latest/google/protobuf/timestamp_pb2.html#google.protobuf.timestamp_pb2.Timestamp.ToDatetime\">ToDatetime</a> ใน Python หรือ <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/types/known/timestamppb?tab=doc#Timestamp.AsTime\">AsTime</a> ใน Go วิธีนี้ทำให้เราไม่ต้องนั่งจำว่า time บน service นี้ encode เป็นอะไร (ISO8601? POSIX? Custom format?)</p><p>เวลาใช้ WKT ต้อง import มาจาก <code>google/protobuf/timestamp.proto</code> (หรือไฟล์อื่นๆ ตามที่จะใช้) ซึ่งไม่มี document ไว้…</p><h2>Wrapped type</h2><p>จากข้อข้างบนเราบอกว่า Protobuf ไม่มี null value แต่ message เป็น null ได้ ดังนั้นถ้าอยากจะส่ง nullable เราก็แค่ยก field นั้นไปทำเป็น message ใหม่แล้วเซตเป็น null</p><p>ซึ่ง Protobuf ก็คิดมาแล้ว ใน WKT จะมี type ต่างๆ ที่ครอบมาให้แล้ว</p><ul><li><strong>google.protobuf.BoolValue</strong></li><li><strong>google.protobuf.BytesValue</strong></li><li><strong>google.protobuf.DoubleValue</strong></li><li><strong>google.protobuf.FloatValue</strong></li><li><strong>google.protobuf.Int32Value</strong></li><li><strong>google.protobuf.Int64Value</strong></li><li><strong>google.protobuf.StringValue</strong></li><li><strong>google.protobuf.UInt32Value</strong></li><li><strong>google.protobuf.UInt64Value</strong></li></ul><p>ทั้งหมดจะมี field เดียวคือ <code>value</code> และเมื่อ encode เป็น JSON แล้วมันจะหายไปกลายเป็นค่าที่เก็บไว้ตรงๆ (นี่แหละที่ถ้าทำ type เองจะทำไม่ได้)</p><h2>FileDescriptorSet</h2><p>เวลาใช้งาน protobuf เราจะใช้ protoc เพื่อทำ code generation ซึ่งต้องลง protoc-gen-* ตามภาษาที่ใช้งานด้วย</p><p>แล้ว protoc generate อะไรได้มั้ย?</p><p>คำตอบคือมัน generate FileDescriptorSet ได้</p><p>FileDescriptorSet เป็น well known type อันนึง มันคือการ .proto ให้เป็น protobuf แถมเราสามารถบอกให้ protoc include ไฟล์ทั้งหมดที่เรา include ต่อๆ กันมาได้ด้วย ทำให้ FileDescriptorSet นั้นจบในตัว</p><p>FileDescriptorSet นี้ไม่อยู่ใน protobuf documentation ด้วยนะ!!</p><h2>Any</h2><p>WKT อีก type หนึ่งที่น่าสนใจคือ Any ซึ่งน่าเสียดายที่ถึงมันจะอยู่ใน documentation แต่ library ต่างๆ ยังไม่พร้อมใช้เท่าไรนัก</p><p>Any ใช้เก็บ message อะไรก็ได้ โดยมันจะมี 2 field คือ</p><ul><li>type_url เก็บ URL ของ type นั้น เช่น type.googleapis.com/com.mycompany.TypeName</li><li>value เป็น bytes คือข้อมูลที่ต้องการเก็บ encode เป็น protobuf</li></ul><p>เวลา decode แล้ว library ที่รองรับจะสามารถอ่าน type ต้นฉบับได้เลยโดยไม่ต้อง decode เอง นอกไปจากนี้จะสังเกตว่า type_url นั้นเป็น URL เวลาเจอ type แปลกประหลาด <a href=\"https://github.com/protocolbuffers/protobuf/blob/389bd06d0a637d3fd1aded7de59a12ed8f83baad/src/google/protobuf/any.proto#L135\">Protobuf client library จะเข้าไปใน URL นั้นเพื่อโหลด type definition ให้อัตโนมัติ</a> ซึ่งฟีเจอร์นี้โม้ไว้เฉยๆ ยังไม่ได้ทำ</p><p>เวลา encode Any เป็น JSON มันจะกลายเป็น <code>{\"@type\": \"type.googleapis.com/com.mycompany.TypeName\"}</code> แล้วเอาค่าใน value ที่เก็บไว้เข้ามา merge เลยไม่ได้ทำเป็น field ย่อย ใครที่ใช้ Stackdriver Logging น่าจะเห็น output ที่มี <code>@type</code> field บ่อย</p><p>จากด้านบน ถ้าเราทำ message ที่มี Any กับ FileDescriptorSet ฝังรวมกันเราจะได้ <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#self-description\">Self describing message</a> แต่ปัจจุบันเนื่องจาก library ไม่รองรับกันเท่าไรจึง decode ยากมากๆ บางภาษาอาจจะ decode แล้วพังเลย</p><h2>Reflection</h2><p>แล้ว FileDescriptorSet ทำอะไรได้อีก? Protobuf ในบางภาษาจะมี reflection API ทำให้เราสามารถ create Protobuf message ได้ใน runtime (ภาษา dynamic เช่น JavaScript อาจจะไม่ต้องรองรับเพราะไม่ต้องใช้ codegen) เช่น <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/types/dynamicpb?tab=doc#Message\">dynamicpb</a></p><h2>Lots of potential</h2><p>เขียนมาทั้งหมดนี้แล้วจะเห็นธีมคล้ายๆ กันว่าถึง Protobuf จะออกมา 12 ปีแล้ว และ Proto3 ออกมา 4 ปีแล้วแต่ Protobuf ยังดูมี potential อีกมากที่ยังพัฒนาไม่เสร็จ</p></div></div></article></main></div></div>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"b0a0a7c729d262fd56982e3d29a28583d653fce2eaf98dca3e23dbdc3311afa3","category":"Thai"}