{"title":"Responsible JavaScript: Part II","link":"https://alistapart.com/article/responsible-javascript-part-2/","date":1560432628000,"content":"<div id=\"readability-page-1\" class=\"page\"><div><p>You and the rest of the dev team lobbied enthusiastically for a total re-architecture of the company’s aging website. Your pleas were heard by management—even up to the C-suite—who gave the green light. Elated, you and the team started working with the design, copy, and IA teams. Before long, you were banging out new code.</p><p><span>Article Continues Below</span></p><p>It started out innocently enough with an <code>npm install</code> here and an <code>npm install</code> there. Before you knew it, though, you were installing production dependencies like an undergrad doing keg stands without a care for the morning after.</p><p>Then you launched.</p><p>Unlike the aftermath of most copious boozings, the agony didn’t start the morning after. <em>Oh</em>, no. It came months later in the ghastly form of low-grade nausea and headache of product owners and middle management wondering why conversions and revenue were both down since the launch. It then hit a fever pitch when the CTO came back from a weekend at the cabin and wondered why the site loaded so slowly on their phone—if it indeed ever loaded at all.</p><p>Everyone was happy. Now <em>no</em> one is happy. Welcome to your first JavaScript hangover.</p><h2 id=\"section2\">It’s not your fault<a href=\"#section2\">#section2</a></h2><p>When you’re grappling with a vicious hangover, “I told you so” would be a well-deserved, if fight-provoking, rebuke—assuming you could even fight in so sorry a state.</p><p>When it comes to JavaScript hangovers, there’s plenty of blame to dole out. Pointing fingers is a waste of time, though. The landscape of the web today demands that we iterate faster than our competitors. This kind of pressure means we’re likely to take advantage of any means available to be as productive as possible. <em>That</em> means we’re more likely—but not necessarily doomed—to build apps with more overhead, and possibly use patterns that can hurt performance and accessibility.</p><p>Web development isn’t easy. It’s a long slog we rarely get right on the first try. The best part of working on the web, however, is that we don’t <em>have</em> to get it perfect at the start. We can make improvements after the fact, and that’s just what the second installment of <a href=\"https://alistapart.com/article/responsible-javascript-part-1/\">this series</a> is here for. Perfection is a long ways off. For now, let’s take the edge off of that JavaScript hangover by improving your site’s, er, <em>scriptuation</em> in the short term.</p><h2 id=\"section3\">Round up the usual suspects<a href=\"#section3\">#section3</a></h2><p>It might seem rote, but it’s worth going through the list of basic optimizations. It’s not uncommon for large development teams—particularly those that work across many repositories or don’t use optimized boilerplate—to overlook them.</p><h3 id=\"section4\">Shake those trees<a href=\"#section4\">#section4</a></h3><p>First, make sure your toolchain is configured to perform <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking\"><em>tree shaking</em></a>. If tree shaking is new to you, I wrote <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/\">a guide on it last year</a> you can consult. The short of it is that tree shaking is a process in which unused exports in your codebase don’t get packaged up in your production bundles.</p><p>Tree shaking is available out of the box with modern bundlers such as <a href=\"https://webpack.js.org/\">webpack</a>, <a href=\"https://rollupjs.org/\">Rollup</a>, or <a href=\"https://parceljs.org/\">Parcel</a>. <a href=\"https://gruntjs.com/\">Grunt</a> or <a href=\"https://gulpjs.com/\">gulp</a>—which are not <em>bundlers</em>, but rather <em>task runners</em>—won’t do this for you. A task runner doesn’t build a <a href=\"https://webpack.js.org/concepts/dependency-graph/\">dependency graph</a> like a bundler does. Rather, they perform discrete tasks on the files you feed to them with any number of plugins. Task runners <em>can</em> be extended with plugins to use bundlers to process JavaScript. If extending task runners in this way is problematic for you, you’ll likely need to manually audit and remove unused code.</p><p>For tree shaking to be effective, the following must be true:</p><ol><li>Your app logic and the packages you install in your project must be authored as <a href=\"https://ponyfoo.com/articles/es6-modules-in-depth\">ES6 modules</a>. Tree shaking <a href=\"https://en.wikipedia.org/wiki/CommonJS\">CommonJS</a> modules isn’t practically possible.</li><li>Your bundler must <em>not</em> transform ES6 modules into another module format at build time. If this happens in a toolchain that uses Babel, <a href=\"https://babeljs.io/docs/en/babel-preset-env\">@babel/preset-env configuration</a> must specify <a href=\"https://babeljs.io/docs/en/babel-preset-env#modules\"><code>modules: false</code></a> to prevent ES6 code from being converted to CommonJS.</li></ol><p>On the off chance tree shaking isn’t occurring during your build, getting it to work may help. Of course, its effectiveness varies on a case-by-case basis. It also depends on whether the modules you import introduce <a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\">side effects</a>, which may influence a bundler’s ability to shake unused exports.</p><h3 id=\"section5\">Split that code<a href=\"#section5\">#section5</a></h3><p>Chances are good that you’re employing some form of <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/\">code splitting</a>, but it’s worth re-evaluating how you’re doing it. No matter <em>how</em> you’re splitting code, there are two questions that are always worth asking yourself:</p><ol><li>Are you <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/#removing_duplicate_code\">deduplicating common code</a> between <a href=\"https://webpack.js.org/concepts/entry-points/\">entry points</a>?</li><li>Are you lazy loading all the functionality you reasonably can with <a href=\"https://developers.google.com/web/updates/2017/11/dynamic-import\">dynamic <code>import()</code></a>?</li></ol><p>These are important because reducing redundant code is essential to performance. Lazy loading functionality also improves performance by lowering the initial JavaScript footprint on a given page. On the redundancy front, using an analysis tool such as <a href=\"https://github.com/samccone/bundle-buddy\">Bundle Buddy</a> can help you find out if you have a problem.</p><figure id=\"figure1\"><img loading=\"lazy\" width=\"652\" height=\"628\" src=\"https://alistapart.com/wp-content/uploads/2019/06/figure-6-2x.png?w=435&amp;resize=652%2C628\" alt=\"The Bundle Buddy utility demonstrating how much code is shared between bundles of JavaScript.\"><figcaption>Bundle Buddy can examine your webpack compilation statistics and determine how much code is shared between your bundles.</figcaption></figure><p>Where lazy loading is concerned, it can be a bit difficult to know where to start looking for opportunities. When I look for opportunities in existing projects, I’ll search for user interaction points throughout the codebase, such as click and keyboard events, and similar candidates. Any code that requires a user interaction to run is a potentially good candidate for dynamic <code>import()</code>.</p><p>Of course, loading scripts on demand brings the possibility that interactivity could be noticeably delayed, as the script necessary for the interaction must be downloaded first. If data usage is not a concern, consider using the <a href=\"https://www.w3.org/TR/resource-hints/#prefetch\"><code>rel=prefetch</code> resource hint</a> to load such scripts at a low priority that won’t contend for bandwidth against critical resources. <a href=\"https://caniuse.com/#feat=link-rel-prefetch\">Support for<strong> </strong><code>rel=prefetch</code></a> is good, but nothing will break if it’s unsupported, as such browsers will ignore markup they doesn’t understand.</p><h3 id=\"section6\">Externalize third-party hosted code<a href=\"#section6\">#section6</a></h3><p>Ideally, you should self-host as many of your site’s dependencies as possible. If for some reason you <em>must</em> load dependencies from a third party, <a href=\"https://webpack.js.org/configuration/externals/\">mark them as externals</a> in your bundler’s configuration. Failing to do so could mean your website’s visitors will download both locally hosted code <em>and</em> the same code from a third party.</p><p>Let’s look at a hypothetical situation where this could hurt you: say that your site loads Lodash from a public CDN. You’ve also installed Lodash in your project for local development. However, if you fail to mark Lodash as external, your production code will end up loading a third party copy of it <em>in addition</em> to the bundled, locally hosted copy.</p><p>This may <em>seem</em> like common knowledge if you know your way around bundlers, but I’ve seen it get overlooked. It’s worth your time to check twice.</p><p>If you aren’t convinced to self-host your third-party dependencies, then consider adding <a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/#article-header-id-0\"><code>dns-prefetch</code></a>, <a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/#article-header-id-1\"><code>preconnect</code></a>, or possibly even <a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\"><code>preload</code></a> hints for them. Doing so can lower your site’s <a href=\"https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive\">Time to Interactive</a> and—if JavaScript is critical to rendering content—your site’s <a href=\"https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index\">Speed Index</a>.</p><h2 id=\"section7\">Smaller alternatives for less overhead<a href=\"#section7\">#section7</a></h2><p><a href=\"https://nodejs.org/en/knowledge/getting-started/what-is-node-core-verus-userland/\">Userland JavaScript</a> is like an obscenely massive candy store, and we as developers are awed by the sheer amount of open source offerings. Frameworks and libraries allow us to extend our applications to quickly do all sorts of stuff that would otherwise take loads of time and effort.</p><p>While I personally prefer to aggressively minimize the use of client-side frameworks and libraries in my projects, their value is compelling. Yet, we <em>do</em> have a responsibility to be a bit hawkish when it comes to what we install. When we’ve already built and shipped something that depends on a slew of installed code to run, we’ve accepted a baseline cost that only the maintainers of that code can practically address. Right?</p><p>Maybe, but then again, maybe not. It depends on the dependencies used. For instance, React is extremely popular, but <a href=\"https://preactjs.com/\">Preact</a> is an <a href=\"https://bundlephobia.com/result?p=preact@8.4.2\">ultra-small</a> alternative that largely shares the same API and retains compatibility with many React add-ons. <a href=\"https://moment.github.io/luxon/\">Luxon</a> and <a href=\"https://date-fns.org/\">date-fns</a> are much more compact alternatives to <a href=\"https://momentjs.com/\">moment.js</a>, which is <a href=\"https://bundlephobia.com/result?p=moment\">not exactly tiny</a>.</p><p>Libraries such as <a href=\"https://lodash.com/\">Lodash</a> offer many useful methods. Yet, some of them are easily replaceable with native ES6. <a href=\"https://lodash.com/docs/4.17.11#compact\">Lodash’s <code>compact</code> method</a>, for example, is replaceable with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\"><code>filter</code> array method</a>. <a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\">Many more can be replaced</a> without much effort, and without the need for pulling in a large utility library.</p><p>Whatever your preferred tools are, the idea is the same: do some research to see if there are smaller alternatives, or if native language features can do the trick. You may be surprised at how little effort it may take you to seriously reduce your app’s overhead.</p><h2 id=\"section8\">Differentially serve your scripts<a href=\"#section8\">#section8</a></h2><p>There’s a good chance you’re using Babel in your toolchain to transform your ES6 source into code that can run on older browsers. Does this mean we’re doomed to serve giant bundles even to browsers that don’t need them, until the older browsers disappear altogether? <a href=\"https://philipwalton.com/articles/deploying-es2015-code-in-production-today/\">Of course not</a>! Differential serving helps us get around this by generating two different builds of your ES6 source:</p><ul><li>Bundle one, which contains all the transforms and polyfills required for your site to work on older browsers. You’re probably already serving this bundle right now.</li><li>Bundle two, which contains <em>little to none</em> of the transforms and polyfills because it targets modern browsers. This is the bundle you’re probably not serving—at least not <em>yet</em>.</li></ul><p>Achieving this is a bit involved. <a href=\"https://calendar.perfplanet.com/2018/doing-differential-serving-in-2019/\">I’ve written a guide on one way you can do it</a>, so there’s no need for a deep dive here. The long and short of it is that you can modify your build configuration to generate an additional but smaller version of your site’s JavaScript code, and serve it only to modern browsers. The best part is that these are savings you can achieve without sacrificing any features or functionality you already offer. Depending on your application code, the savings could be quite significant.</p><figure id=\"figure2\"><img loading=\"lazy\" width=\"960\" height=\"297\" src=\"https://alistapart.com/wp-content/uploads/2019/06/diff-serving-bundles.jpg?w=960&amp;resize=960%2C297\" alt=\"\" data-recalc-dims=\"1\"><figcaption>A webpack-bundle-analyzer analysis of a project’s legacy bundle (left) versus one for a modern bundle (right). <a href=\"https://alistapart.com/wp-content/uploads/2019/06/diff-serving-bundles.jpg\" rel=\"noopener noreferrer\" target=\"_blank\">View full-sized image</a>.</figcaption></figure><p>The <a href=\"https://developers.google.com/web/fundamentals/primers/modules#browser\">simplest pattern</a> for serving these bundles to their respective platforms is brief. It also works a treat in modern browsers:</p><pre id=\"snippet1\"><code>&lt;!-- Modern browsers load this file: --&gt;\n<a href=\"https://alistapart.com/js/app.mjs\">/js/app.mjs</a>\n&lt;!-- Legacy browsers load this file: --&gt;\n<a href=\"https://alistapart.com/js/app.js\">/js/app.js</a></code></pre><p>Unfortunately, there’s a caveat with this pattern: legacy browsers like IE 11—and even relatively modern ones such as Edge versions 15 through 18—will download <em>both</em> bundles. If this is an acceptable trade-off for you, then worry no further.</p><p>On the other hand, you’ll need a workaround if you’re concerned about <a href=\"https://gist.github.com/jakub-g/5fc11af85a061ca29cc84892f1059fec\">the performance implications of older browsers downloading both sets of bundles</a>. Here’s one potential solution that uses script injection (instead of the <code>script</code> tags above) to avoid double downloads on affected browsers:</p><pre id=\"snippet2\"><code><span>var</span> scriptEl <span>=</span> document<span>.</span>createElement<span>(</span><span>\"script\"</span><span>)</span><span>;</span>\n\n<span>if</span> <span>(</span><span>\"noModule\"</span> <span>in</span> scriptEl<span>)</span> <span>{</span>\n  <span spellcheck=\"true\">// Set up modern script\n</span>  scriptEl<span>.</span>src <span>=</span> <span>\"/js/app.mjs\"</span><span>;</span>\n  scriptEl<span>.</span>type <span>=</span> <span>\"module\"</span><span>;</span>\n<span>}</span> <span>else</span> <span>{</span>\n  <span spellcheck=\"true\">// Set up legacy script\n</span>  scriptEl<span>.</span>src <span>=</span> <span>\"/js/app.js\"</span><span>;</span>\n  scriptEl<span>.</span>defer <span>=</span> <span>true</span><span>;</span> <span spellcheck=\"true\">// type=\"module\" defers by default, so set it here.\n</span><span>}</span>\n\n<span spellcheck=\"true\">// Inject!\n</span>document<span>.</span>body<span>.</span>appendChild<span>(</span>scriptEl<span>)</span><span>;</span></code></pre><p>This script infers that if a browser supports <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-nomodule\">the <code>nomodule</code> attribute</a> in the <code>script</code> element, it understands <code>type=\"module\"</code>. This ensures that legacy browsers only get legacy scripts and modern browsers only get modern ones. Be warned, though, that dynamically injected scripts load asynchronously by default, so set the <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async\">async</a></code> attribute to <code>false</code> if dependency order is crucial.</p><h2 id=\"section9\">Transpile less<a href=\"#section9\">#section9</a></h2><p>I’m not here to trash Babel. It’s indispensable, but lordy, it adds a <em>lot</em> of extra stuff without your ever knowing. It pays to peek under the hood to see what it’s up to. Some minor changes in your coding habits can have a positive impact on what Babel spits out.</p><figure id=\"figure3\"><img loading=\"lazy\" width=\"758\" height=\"421\" src=\"https://alistapart.com/wp-content/uploads/2019/06/twete.png?w=306&amp;resize=758%2C421\" alt=\"\" data-recalc-dims=\"1\"><figcaption><a href=\"https://twitter.com/_developit/status/1110229993999777793\">https://twitter.com/_developit/status/1110229993999777793</a></figcaption></figure><p>To wit: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters\">default parameters</a> are a <em>very</em> handy ES6 feature you probably already use:</p><pre id=\"snippet3\"><code><span>function</span> logger<span>(</span>message<span>,</span> level <span>=</span> <span>\"log\"</span><span>)</span> <span>{</span>\n  console<span>[</span>level<span>]</span><span>(</span>message<span>)</span><span>;</span>\n<span>}</span></code></pre><p>The thing to pay attention to here is the <code>level</code> parameter, which has a default of “log.” This means if we want to invoke <code>console.log</code> with this wrapper function, we don’t need to specify <code>level</code>. Great, right? Except when Babel transforms this function, the output looks like this:</p><pre id=\"snippet4\"><code><span>function</span> logger<span>(</span>message<span>)</span> <span>{</span>\n  <span>var</span> level <span>=</span> arguments<span>.</span>length <span>&gt;</span> <span>1</span> <span>&amp;&amp;</span> arguments<span>[</span><span>1</span><span>]</span> <span>!</span><span>==</span> undefined <span>?</span> arguments<span>[</span><span>1</span><span>]</span> <span>:</span> <span>\"log\"</span><span>;</span>\n\n  console<span>[</span>level<span>]</span><span>(</span>message<span>)</span><span>;</span>\n<span>}</span></code></pre><p>This is an example of how, despite our best intentions, developer conveniences can backfire. What was a handful of bytes in our source has now been transformed into <em>much</em> larger in our production code. Uglification can’t do much about it either, as arguments can’t be reduced. Oh, and if you think <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\">rest parameters</a> might be a worthy antidote, Babel’s transforms for them are even bulkier:</p><pre id=\"snippet5\"><code><span spellcheck=\"true\">// Source\n</span><span>function</span> logger<span>(</span><span>.</span><span>.</span><span>.</span>args<span>)</span> <span>{</span>\n  const <span>[</span>level<span>,</span> message<span>]</span> <span>=</span> args<span>;</span>\n\n  console<span>[</span>level<span>]</span><span>(</span>message<span>)</span><span>;</span>\n<span>}</span>\n<span spellcheck=\"true\">\n// Babel output\n</span><span>function</span> logger<span>(</span><span>)</span> <span>{</span>\n  <span>for</span> <span>(</span><span>var</span> _len <span>=</span> arguments<span>.</span>length<span>,</span> args <span>=</span> <span>new</span> Array<span>(</span>_len<span>)</span><span>,</span> _key <span>=</span> <span>0</span><span>;</span> _key <span>&lt;</span> _len<span>;</span> _key<span>++</span><span>)</span> <span>{</span>\n    args<span>[</span>_key<span>]</span> <span>=</span> arguments<span>[</span>_key<span>]</span><span>;</span>\n  <span>}</span>\n\n  const level <span>=</span> args<span>[</span><span>0</span><span>]</span><span>,</span>\n        message <span>=</span> args<span>[</span><span>1</span><span>]</span><span>;</span>\n  console<span>[</span>level<span>]</span><span>(</span>message<span>)</span><span>;</span>\n<span>}</span></code></pre><p>Worse yet, Babel transforms this code even for projects with a <a href=\"https://babeljs.io/docs/en/babel-preset-env\">@babel/preset-env</a> configuration <a href=\"https://babeljs.io/docs/en/babel-preset-env#targetsesmodules\">targeting modern browsers</a>, meaning the modern bundles in your differentially served JavaScript will be affected too! You <em>could</em> use <a href=\"https://babeljs.io/docs/en/babel-preset-env#loose\">loose transforms</a> to soften the blow—and that’s a fine idea, as they’re often quite a bit smaller than their more spec-compliant counterparts—<a href=\"http://2ality.com/2015/12/babel6-loose-mode.html\">but enabling loose transforms can cause issues if you remove Babel from your build pipeline later on</a>.</p><p>Regardless of whether you decide to enable loose transforms, here’s one way to cut the cruft of transpiled default parameters:</p><pre id=\"snippet6\"><code><span spellcheck=\"true\">// Babel won't touch this\n</span><span>function</span> logger<span>(</span>message<span>,</span> level<span>)</span> <span>{</span>\n  console<span>[</span>level <span>||</span> <span>\"log\"</span><span>]</span><span>(</span>message<span>)</span><span>;</span>\n<span>}</span></code></pre><p>Of course, default parameters aren’t the <em>only</em> feature to be wary of. For example, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">spread syntax</a> gets transformed, as do <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a> and a whole host of <a href=\"https://babeljs.io/repl/#?babili=false&amp;browsers=%3E%200.25%25%2C%20ie%20%3E%2010%2C%20Firefox%20ESR%2C%20not%20dead&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYGwhgzhAECyYDsCuAzMwAuSBOBTb0A3gFDTTAD2CEG2SmFBAFALaKrpZ7YA05FSBLQCeASiKky0DAAsAlhAB0bZGkw580ALzQVHddwDcksrIWLKgkdv5Xsw42QC-xF8VCQYAYTAFcADwxcBAATGHhVTg0CEjJKalp6DEZoVgoQ3BA-YVxfPkoQRj5FEt8AcwhxWKkIJAAHfCYSxXLKxykTaXklFnTMm16MkHbTbsUc3xsJ7BGu8wKUnQWZyRcySTw6sDkhVOWqzrMlZZtl9pc3eJpoNBY5EGEfAh0EXAB3aCemACIfFntvnxvgAmAAMoOBgOg3wAMoJJrAFBg4LgMGAQCA5MAod8ACoUYQUNE4gBSYC2CG-okMQA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=true&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env&amp;prettier=false&amp;targets=&amp;version=7.4.5&amp;externalPlugins=\">other stuff</a>.</p><p>If you don’t want to avoid these features altogether, you have a couple ways of reducing their impact:</p><ol><li>If you’re authoring a library, consider using <a href=\"https://babeljs.io/docs/en/babel-runtime\">@babel/runtime</a> in concert with <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\">@babel/plugin-transform-runtime</a> to deduplicate the helper functions Babel puts into your code.</li><li>For polyfilled features in apps, you can include them selectively with <a href=\"https://babeljs.io/docs/en/babel-polyfill\">@babel/polyfill</a> via <a href=\"https://babeljs.io/docs/en/babel-preset-env#usebuiltins\">@babel/preset-env’s useBuiltIns: “usage”</a> option.</li></ol><p>This is solely my opinion, but I believe the best choice is to avoid transpilation altogether in bundles generated for modern browsers. That’s not always possible, especially if you use <a href=\"https://reactjs.org/docs/introducing-jsx.html\">JSX</a>, which must be transformed for <em>all</em> browsers, or if you’re using bleeding edge language features that aren’t widely supported. In the latter case, it might be worth asking if those features are really necessary to deliver a good user experience (they rarely are). If you arrive at the conclusion that Babel must be a part of your toolchain, then it’s worth peeking under the hood from time to time to catch suboptimal stuff Babel might be doing that you can improve on.</p><h2 id=\"section10\">Improvement is not a race<a href=\"#section10\">#section10</a></h2><p>As you massage your temples wondering when this horrid JavaScript hangover is going to lift, understand that it’s precisely when we rush to get something out there as fast as we possibly can that the user experience can suffer. As the web development community obsesses on iterating faster in the name of competition, it’s worth your time to <a href=\"https://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow\"><em>slow down a little bit</em></a>. You’ll find that by doing so, you may not be iterating as fast as your competitors, but <em>your product</em> will be <em>faster</em> than theirs.</p><p>As you take these suggestions and apply them to your codebase, know that progress doesn’t spontaneously happen overnight. Web development is a job. The truly impactful work is done when we’re thoughtful and dedicated to the craft for the long haul. Focus on steady improvements. Measure, test, repeat, and your site’s user experience will improve, and you’ll get faster bit by bit over time.</p><p><em>Special thanks to </em><a href=\"https://twitter.com/_developit\"><em>Jason Miller</em></a><em> for tech editing this piece. Jason is the creator and one of the many maintainers of </em><a href=\"https://preactjs.com/\"><em>Preact</em></a><em>, a vastly smaller alternative to React with the same API. If you use Preact, </em><a href=\"https://opencollective.com/preact\"><em>please consider supporting Preact through Open Collective</em></a><em>.</em></p></div></div>","author":"","siteTitle":"A List Apart: The Full Feed","siteHash":"09b09f389b84b264a6ebab120b6208479961d3fe7df4850a75b103b2b9c8a950","entryHash":"8d2ee969dd6afde7074f0c8a7f36c83fefc4e1173bd75595f3d3faa452f2c283","category":"Tech"}