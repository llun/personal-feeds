{"title":"A Complete Guide To Incremental Static Regeneration (ISR) With Next.js","link":"https://smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/","date":1619013300000,"content":"<p>A year ago, <a href=\"https://nextjs.org/blog/next-9-3\">Next.js 9.3</a> released support for Static Site Generation (SSG) making it the first hybrid framework. I’d been a happy Next.js user for about a few years at this point, but this release made Next.js my new default solution. After working with Next.js extensively, I joined Vercel to help companies like Tripadvisor and Washington Post as they adopt and scale Next.js.</p>\n<p>In this article, I’d like to explore a new evolution of the Jamstack: <strong>Incremental Static Regeneration (ISR)</strong>. Below you’ll find a guide to ISR — including use cases, demos and tradeoffs.</p>\n<h3>The Problem with Static-Site Generation</h3>\n<p>The idea behind the Jamstack is appealing: pre-rendered static pages which can be pushed to a CDN and globally available in seconds. Static content is fast, resilient to downtime, and immediately indexed by crawlers. But there are some issues.</p>\n<p>If you’ve adopted the Jamstack architecture while building a large-scale static site, you might be stuck waiting hours for your site to build. If you double the number of pages, the build time also doubles. Let’s consider <a href=\"https://www.target.com\">Target.com</a>. Is it possible to statically generate millions of products with every deployment?</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/384b3f3b-756d-4061-92c4-59a4d2a9f1fb/build-times-regeneration-nextjs.png\" /></p>\n<p>Even if every page was statically generated in an unrealistic 1ms, it would still take <strong>hours to rebuild the entire site</strong>. For large web applications, choosing <em>complete</em> static-site generation is a non-starter. Large-scale teams need a more flexible, personalized, hybrid solution.</p>\n<h3>Content Management Systems (CMS)</h3>\n<p>For many teams, their site’s content is decoupled from the code. Using a <a href=\"https://www.smashingmagazine.com/2021/03/going-headless-use-cases/\">Headless CMS</a> allows content editors to publish changes without involving a developer. However, with traditional static sites, this process can be slow.</p>\n<p>Consider an e-commerce store with 100,000 products. Product prices change frequently. When a content editor changes the price of headphones from $100 to $75 as part of a promotion, their CMS uses a webhook to rebuild the entire site. It’s not feasible to wait hours for the new price to be reflected.</p>\n<p>Long builds with unnecessary computation might also incur additional expenses. Ideally, your application is intelligent enough to understand which products changed and <em>incrementally</em> update those pages <strong>without needing a full rebuild</strong>.</p>\n<h3>Incremental Static Regeneration (ISR)</h3>\n<p><a href=\"https://nextjs.org/\">Next.js</a> allows you to create or update static pages <em>after</em> you’ve built your site. Incremental Static Regeneration (ISR) enables developers and content editors to use static-generation on a per-page basis, <strong>without needing to rebuild the entire site</strong>. With ISR, you can retain the benefits of static while scaling to millions of pages.</p>\n<p>Static pages can be generated at runtime (on-demand) instead of at build-time with ISR. Using analytics, A/B testing, or other metrics, you are equipped with the flexibility to make your own tradeoff on build times. </p>\n<p>Consider the e-commerce store from before with 100,000 products. At a realistic 50ms to statically generate each product page, this would take <strong>almost 2 hours without ISR</strong>. With ISR, we can choose from:</p>\n<ul>\n<li><strong>Faster Builds</strong><br />Generate the most popular 1,000 products at build-time. Requests made to other products will be a cache miss and statically generate on-demand: 1-minute builds.</li>\n<li><strong>Higher Cache Hit Rate</strong><br />Generate 10,000 products at build-time, ensuring more products are cached ahead of a user’s request: 8-minute builds.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/14bd554d-ea02-49d9-8077-7b94f8ba69ad/generation-regeneration-nextjs.png\" /></p>\n<p>Let’s walk through an example of ISR for an e-commerce product page.</p>\n<h3>Getting Started</h3>\n<h4>Fetching Data</h4>\n<p>If you’ve never used Next.js before, I’d recommend reading <a href=\"https://www.smashingmagazine.com/2020/10/getting-started-with-next-js/\">Getting Started With Next.js</a> to understand the basics. ISR uses the same Next.js API to generate static pages: <a href=\"https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation\"><code>getStaticProps</code></a>. By specifying <code>revalidate: 60</code>, we inform Next.js to use ISR for this page.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a9d6ec1f-b714-4102-b845-0986bfc65417/regeneration-regeneration-nextjs.png\" /></p>\n<ol>\n<li>Next.js can define a revalidation time per page. Let’s set it at 60 seconds.</li>\n<li>The initial request to the product page will show the cached page with the original price.</li>\n<li>The data for the product is updated in the CMS.</li>\n<li>Any requests to the page after the initial request and before 60 seconds are cached and instantaneous.</li>\n<li>After the 60-second window, the next request will still show the cached (stale) page. Next.js triggers a regeneration of the page <em>in the background</em>.</li>\n<li>Once the page has been successfully generated, Next.js will invalidate the cache and show the updated product page. If the background regeneration fails, the old page remains unaltered.</li>\n</ol>\n<pre><code>// pages/products/[id].js\n\nexport async function getStaticProps({ params }) {\n  return {\n    props: {\n      product: await getProductFromDatabase(params.id)\n    },\n    revalidate: 60\n  }\n}\n</code></pre>\n\n<h4>Generating Paths</h4>\n<p>Next.js defines which products to generate at build-time and which on-demand. Let’s only generate the most popular 1,000 products at build-time by providing <code>getStaticPaths</code> with a list of the top 1,000 product IDs.</p>\n<p>We need to configure how Next.js will “fallback” when requesting any of the other products after the initial build. There are two options to choose from: <code>blocking</code> and <code>true</code>. </p>\n<ul>\n<li><code>fallback: blocking</code> (preferred)<br />When a request is made to a page that hasn’t been generated, Next.js will server-render the page on the first request. Future requests will serve the static file from the cache.</li>\n<li><code>fallback: true</code><br />When a request is made to a page that hasn’t been generated, Next.js will immediately serve a static page with a loading state on the first request. When the data is finished loading, the page will re-render with the new data and be cached. Future requests will serve the static file from the cache.</li>\n</ul>\n<pre><code>// pages/products/[id].js\n\nexport async function getStaticPaths() {\n  const products = await getTop1000Products()\n  const paths = products.map((product) =&gt; ({\n    params: { id: product.id }\n  }))\n\n  return { paths, fallback: 'blocking' }\n}\n</code></pre>\n\n\n\n<h3>Tradeoffs</h3>\n<p>Next.js focuses first and foremost on the end-user. The \"best solution\" is relative and varies by industry, audience, and the nature of the application. By allowing developers to shift between solutions without leaving the bounds of the framework, Next.js lets you pick the right tool for the project.</p>\n<h4>Server-Side Rendering</h4>\n<p>ISR isn’t always the right solution. For example, the Facebook news feed cannot show stale content. In this instance, you’d want to use SSR and potentially your own <code>cache-control</code> headers with <a href=\"https://www.fastly.com/blog/surrogate-keys-part-1\">surrogate keys</a> to invalidate content. Since Next.js is a hybrid framework, you’re able to make that tradeoff yourself and stay within the framework.</p>\n<pre><code>// You can cache SSR pages at the edge using Next.js\n// inside both getServerSideProps and API Routes\nres.setHeader('Cache-Control', 's-maxage=60, stale-while-revalidate');\n</code></pre>\n\n<p>SSR and edge caching are similar to ISR (especially if using <code>stale-while-revalidate</code> caching headers) with the main difference being the <em>first</em> request. With ISR, the first request can be guaranteed static if pre-rendered. Even if your database goes down, or there’s an issue communicating with an API, your users will still see the properly served static page. However, SSR will allow you to customize your page based on the incoming request.</p>\n<p><strong>Note</strong>: <em>Using SSR without caching can lead to poor performance. Every millisecond matters when blocking the user from seeing your site, and this can have a dramatic effect on your <a href=\"https://web.dev/time-to-first-byte/\">TTFB</a> (Time to First Byte).</em></p>\n<h4>Static-Site Generation</h4>\n<p>ISR doesn’t always make sense for small websites. If your revalidation period is larger than the time it takes to rebuild your entire site, you might as well use traditional static-site generation.</p>\n<h4>Client-Side Rendering</h4>\n<p>If you use React without Next.js, you’re using client-side rendering. Your application serves a loading state, followed by requesting data inside JavaScript on the client-side (e.g. <code>useEffect</code>). While this does increase your options for hosting (as there’s no server necessary), there are tradeoffs.</p>\n<p>The lack of pre-rendered content from the initial HTML leads to slower and less dynamic Search Engine Optimization (SEO). It’s also not possible to use CSR with JavaScript disabled.</p>\n<h4>ISR Fallback Options</h4>\n<p>If your data can be fetched quickly, consider using <code>fallback: blocking</code>. Then, you don’t need to consider the loading state and your page will always show the same result (regardless of whether it’s cached or not). If your data fetching is slow, <code>fallback: true</code> allows you to immediately show a loading state to the user.</p>\n<h3>ISR: Not Just Caching!</h3>\n<p>While I’ve explained ISR through the context of a cache, it’s designed to <strong>persist your generated pages</strong> between deployments. This means that you’re able to roll back instantly and not lose your previously generated pages.</p>\n<p>Each deployment can be keyed by an ID, which Next.js uses to persist statically generated pages. When you roll back, you can update the key to point to the previous deployment, allowing for atomic deployments. This means that you can visit your previous immutable deployments and they’ll work as intended.</p>\n<ul>\n<li>Here’s an example of reverting code with ISR:</li>\n<li>You push code and get a deployment ID 123.</li>\n<li>Your page contains a typo “Smshng Magazine”.</li>\n<li>You update the page in the CMS. No re-deploy needed.</li>\n<li>Once your page shows “Smashing Magazine”, it’s persisted in storage.</li>\n<li>You push some bad code and deploy ID 345.</li>\n<li>You roll back to deployment ID 123.</li>\n<li>You still see “Smashing Magazine”.</li>\n</ul>\n<p>Reverts and persisting static pages are out of scope of Next.js and dependent on your hosting provider. Note that ISR differs from server-rendering with <code>Cache-Control</code> headers because, by design, caches expire. They are not shared across regions and will be purged when reverting.</p>\n<h3>Examples of Incremental Static Regeneration</h3>\n<p>Incremental Static Regeneration works well for e-commerce, marketing pages, blog posts, ad-backed media, and more.</p>\n<ul>\n<li><a href=\"https://nextjs.org/commerce\">E-commerce Demo</a><br />Next.js Commerce is an all-in-one starter kit for high-performance e-commerce sites.</li>\n<li><a href=\"https://reactions-demo.vercel.app/\">GitHub Reactions Demo</a><br />React to the original GitHub issue and watch ISR update the statically generated landing page.</li>\n<li><a href=\"https://static-tweet.vercel.app/\">Static Tweets Demo</a><br />This project deploys in 30 seconds, but can statically generate 500M tweets on-demand using ISR.</li>\n</ul>\n<h3>Learn Next.js Today</h3>\n<p>Developers and large teams are choosing <a href=\"http://nextjs.org/learn\">Next.js</a> for its hybrid approach and ability to incrementally generate pages on-demand. With ISR, you get the benefits of static with the flexibility of server-rendering. ISR works out of the box using <code>next start</code>.</p>\n<p>Next.js has been designed for <a href=\"https://nextjs.org/blog/incremental-adoption\">gradual adoption</a>. With Next.js, you can continue using your existing code and add as much (or as little) React as you need. By starting small and incrementally adding more pages, you can prevent derailing feature work by avoiding a complete rewrite. <a href=\"https://nextjs.org/learn/basics/create-nextjs-app\">Learn more about Next.js</a> — and happy coding, everyone!</p>\n<h3>Further Reading</h3>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2020/10/getting-started-with-next-js/\">Getting Started With Next.js</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2020/09/comparison-styling-methods-next-js/\">Comparing Styling Methods In Next.js</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2020/10/graphql-server-next-javascript-api-routes/\">How To Build A GraphQL Server Using Next.js API Routes</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"0146ba4a599aa9686248ca9f44b9f8cb390c15c954b7915d51784b357ce366aa","category":"Tech"}