{"title":"A Guide To Undoing Mistakes With Git","link":"https://smashingmagazine.com/2021/05/undoing-mistakes-git-part1/","date":1620138600000,"content":"<p>Working with code is a risky endeavour: There are countless ways to shoot yourself in the foot! But if you use Git as your version control system, then you have an excellent safety net. A lot of “undo” tools will help you recover from almost any type of disaster.</p>\n<p>In this first article of our two-part series, we will look at various mistakes — and how to safely undo them with Git!</p>\n<h3>Discard Uncommitted Changes in a File</h3>\n<p>Suppose you’ve made some changes to a file, and after some time you notice that your efforts aren’t leading anywhere. It would be best to start over and undo your changes to this file.</p>\n<p>The good news is that if you haven’t committed the modifications, undoing them is pretty easy. But there’s also a bit of bad news: You <strong>cannot bring back the modifications</strong> once you’ve undone them! Because they haven’t been saved to Git’s “database”, there’s no way to restore them!</p>\n<p>With this little warning out of the way, let’s undo our changes in <code>index.html</code>:</p>\n<pre><code>$ git restore index.html\n</code></pre>\n\n<p>This command will restore our file to its last committed state, wiping it clean of any local changes.</p>\n<h3>Restore a Deleted File</h3>\n<p>Let’s take the previous example one step further. Let’s say that, rather than modifying <code>index.html</code>, you’ve <strong>deleted it entirely</strong>. Again, let’s suppose you haven’t committed this to the repository yet.</p>\n<p>You’ll be pleased to hear that <code>git restore</code> is equipped to handle this situation just as easily:</p>\n<pre><code>$ git restore index.html\n</code></pre>\n\n<p>The <code>restore</code> command doesn’t really care <em>what</em> exactly you did to that poor file. It simply recreates its last committed state!</p>\n<h3>Discard Some of Your Changes</h3>\n<p>Most days are a mixture of good and bad work. And sometimes we have both in a single file: Some of your modifications will be great (let’s be generous and call them genius), while others are fit for the garbage bin.</p>\n<p>Git allows you to work with changes in a very granular way. Using <code>git restore</code> with the <code>-p</code> flag makes this whole undoing business much more nuanced:</p>\n<pre><code>$ git restore -p index.html\n</code></pre>\n\n<p>Git takes us by the hand and walks us through every <strong>chunk of changes</strong> in the file, asking whether we want to throw it away (in which case, we would type <code>y</code>) or keep it (typing <code>n</code>):</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f0975d23-2d01-4137-b905-b5f12b7f67f5/commit-with-typo-2x.png\" /></p>\n<p>Using the <code>--amend</code> option allows you to change this very last commit (and <em>only</em> this one):</p>\n<pre><code>$ git commit --amend -m \"A message without typos\"\n</code></pre>\n\n<p>In case you’ve also <strong>forgotten to add a certain change</strong>, you can easily do so. Simply stage it like any other change with the <code>git add</code> command, and then run <code>git commit --amend</code> again:</p>\n<pre><code>$ git add forgotten-change.txt\n\n$ git commit --amend --no-edit\n</code></pre>\n\n<p>The <code>--no-edit</code> option tells Git that we don’t want to change the commit’s message this time.</p>\n<h3>Revert the Effects of a Bad Commit</h3>\n<p>In all of the above cases, we were pretty quick to recognize our mistakes. But often, we only learn of a mistake long after we’ve made it. The bad commit sits in our revision history, peering snarkily at us.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/393dea41-d7d0-431f-9ecb-28c698c1a041/revert-commit-01-2x.png\" /></p>\n<p>Of course, there’s a solution to this problem, too: the <code>git revert</code> command! And it solves our issue in a very non-destructive way. Instead of ripping our bad commit out of the history, it creates a <strong>new commit</strong> that contains the opposite changes.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4a7f6c5c-827f-433a-b0f6-6c52e5252e43/revert-commit-02-2x.png\" /></p>\n<p>Performing that on the command line is as simple as providing the revision hash of that bad commit to the <code>git revert</code> command:</p>\n<pre><code>$ git revert 2b504bee\n</code></pre>\n\n<p>As mentioned, this will <em>not</em> delete our bad commit (which could be problematic if we have already shared it with colleagues in a remote repository). Instead, a <strong>new commit</strong> containing the reverted changes will be automatically created.</p>\n<h3>Restore a Previous State of the Project</h3>\n<p>Sometimes, we have to admit that we’ve coded ourselves into a dead end. Perhaps our last couple of commits have yielded no fruit and are better off undone.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b2bd12f2-9574-434d-bc1e-04801ec27451/reset-before-and-after-2x.png\" /></p>\n<p>Luckily, this problem is pretty easy to solve. We simply need to provide the SHA-1 hash of the revision that we want to return to when we use the <code>git reset</code> command. Any commits that come after this revision will then disappear:</p>\n<pre><code>$ git reset --hard 2b504bee\n</code></pre>\n\n<p>The <code>--hard</code> option makes sure that we are left with a <strong>clean</strong> working copy. Alternatively, we can use the <code>--mixed</code> option for a bit more flexibility (and safety): <code>--mixed</code> will preserve the changes that were contained in the deleted commits as local changes in our working copy.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0819576a-1ffe-4d18-8cb0-3c0479463780/git-reflog-2x.png\" /></p>\n<p>The first thing to know about reflog is that it’s <strong>ordered chronologically</strong>. Therefore, it should come as no surprise to see our recent <code>git reset</code> mistake at the very top. If we now want to undo this, we can simply return to the state before, which is also protocoled here, right below!</p>\n<p>We can now copy the commit hash of this safe state and create a new branch based on it:</p>\n<pre><code>$ git branch happy-ending e5b19e4\n</code></pre>\n\n<p>Of course, we could have also used <code>git reset e5b19e4</code> to return to this state. Personally, however, I prefer to create a new branch: It comes with no downsides and allows me to inspect whether this state is really what I want.</p>\n<h3>Restore a Single File From a Previous State</h3>\n<p>Until now, when we’ve worked with committed states, we’ve always worked with the complete project. But what if we want to <strong>restore a single file</strong>, not the whole project? For example, let’s say we’ve deleted a file, only to find out much later that we shouldn’t have. To get us out of this misery, we’ll have to solve two problems:</p>\n<ol>\n<li>find the commit where we deleted the file,</li>\n<li>then (and only then) restore it.</li>\n</ol>\n<p>Let’s go search the commit history for our poor lost file:</p>\n<pre><code>$ git log -- &lt;filename&gt;\n</code></pre>\n\n<p>The output of this lists all commits where this file has been modified. And because <code>log</code> output is sorted chronologically, we shouldn’t have to search for long — the commit in which we deleted the file will likely be topmost (because after deleting it, the file probably wouldn’t show up in newer commits anymore).</p>\n<p>With that commit’s hash and the name of our file, we have everything we need to bring it back from the dead:</p>\n<pre><code>$ git checkout &lt;deletion commit hash&gt;~1 -- &lt;filename&gt;\n</code></pre>\n\n<p>Note that we’re using <code>~1</code> to address the commit <em>before</em> the one where we made the deletion. This is necessary because the commit where the deletion happened doesn’t contain the file anymore, so we can’t use it to restore the file.</p>\n<h3>You Are Now (Almost) Invincible</h3>\n<p>During the course of this article, we’ve witnessed many disasters — but we’ve seen that virtually nothing is beyond repair in Git! Once you know the right commands, you can always find a way to save your neck.</p>\n<p>But to really become invincible (in Git, that is), you’ll have to wait for the <strong>second part of this series</strong>. We will look at some more hairy problems, such as how to recover deleted branches, how to move commits between branches, and how to combine multiple commits into one!</p>\n<p>In the meantime, if you want to learn more about undoing mistakes with Git, I recommend the free “<a href=\"https://www.git-tower.com/learn/git/first-aid-kit?utm_source=smashingmagazine&amp;utm_medium=guestpost&amp;utm_campaign=undoing-mistakes-01\">First Aid Kit for Git</a>”, a series of short videos about this very topic.</p>\n<p>See you soon in part two of this series! <a href=\"https://www.smashingmagazine.com/the-smashing-newsletter/\">Subscribe to the Smashing Newsletter</a> to not miss that one. ;-)</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"58af1749caff9b47c4c86ffd8dd1aa64443a0e92b7ca36a3e9c528c5b190a356","category":"Tech"}