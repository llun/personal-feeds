{"title":"Create Responsive Image Effects With CSS Gradients And `aspect-ratio`","link":"https://smashingmagazine.com/2021/02/responsive-image-effects-css-gradients-aspect-ratio/","date":1614087000000,"content":"<p>To prepare for our future image effects, we’re going to set up a card component that has a large image at the top followed by a headline and description. The common problem with this setup is that we may not always have perfect control over <em>what</em> the image is, and more importantly to our layout, what its <em>dimensions</em> are. And while this can be resolved by cropping ahead of time, we can still encounter issues due to responsively sized containers. A consequence is uneven positions of the card content which really stands out when you present a row of cards.</p>\n<p>Another previous solution besides cropping may have been to swap from an inline <code>img</code> to a blank <code>div</code> that only existed to present the image via <code>background-image</code>. I’ve implemented this solution many times myself in the past. One advantage this has is using <strong>an older trick for aspect ratio</strong> which uses a zero-height element and sets a <code>padding-bottom</code> value. Setting a padding value as a percent results in a final computed value that is relative to the element’s width. You may have also used this idea to maintain a 16:9 ratio for video embeds, in which case the padding value is found with the formula:  <code>9/16 = 0.5625 * 100% = 56.26%</code>. But we’re going to <strong>explore two modern CSS properties</strong> that don’t involve extra math, give us more flexibility, and also allow keeping the semantics provided by using a real <code>img</code> instead of an empty <code>div</code>.</p>\n<p>First, let’s define the HTML semantics, including use of an unordered list as the cards’ container:</p>\n<pre><code>&lt;ul class=\"card-wrapper\"&gt;\n  &lt;li class=\"card\"&gt;\n    &lt;img src=\"\" alt=\"\"&gt;\n    &lt;h3&gt;A Super Wonderful Headline&lt;/h3&gt;\n    &lt;p&gt;Lorem ipsum sit dolor amit&lt;/p&gt;\n  &lt;/li&gt;\n  &lt;!-- additional cards --&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>Next, we’ll create a minimal set of baseline styles for the <code>.card</code> component. We’ll set some basic visual styles for the card itself, a quick update to the expected <code>h3</code> headline, then essential styles to begin to style the card image. </p>\n<pre><code>.card {\n  background-color: #fff;\n  border-radius: 0.5rem;\n  box-shadow: 0.05rem 0.1rem 0.3rem -0.03rem rgba(0, 0, 0, 0.45);\n  padding-bottom: 1rem;\n}\n\n.card &gt; :last-child {\n  margin-bottom: 0;\n}\n\n.card h3 {\n  margin-top: 1rem;\n  font-size: 1.25rem;\n}\n\nimg {\n  border-radius: 0.5rem 0.5rem 0 0;\n  width: 100%;\n}\n\nimg ~ * {\n  margin-left: 1rem;\n  margin-right: 1rem;\n}\n</code></pre>\n\n<p>The last rule uses the <em>general sibling combinator</em> to add a horizontal margin to any element that follows the <code>img</code> since we want the image itself to be flush with the sides of the card.</p>\n<p>And our progress so far leads us to the following card appearance:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ed39732a-0106-4e7f-8ef4-5a515902d73b/baseline-card-styles-css-gradients-aspect-ratio.png\" /></p>\n<p>Finally, we’ll create the <code>.card-wrapper</code>  styles for a quick responsive layout using CSS grid. This will also remove the default list styles.</p>\n<pre><code>.card-wrapper {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(30ch, 1fr));\n  grid-gap: 1.5rem;\n}\n</code></pre>\n\n<p><strong>Note</strong>: <em>If this grid technique is unfamiliar to you, review the explanation in my <a href=\"https://moderncss.dev/solutions-to-replace-the-12-column-grid/\">tutorial about modern solutions for the 12-column grid</a>.</em></p>\n<p>With this applied and with all cards containing an image with a valid source path, our <code>.card-wrapper</code> styles give us the following layout:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bff61e0b-118b-491d-9b01-605ef46d3689/baseline-with-card-wrapper-css-gradients-aspect-ratio.png\" /></p>\n<p>As demonstrated in the preview image, these baseline styles aren’t enough to properly contain the images given their varying natural dimensions. We’re in need of a method to constrain these images uniformly and consistently.</p>\n<h3>Enable Uniform Image Sizes with <code>object-fit</code></h3>\n<p>As noted earlier, you may previously have made an update in this scenario to change the images to be added via <code>background-image</code> instead and used <code>background-size: cover</code> to handle nicely resizing the image. Or you may have tried to enforce cropping ahead of time (still a worthy goal since any image size reduction will improve performance!).</p>\n<p>Now, we have the property <code>object-fit</code> available which enables an <code>img</code> tag to act as the container for the image. And, it comes with a <code>cover</code> value as well that results in a similar effect as the background image solution, but with the bonus of <strong>retaining the semantics</strong> of an inline image. Let’s apply it and see how it works.</p>\n<p>We do need to pair it with a <code>height</code> dimension for extra guidance on how we want the image container to behave (recall we had already added <code>width: 100%</code>). And we’re going to use the <code>max()</code> function to select either <code>10rem</code> or <code>30vh</code> depending on which is larger in a given context, which prevents the image height from shrinking too much on smaller viewports <em>or</em> when the user has set a large zoom.</p>\n<pre><code>img {\n  /* ...existing styles */\n  object-fit: cover;\n  height: max(10rem, 30vh);\n}\n</code></pre>\n\n<p><strong>Bonus Accessibility Tip</strong>: <em>You should always test your layouts with 200% and 400% zoom on desktop. While there isn’t currently a <code>zoom</code> media query, functions like <code>max()</code> can help resolve layout issues. Another context this technique is useful is spacing between elements.</em></p>\n<p>With this update, we’ve definitely improved things, and the visual result is as if we’d use the older background image technique:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dda661db-71d9-41cc-86d6-7203a5f675a3/aspect-ratio-css-gradients-object-fit.png\" /></p>\n<h3>Responsively Consistent Image Sizing With <code>aspect-ratio</code></h3>\n<p>When using <code>object-fit</code> by itself, one downside is that we still need to set some dimension hints.</p>\n<p>An upcoming property (currently available in Chromium browsers) called <code>aspect-ratio</code> will enhance our ability to consistently size images.</p>\n<p>Using this property, we can <strong>define a ratio</strong> to resize the image instead of setting explicit dimensions. We’ll continue to use it in combination with <code>object-fit</code> to ensure these dimensions only affect the image as a container, otherwise, the image could appear distorted.</p>\n<p>Here is our full updated image rule:</p>\n<pre><code>img {\n  border-radius: 0.5rem 0.5rem 0 0;\n  width: 100%;\n  object-fit: cover;\n  aspect-ratio: 4/3;\n}\n</code></pre>\n\n<p>We’re going to start with an image ratio of 4/3 for our card context, but you could choose any ratio. For example, 1/1 for a square, or 16/9 for standard video embeds.</p>\n<p>Here are the updated cards, although it will probably be difficult to notice the visual difference in this particular instance since the aspect ratio happens to closely match the appearance we achieved by setting the <code>height</code> for <code>object-fit</code> alone.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9f670769-3bc2-497f-ade6-81ce9060db06/aspect-ratio-css-gradients-aspect-ratio.png\" /></p>\n<p> Setting an <code>aspect-ratio</code> results in the ratio being maintained as the elements grow or shrink, whereas when only setting <code>object-fit</code> and <code>height</code> the image ratio will constantly be in flux as the container dimensions change.</p>\n<h3>Adding Responsive Effects With CSS Gradients And Functions</h3>\n<p>OK, now that we know how to setup consistently sized images, let’s have some fun with them by adding a gradient effect!</p>\n<p>Our goal with this effect is to make it appear as though the image is fading into the card content. You may be tempted to wrap the image in its own container to add the gradient, but thanks to the work we’ve already done on the image sizing, we can work out how to safely do it on the main <code>.card</code>.</p>\n<p>The first step is to <strong>define a gradient</strong>. We’re going to use a CSS custom property to add in the gradient colors to enable easily swapping the gradient effect, starting with a blue to pink. The last color in the gradient will always be white to maintain the transition into the card content background and create the “feathered” edge.</p>\n<pre><code>.card {\n  --card-gradient: #5E9AD9, #E271AD;\n\n  background-image: linear-gradient(\n    var(--card-gradient),\n    white max(9.5rem, 27vh)\n  );\n  /* ...existing styles */\n}\n</code></pre>\n\n<p>But wait — is that a CSS <code>max()</code> function? In a gradient? Yes, it’s possible, and it’s the magic that makes this gradient effective responsively!</p>\n<p>However, if I were to add a screenshot, we wouldn’t actually see the gradient having any effect on the image yet. For that, we need to bring in the <code>mix-blend-mode</code> property, and in this scenario we’ll use the <code>overlay</code> value:</p>\n<pre><code>img {\n  /* ...existing styles */\n  mix-blend-mode: overlay;\n}\n</code></pre>\n\n<p>The <code>mix-blend-mode</code> property is similar to applying the layer blending styles available in photo manipulation software like Photoshop. And the <code>overlay</code> value will have the effect of allowing the <strong>medium tones</strong> in the image to <em>blend</em> with the gradient behind it, leading to the following result:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/160bb074-97fa-4675-bdb1-3812da69d9de/gradient-overlay-css-gradients-aspect-ratio.png\" /></p>\n<p>Now, at this point, we are relying on the <code>aspect-ratio</code> value alone to resize the image. And if we <strong>resize the container</strong> and cause the card layout to reflow, the changing image height causes inconsistencies in where the gradient fades to white.</p>\n<p>So we’ll add a <code>max-height</code> property as well that <em>also</em> uses the <code>max()</code> function and contains values slightly greater than the ones in the gradient. The resulting behavior is that the gradient will (almost always) correctly line up with the bottom of the image.</p>\n<pre><code>img {\n  /* ...existing styles */\n  max-height: max(10rem, 30vh);\n}\n</code></pre>\n\n\n<p> It’s important to note that adding a <code>max-height</code> alters the <code>aspect-ratio</code> behavior. Instead of always using the exact ratio, it will be used only when there’s enough allotted space given the new extra constraint of the <code>max-height</code>.</p>\n<p>However, <code>aspect-ratio</code> will still continue to ensure the images resize consistently as was the benefit over only <code>object-fit</code>. Try commenting out <code>aspect-ratio</code> in the final CodePen demo to see the difference it’s making across container sizes.</p>\n<p>Since our original goal was to enable consistently <strong>responsive image dimensions</strong>, we’ve still hit the mark. For your own use case, you may need to fiddle with the ratio and height values to achieve your desired effect.</p>\n<h4>Alternate: <code>mix-blend-mode</code> And Adding A Filter</h4>\n<p>Using <code>overlay</code> as the <code>mix-blend-mode</code> value was the best choice for the fade-to-white effect we were looking for, but let’s try an alternate option for a more dramatic effect.</p>\n<p>We’re going to update our solution to add a CSS custom property for the <code>mix-blend-mode</code> value and also update the color values for the gradient:</p>\n<pre><code>.card {\n  --card-gradient: tomato, orange;\n  --card-blend-mode: multiply;\n}\n\nimg {\n  /* ...existing styles */\n  mix-blend-mode: var(--card-blend-mode);\n}\n</code></pre>\n\n<p>The <code>multiply</code> value has a darkening effect on mid-tones, but keeps white and black as is, resulting in the following appearance:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2d6754f8-c8f0-4ec9-9dd0-b96d91d030dd/gradient-multiply-css-gradients-aspect-ratio.png\" /></p>\n<p>While we’ve lost the fade and now have a hard edge on the bottom of the image, the white part of our gradient is still important to ensure that the gradient ends prior to the card content.</p>\n<p>One <strong>additional modification</strong> we can add is the use of <code>filter</code> and, in particular, use the <code>grayscale()</code> function to remove the image colors and therefore have the gradient be the only source of image coloring.</p>\n<pre><code>img {\n  /* ...existing styles */\n  filter: grayscale(100);\n}\n</code></pre>\n\n<p>Using the value of <code>grayscale(100)</code> results in complete removal of the image’s natural colors and transforming it into black and white. Here’s the update for comparison with the previous screenshot of its effect when using our orange gradient with <code>multiply</code>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0197568f-fcce-4f90-bba7-08c81b367e4a/gradient-filter-css-gradients-aspect-ratio.png\" /></p>\n<h3>Use <code>aspect-ratio</code> As A Progressive Enhancement</h3>\n<p>As previously mentioned, currently <code>aspect-ratio</code> is only supported in the latest version of Chromium browsers (Chrome and Edge). However, all browsers support <code>object-fit</code> and that along with our <code>height</code> constraints results in a less-ideal but still acceptable result, seen here for Safari:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/17d605db-80bf-44f0-a763-2d2a29b3d077/safari-support-css-gradients-aspect-ratio.png\" /></p>\n<p>Without <code>aspect-ratio</code> functioning, the result here is that ultimately the image height is capped but the <strong>natural dimensions</strong> of each image still lead to some variance between card image heights. You may want to instead change to adding a <code>max-height</code> or make use of the <code>max()</code> function again to help make a <code>max-height</code> more responsive across varying card sizes.</p>\n<h3>Extending The Gradient Effects</h3>\n<p>Since we defined the gradient color stops as a CSS custom property, we have ready access to change them under different contexts. For example, we might change the gradient to more strongly feature one of the colors if the card is hovered or has one of its children in focus.</p>\n<p>First, we’ll update each card <code>h3</code> to contain a link, such as:</p>\n<pre><code>&lt;h3&gt;&lt;a href=\"\"&gt;A Super Wonderful Headline&lt;/a&gt;&lt;/h3&gt;\n</code></pre>\n\n<p>Then, we can use one of our newest available selectors — <code>:focus-within</code> — to alter the card gradient when the link is in focus. For <strong>extra coverage</strong> of possible interactions, we’ll couple this with <code>:hover</code>. And, we’ll reuse our <code>max()</code> idea to assign a single color to take over coverage of the image portion of the card. The downside to this particular effect is that gradient stops and color changes aren’t reliably animateable — but they will be soon thanks to <a href=\"https://css-houdini.rocks/animating-gradient/\">CSS Houdini</a>.</p>\n<p>To update the color and add the new color stop, we just need to re-assign the value of <code>--card-gradient</code> within this new rule:</p>\n<pre><code>.card:focus-within,\n.card:hover {\n  --card-gradient: #24a9d5 max(8.5rem, 20vh);\n}\n</code></pre>\n\n<p>Our <code>max()</code> values are less than the original in use for <code>white</code> to maintain the feathered edge. If we used the same values, it would meet the <code>white</code> and create a clearly straightedge separation.</p>\n<p>In creating this demo, I originally tried an effect that used <code>transform</code> with <code>scale</code> for a zoom-in effect. But I discovered that due to <code>mix-blend-mode</code> being applied, the browser would not consistently repaint the image which caused an unpleasant flickering. There will always be trade-offs in requesting the browser perform CSS-only effects and animations, and while it’s very cool what we <em>can</em> do, it’s always best to <strong>check the performance impact</strong> of your effects.</p>\n<h3>Have Fun Experimenting!</h3>\n<p>Modern CSS has given us some awesome tools for updating our web design toolkits, with <code>aspect-ratio</code> being the latest addition. So go forth, and experiment with <code>object-fit</code>, <code>aspect-ratio</code>, and adding functions like <code>max()</code> into your gradients for some fun responsive effects! Just be sure to double-check things cross-browser (for now!) and across varying viewports and container sizes.</p>\n<p>Here is the CodePen including the features and effects we reviewed today:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/WNoERXo\">Responsive Image Effects with CSS Gradients and aspect-ratio</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<p><em>Looking for more? Make sure you <a href=\"https://www.smashingmagazine.com/guides/css-layout/\">check out our CSS Guide</a> here on Smashing →</em></p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f7ddad498fe0b935f18b647e9a3f439c6cfc7ac861fae2862e0c4c1ee8f92588","category":"Tech"}