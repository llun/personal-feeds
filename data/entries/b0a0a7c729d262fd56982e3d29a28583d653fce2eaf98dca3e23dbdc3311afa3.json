{"title":"Things you don’t know about Protocol Buffers","link":"https://blog.whs.in.th/node/3484","date":1597338138000,"content":"<p>ช่วงนี้นั่งงม Protocol Buffers ลึกๆ แล้วพบว่า documentation มันไม่ค่อยมีเขียนเท่าไร หลายๆ คนก็คงน่าจะเคยใช้อย่างมากก็ gRPC เลยอยากมาเล่าให้ฟังหน่อยว่า Protobuf ทำอะไรได้อีกบ้าง</p>\n\n\n\n<p>บทความนี้จะพูดถึงเฉพาะ Protobuf 3 เท่านั้น ส่วน 2 ผมไม่ได้ใช้นานแล้ว</p>\n\n\n\n<div class=\"wp-block-jetpack-markdown\"><h2>REST API</h2>\n<p>ลองทำ API แล้วคืนเป็น Protobuf ดู พบว่าทำงานง่ายขึ้นมาก</p>\n<ul>\n<li>Protobuf มี schema ชัดเจน และ validate มาแล้ว ไม่ต้องนั่งเขียน JSON Schema บน Swagger อีกรอบ (ตรงไม่ตรงก็ไม่รู้อีกต่างหาก)</li>\n<li>ไม่เสียเวลาเขียน struct หรือ type definition มา parse บน client side ใช้ codegen ออกมาจาก proto definition ได้เลย</li>\n<li>ยังใช้ Django + Django REST Framework Serializer ได้อยู่</li>\n</ul>\n<p>แต่ข้อเสียคือ</p>\n<ul>\n<li>HTTP Library ส่วนมาก parse JSON จาก response ได้เลย พอเป็น Protobuf แล้วต้องเขียน logic ในการ parse เอง</li>\n<li>บน JavaScript frontend ถ้าใช้ Protobuf API ต้อง ship parser ไปด้วยทำให้เปลือง bundle size</li>\n</ul>\n<h2>JSON</h2>\n<p>จากข้อข้างบน ถ้าอยากจะ ship Protobuf แต่ไม่อยากเปลือง bundle size วิธีหนึ่งที่ทำได้คือ Protobuf จะมี <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON representation</a> เราก็อาจจะให้รับส่งเป็น JSON แทนได้</p>\n<p>วิธีนี้คิดว่าได้ข้อดีข้างบนมาหมดทุกข้อเลย</p>\n<p>วิธี encode protobuf เป็น JSON อย่า parse ออกมาแล้วโยนใส่ JSON encoder ปกติ แต่ Protobuf จะมี function ให้ เช่น <a href=\"https://googleapis.dev/python/protobuf/latest/google/protobuf/json_format.html#google.protobuf.json_format.MessageToJson\">google.protobuf.json_format.MessageToJson</a> ใน Python หรือ <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/encoding/protojson?tab=doc#Marshal\">google.golang.org/protobuf/encoding/protojson.Marshal</a> ใน Go เวลาถอดรหัสก็ต้องใช้ function ของ protobuf เช่นกัน</p>\n<p>JSON encoding ของ Protobuf จะไม่เหมือนกับ data structure ตรงๆ นิดนึงคือ</p>\n<ul>\n<li>Key จะกลายเป็น lowerCamelCase เสมอ เช่น field ชื่อ <code>user_name</code> จะกลายเป็น <code>userName</code></li>\n<li>ถ้าไม่ได้แก้ settings อะไร default value ของแต่ละ field จะหายไป เช่นถ้ามี field <code>string username = 1;</code> อยู่มีค่าเป็น string เปล่า มันจะไม่ออกมาใน JSON (ถ้าอยากให้ parse สะดวกอาจจะต้องแก้ config ให้มันส่งออกมาด้วย)</li>\n<li>enum จะแสดงเป็นชื่อ enum field แต่จะแก้ settings ให้ส่งเป็นตัวเลขแทนก็ได้ (default value ของ enum คือ member ตัวแรก)</li>\n<li>bytes กลายเป็น base64 string</li>\n</ul>\n<p><strong>Fun fact:</strong> เวลาแปลง protobuf เป็น JSON ใน Go ไม่ได้ใช้ encoding/json แต่มันจะ build string ออกมาเลย (แต่ตอนถอดกลับใช้ยัง encoding/json นะ)</p>\n<h2>Null value</h2>\n<p>จากข้อข้างบนอาจจะสงสัยว่าทำไม default value ไม่ถูก encode ออกมา</p>\n<p>คำตอบคือ Protobuf ไม่มี null value และนี่น่าจะเป็นสิ่งที่ผมพลาดเยอะที่สุด</p>\n<p>กรณีที่เราเซต field ใดๆ เป็น null นั้น protobuf จะถือว่าใช้ default value ของ field นั้นๆ ได้แก่</p>\n<ul>\n<li>string คือ string เปล่า</li>\n<li>bool คือ false</li>\n<li>ตัวเลขต่างๆ คือ 0</li>\n<li>enum คือ สมาชิกตัวแรกของ enum</li>\n<li>repeated คือ empty list</li>\n<li>เฉพาะ field ที่มี type เป็น message เท่านั้นจะมี null value ได้</li>\n</ul>\n<p>ที่เป็นแบบนี้เพราะ Protobuf จะไม่ encode field ที่มีค่าเป็น default ส่งไป</p>\n<h2>Well Known Type</h2>\n<p>Docs Protobuf เอา <a href=\"https://developers.google.com/protocol-buffers/docs/reference/google.protobuf\">WKT</a> ไปแอบลึกมากจนอาจจะไม่เคยรู้เลยว่ามีสิ่งนี้ด้วย</p>\n<p>Well known type คือ message ต่างๆ ที่ติดมากับ Protobuf ได้แก่</p>\n<ul>\n<li><strong>google.protobuf.Duration</strong> เก็บระยะเวลา</li>\n<li><strong>google.protobuf.Timestamp</strong> เก็บเวลา</li>\n<li><strong>google.protobuf.Empty</strong> ไม่เก็บอะไรเลย</li>\n</ul>\n<p>ดังนั้นเวลาจะ encode เวลาควรจะใช้ WKT เสมอ เนื่องจากว่าใน library ภาษาต่างๆ มักจะมี function ที่ถอดรหัสเข้าออกเป็น native value ของภาษานั้นๆ ให้อยู่แล้ว เช่น <a href=\"https://googleapis.dev/python/protobuf/latest/google/protobuf/timestamp_pb2.html#google.protobuf.timestamp_pb2.Timestamp.ToDatetime\">ToDatetime</a> ใน Python หรือ <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/types/known/timestamppb?tab=doc#Timestamp.AsTime\">AsTime</a> ใน Go วิธีนี้ทำให้เราไม่ต้องนั่งจำว่า time บน service นี้ encode เป็นอะไร (ISO8601? POSIX? Custom format?)</p>\n<p>เวลาใช้ WKT ต้อง import มาจาก <code>google/protobuf/timestamp.proto</code> (หรือไฟล์อื่นๆ ตามที่จะใช้) ซึ่งไม่มี document ไว้&#8230;</p>\n<h2>Wrapped type</h2>\n<p>จากข้อข้างบนเราบอกว่า Protobuf ไม่มี null value แต่ message เป็น null ได้ ดังนั้นถ้าอยากจะส่ง nullable เราก็แค่ยก field นั้นไปทำเป็น message ใหม่แล้วเซตเป็น null</p>\n<p>ซึ่ง Protobuf ก็คิดมาแล้ว ใน WKT จะมี type ต่างๆ ที่ครอบมาให้แล้ว</p>\n<ul>\n<li><strong>google.protobuf.BoolValue</strong></li>\n<li><strong>google.protobuf.BytesValue</strong></li>\n<li><strong>google.protobuf.DoubleValue</strong></li>\n<li><strong>google.protobuf.FloatValue</strong></li>\n<li><strong>google.protobuf.Int32Value</strong></li>\n<li><strong>google.protobuf.Int64Value</strong></li>\n<li><strong>google.protobuf.StringValue</strong></li>\n<li><strong>google.protobuf.UInt32Value</strong></li>\n<li><strong>google.protobuf.UInt64Value</strong></li>\n</ul>\n<p>ทั้งหมดจะมี field เดียวคือ <code>value</code> และเมื่อ encode เป็น JSON แล้วมันจะหายไปกลายเป็นค่าที่เก็บไว้ตรงๆ (นี่แหละที่ถ้าทำ type เองจะทำไม่ได้)</p>\n<h2>FileDescriptorSet</h2>\n<p>เวลาใช้งาน protobuf เราจะใช้ protoc เพื่อทำ code generation ซึ่งต้องลง protoc-gen-* ตามภาษาที่ใช้งานด้วย</p>\n<p>แล้ว protoc generate อะไรได้มั้ย?</p>\n<p>คำตอบคือมัน generate FileDescriptorSet ได้</p>\n<p>FileDescriptorSet เป็น well known type อันนึง มันคือการ .proto ให้เป็น protobuf แถมเราสามารถบอกให้ protoc include ไฟล์ทั้งหมดที่เรา include ต่อๆ กันมาได้ด้วย ทำให้ FileDescriptorSet นั้นจบในตัว</p>\n<p>FileDescriptorSet นี้ไม่อยู่ใน protobuf documentation ด้วยนะ!!</p>\n<h2>Any</h2>\n<p>WKT อีก type หนึ่งที่น่าสนใจคือ Any ซึ่งน่าเสียดายที่ถึงมันจะอยู่ใน documentation แต่ library ต่างๆ ยังไม่พร้อมใช้เท่าไรนัก</p>\n<p>Any ใช้เก็บ message อะไรก็ได้ โดยมันจะมี 2 field คือ</p>\n<ul>\n<li>type_url เก็บ URL ของ type นั้น เช่น type.googleapis.com/com.mycompany.TypeName</li>\n<li>value เป็น bytes คือข้อมูลที่ต้องการเก็บ encode เป็น protobuf</li>\n</ul>\n<p>เวลา decode แล้ว library ที่รองรับจะสามารถอ่าน type ต้นฉบับได้เลยโดยไม่ต้อง decode เอง นอกไปจากนี้จะสังเกตว่า type_url นั้นเป็น URL เวลาเจอ type แปลกประหลาด <a href=\"https://github.com/protocolbuffers/protobuf/blob/389bd06d0a637d3fd1aded7de59a12ed8f83baad/src/google/protobuf/any.proto#L135\">Protobuf client library จะเข้าไปใน URL นั้นเพื่อโหลด type definition ให้อัตโนมัติ</a> ซึ่งฟีเจอร์นี้โม้ไว้เฉยๆ ยังไม่ได้ทำ</p>\n<p>เวลา encode Any เป็น JSON มันจะกลายเป็น <code>{&quot;@type&quot;: &quot;type.googleapis.com/com.mycompany.TypeName&quot;}</code> แล้วเอาค่าใน value ที่เก็บไว้เข้ามา merge เลยไม่ได้ทำเป็น field ย่อย ใครที่ใช้ Stackdriver Logging น่าจะเห็น output ที่มี <code>@type</code> field บ่อย</p>\n<p>จากด้านบน ถ้าเราทำ message ที่มี Any กับ FileDescriptorSet ฝังรวมกันเราจะได้ <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#self-description\">Self describing message</a> แต่ปัจจุบันเนื่องจาก library ไม่รองรับกันเท่าไรจึง decode ยากมากๆ บางภาษาอาจจะ decode แล้วพังเลย</p>\n<h2>Reflection</h2>\n<p>แล้ว FileDescriptorSet ทำอะไรได้อีก? Protobuf ในบางภาษาจะมี reflection API ทำให้เราสามารถ create Protobuf message ได้ใน runtime (ภาษา dynamic เช่น JavaScript อาจจะไม่ต้องรองรับเพราะไม่ต้องใช้ codegen) เช่น <a href=\"https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/types/dynamicpb?tab=doc#Message\">dynamicpb</a></p>\n<h2>Lots of potential</h2>\n<p>เขียนมาทั้งหมดนี้แล้วจะเห็นธีมคล้ายๆ กันว่าถึง Protobuf จะออกมา 12 ปีแล้ว และ Proto3 ออกมา 4 ปีแล้วแต่ Protobuf ยังดูมี potential อีกมากที่ยังพัฒนาไม่เสร็จ</p>\n</div>\n\n\n\n<p></p>","author":"whs","siteTitle":"Quietly Verbose","siteHash":"5f972a6fe70a917eb1b1aa165b3cb2be8a9465af33ab38bf05f34c55c0e40587","entryHash":"b0a0a7c729d262fd56982e3d29a28583d653fce2eaf98dca3e23dbdc3311afa3","category":"Thai"}