{"title":"[LoRa] ตั้งค่า LoRa Server Project เพื่อทำ Private LoRaWAN ครับ (ภาคต่อ)","link":"https://thanapon.info/lora-private-lorawan/","date":1563129570000,"content":"<p>อ้างอิงจากบทความ <a href=\"http://thanapon.info/?p=375\" data-type=\"post\" data-id=\"375\">[LoRa] สร้าง Private LoRaWAN ด้วย LoRa Server Project บน Raspberry Pi 3</a> ผมได้ค้างเรื่องการตั้งค่า LoRa Server Project ไว้ ซึ่งบทความนี้จะแนะนำการตั้งค่า LoRa Server Project เพื่อสร้าง Private LoRaWAN กันครับ</p>\n\n\n\n<h2 id=\"2ca9\">Requirement:</h2>\n\n\n\n<ul><li>Raspberry Pi 3 + Single Channel Packet Forwarding + LoRa Server Project</li><li>Arduino Promini + RFM95w</li><li>USB to Serial</li></ul>\n\n\n\n<h2 id=\"7633\">เริ่มกันเลยละกันครับจะได้ไม่เสียเวลาาา!!!!!</h2>\n\n\n\n<ul><li>Login เข้าไปยัง LoRa App Server ซึ่ง URL ที่ใช้จะเป็น IP Address ของ Raspberry Pi แล้วตามด้วย Port: 8080 เช่น <em>http://192.168.2.10:8080</em> โดยใช้ Username/Password: <strong>admin/admin</strong></li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1912/1*-hB7tVbxQvSP_AbQCmJ9LQ.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1920/1*Hdin3n6eD9hIWSDDkJGQ8Q.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<ul><li>หลังจาก Login เสร็จเรียบร้อยเราจะเข้าไปยังหน้าจัดการ LoRaServer ซึ่งจากตัวอย่างผมได้ทำการสร้าง Application สำหรับทำการทดสอบแล้วนะก็ไม่ต้องสนใจครับ เข้ามายังเรื่องของเราต่อหลังจากนั้นให้ทำเลือก <strong>Network-server</strong> เพื่อทำการ Server สำหรับ LoRaWAN นะครับ แล้วทำการกด <strong>ADD</strong></li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/328/1*OHZViinwG-__-Gr1aGTU9w.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1526/1*w17cB1DnVolGmJHIjrsxzQ.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<ul><li>จากนั้นเราจะเข้ามายังหน้าเพิ่ม Network-Server ซึ่ง parameter ที่เราจะต้องกำหนดจะมีอยู่ 2 อย่างคือ<br>&#8211; Network-server name คือชื่อ Network-server ที่เราจะใช้เรียกเป็นชื่ออะไรก็ได้ครับ<br>&#8211; Network-server server คือ Network-server API ที่เราได้จากการติดตั้ง LoRa Server นั้นเองครับ โดยค่า default คือ <strong>localhost:8000</strong></li><li>หลังจากนั้น <strong>Add Network-Server</strong> ได้เลยครับ</li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1913/1*VRvsYE1ZEhADVRUWfomCUQ.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<ul><li>ทำการเพิ่ม <strong>Service-profiles </strong>โดยจะมี parameter ที่เราจะต้องกำหนดคือ<br>&#8211; <strong>Service-profile name</strong><br>&#8211; <strong>Network-Server</strong> (มาจากการเพิ่ม Network-server จากขั้นตอนก่อนหน้านี้)<br>หลังจากนั้นก็ทำการ create service-profile ได้เลยครับ</li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/327/1*Dsx4j_m3CuDrVkQg7rd-AA.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1530/1*GDMOwvCsLBmHJVHgfq3DnA.png\" alt=\"Image for post\"/></figure>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1877/1*thbLsTksZLISXO1xVd0XSg.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<ul><li>ขั้นตอนต่อไปทำการสร้าง Device-profiles ซึ่งเราจะต้องกำหนด parameter คือ<br>&#8211; Device-profile name<br>&#8211; Network-server<br>&#8211; LoRaWAN MAC version<br>&#8211; LoRaWAN Regional Parameters revision<br><strong>*** เนื่องจากโปรเจคนี้ผมได้ Library Arduino-LMIC ดังนั้นผมต้องกำหนด LoRaWAN MAC version: 1.0.2, LoRaWAN Regional Parameters revision: A ส่วนการ Authentication นั้นผมใช้แบบ ABP ใน tab JOIN(OTAA/ABP) ก็ไม่ต้องเลือก Device support OTTA ครับเสร็จแล้วก็ Create Device-profile ได้เลยครับ</strong></li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/324/1*jNX3lrwsQsgysnbnbC_5kg.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1522/1*Bzf4cnM64R68sNshjz-gNQ.png\" alt=\"Image for post\"/></figure>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1879/1*vPxdVL0P_H_qi3cjJpCUvA.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1055/1*DWgWY2Cgf98Oh7yAxWE0Ug.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>จากนั้นก็มาสร้าง Gateway กันครับโดยให้เรากำหนด Gateway-name, Gateway-description, Gateway ID และ Network-Server เรียบร้อยแล้วกด Create Gateway ได้เลยครับ<br><strong>***Gateway ID ได้มาจาก Device ID ที่เราทำการสร้าง Single Channel Gateway นะครับ</strong></li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/330/1*aCI7AxZ4DfIOsYy-f_DUqA.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1518/1*SRNw1Wvq5tENH5dcAHemEQ.png\" alt=\"Image for post\"/></figure>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/1875/1*7y6_QyNQQR8oBCa_NdEQiw.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1532/1*DmIoeziKKU63INExDzHDRA.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>จากนั้นทำการสร้าง Application สำหรับทดสอบการทำงาน LoRaServer กัน</li></ul>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://miro.medium.com/max/329/1*6Q_aynGQqMk-nNUa_Nq2Ug.png\" alt=\"Image for post\"/></figure></div>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1523/1*UsYP8x3BlRZ6zrFVnuGg2g.png\" alt=\"Image for post\"/></figure>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1890/1*3jBTLo3YXUQPP4g4cVitDg.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>ขั้นตอนต่อไปเมื่อเราได้ Application มาแล้วให้เข้าไปสร้าง device ที่จะเชื่อมต่อเข้ากับ LoRa Network ของเราโดยกดเข้าไปที่ชื่อของ Application ได้เลยครับ</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1535/1*xy5iKymnRSbNro3AmUq5VQ.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>เราก็จะอยู่ในหน้า Application-PrivateLoRaWAN จากนั้นเลือก Create เพื่อสร้าง Device ของเรา</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1534/1*4KNUR9wrDymGnLSedScH2A.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>กำหนด Device name, Device Description,Device EUI และ Device-profile<br>***Device EUI สามารถให้ระบบ generate ได้ครับส่วน Disable frame-counter validation สามารถติ๊กเลือกได้ครับ เพราะมันคือการ ignore frame-counter ทำให้สามารถส่งข้อมูลได้รัวๆ ถึงแม้ตัว End-Device เราจะ reset แล้วเริ่มนับ frame-counter ใหม่ ซึ่งหลังจากที่ End-Device reset ตัว frame-counter ของระบบจะเท่ากับ 0 ด้วย</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1533/1*m5dhTukFwC4ud4lAnt99PA.png\" alt=\"Image for post\"/></figure>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1556/1*bSj_QKFhCuDy7cFhZ7nywQ.png\" alt=\"Image for post\"/></figure>\n\n\n\n<ul><li>เสร็จแล้วเลือก tab Activation เพื่อนำข้อมูล Device Address, Network Session key และ Application Session key ไปใช้ในการกำหนด Authentication แบบ ABP ในฝั่งของ End-Device<br>***หากใครไม่มีข้อมูลสามารถให้ระบบ generate data ออกมาได้เลยครับ เสร็จแล้วอย่าลืมกด <strong>(Re)Activate Device</strong> ด้วยนะครับ</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/1535/1*6w-rJonPxk4PaxDjWBIfZA.png\" alt=\"Image for post\"/></figure>\n\n\n\n<h2 id=\"2076\">End-Device Section</h2>\n\n\n\n<ul><li>คัดลอกโค๊ดด้านล่างนี้ไปแปะลงใน ArduinoIDE ได้เลย โดยให้เปลี่ยน <strong>DEVADDR, NWKSKEY</strong> และ <strong>APPSKEY</strong> ตามที่เราได้ตั้งไว้ในขั้นตอนก่อนหน้านี้นะครับ</li></ul>\n\n\n\n<div class=\"hcb_wrap\"><pre class=\"prism line-numbers lang-cpp\" data-lang=\"C++\"><code>#include &lt;lmic.h&gt;\n#include &lt;hal/hal.h&gt;\n#include &lt;SPI.h&gt;\n\n// LoRaWAN NwkSKey, network session key\n// This is the default Semtech key, which is used by the early prototype TTN\n// network.\nstatic const u4_t DEVADDR = 0x018796ad;\n//Set network session key\nstatic const PROGMEM u1_t NWKSKEY[16] = { 0x5f, 0xe9, 0x61, 0x37, 0x4b, 0xe8, 0xaf, 0xb2, 0x1a, 0x7a, 0x44, 0xeb, 0x8d, 0xb5, 0xff, 0x07 };\n//Set app session key\nstatic const u1_t PROGMEM APPSKEY[16] = { 0x0a, 0x4c, 0x8d, 0xcc, 0x31, 0xf6, 0xe9, 0x89, 0xb0, 0x09, 0x97, 0xca, 0xfd, 0x2e, 0x05, 0x1b };\n\n// These callbacks are only used in over-the-air activation, so they are\n// left empty here (we cannot leave them out completely unless\n// DISABLE_JOIN is set in config.h, otherwise the linker will complain).\nvoid os_getArtEui (u1_t* buf) { }\nvoid os_getDevEui (u1_t* buf) { }\nvoid os_getDevKey (u1_t* buf) { }\n\nstatic osjob_t sendjob;\n\n// Schedule TX every this many seconds (might become longer due to duty\n// cycle limitations).\nconst unsigned TX_INTERVAL = 15;\n\n// Pin mapping\nconst lmic_pinmap lmic_pins = {\n  .nss = 10,\n  .rxtx = LMIC_UNUSED_PIN,\n  .rst = 6,\n  .dio = {2, 4, 5},\n};\n\nint channel = 0;\n\nvoid onEvent (ev_t ev) {\n  Serial.print(os_getTime());\n  Serial.print(&quot;: &quot;);\n  switch (ev) {\n    case EV_SCAN_TIMEOUT:\n      Serial.println(F(&quot;EV_SCAN_TIMEOUT&quot;));\n      break;\n    case EV_BEACON_FOUND:\n      Serial.println(F(&quot;EV_BEACON_FOUND&quot;));\n      break;\n    case EV_BEACON_MISSED:\n      Serial.println(F(&quot;EV_BEACON_MISSED&quot;));\n      break;\n    case EV_BEACON_TRACKED:\n      Serial.println(F(&quot;EV_BEACON_TRACKED&quot;));\n      break;\n    case EV_JOINING:\n      Serial.println(F(&quot;EV_JOINING&quot;));\n      break;\n    case EV_JOINED:\n      Serial.println(F(&quot;EV_JOINED&quot;));\n      break;\n    case EV_RFU1:\n      Serial.println(F(&quot;EV_RFU1&quot;));\n      break;\n    case EV_JOIN_FAILED:\n      Serial.println(F(&quot;EV_JOIN_FAILED&quot;));\n      break;\n    case EV_REJOIN_FAILED:\n      Serial.println(F(&quot;EV_REJOIN_FAILED&quot;));\n      break;\n    case EV_TXCOMPLETE:\n      Serial.println(F(&quot;EV_TXCOMPLETE (includes waiting for RX windows)&quot;));\n      if (LMIC.txrxFlags & TXRX_ACK)\n        Serial.println(F(&quot;Received ack&quot;));\n      if (LMIC.dataLen) {\n        Serial.println(F(&quot;Received &quot;));\n        Serial.println(LMIC.dataLen);\n        Serial.println(F(&quot; bytes of payload&quot;));\n      }\n      // Schedule next transmission\n      os_setTimedCallback(&sendjob, os_getTime() + sec2osticks(TX_INTERVAL), do_send);\n      break;\n    case EV_LOST_TSYNC:\n      Serial.println(F(&quot;EV_LOST_TSYNC&quot;));\n      break;\n    case EV_RESET:\n      Serial.println(F(&quot;EV_RESET&quot;));\n      break;\n    case EV_RXCOMPLETE:\n      // data received in ping slot\n      Serial.println(F(&quot;EV_RXCOMPLETE&quot;));\n      break;\n    case EV_LINK_DEAD:\n      Serial.println(F(&quot;EV_LINK_DEAD&quot;));\n      break;\n    case EV_LINK_ALIVE:\n      Serial.println(F(&quot;EV_LINK_ALIVE&quot;));\n      break;\n    default:\n      Serial.println(F(&quot;Unknown event&quot;));\n      break;\n  }\n}\n\nvoid do_send(osjob_t* j) {\n  int temp = random(20, 30); //random Temperature Value\n  int hum = random(50, 70);  //random humidity Value\n  unsigned char buff[15];\n  dtostrf(temp, 5, 1, buff);\n  strcat(buff, &quot; &quot;);\n  dtostrf(hum, 5, 1, buff + strlen(buff));\n\n  // Check if there is not a current TX/RX job running\n  if (LMIC.opmode & OP_TXRXPEND) {\n    Serial.println(F(&quot;OP_TXRXPEND, not sending&quot;));\n  } else {\n    // Prepare upstream data transmission at the next possible time.\n    //    LMIC_setTxData2(1, mydata, sizeof(mydata) - 1, 0);\n    LMIC_setTxData2(1, buff, strlen(buff), 0);\n    Serial.println(F(&quot;Packet queued&quot;));\n    digitalWrite(9, HIGH);\n    delay(200);\n    digitalWrite(9, LOW);\n  }\n  // Next TX is scheduled after TX_COMPLETE event.\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(F(&quot;Starting&quot;));\n  pinMode(9, OUTPUT);\n\n#ifdef VCC_ENABLE\n  // For Pinoccio Scout boards\n  pinMode(VCC_ENABLE, OUTPUT);\n  digitalWrite(VCC_ENABLE, HIGH);\n  delay(1000);\n#endif\n\n  // LMIC init\n  os_init();\n  // Reset the MAC state. Session and pending data transfers will be discarded.\n  LMIC_reset();\n\n  // Set static session parameters. Instead of dynamically establishing a session\n  // by joining the network, precomputed session parameters are be provided.\n#ifdef PROGMEM\n  // On AVR, these values are stored in flash and only copied to RAM\n  // once. Copy them to a temporary buffer here, LMIC_setSession will\n  // copy them into a buffer of its own again.\n  uint8_t appskey[sizeof(APPSKEY)];\n  uint8_t nwkskey[sizeof(NWKSKEY)];\n  memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));\n  memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));\n  LMIC_setSession (0x1, DEVADDR, nwkskey, appskey);\n#else\n  // If not running an AVR with PROGMEM, just use the arrays directly\n  LMIC_setSession (0x1, DEVADDR, NWKSKEY, APPSKEY);\n#endif\n\n  LMIC_setupChannel(0, 923200000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);  // g-band\n  forceTxSingleChannelDr();\n  // Disable link check validation\n  LMIC_setLinkCheckMode(0);\n\n  // TTN uses SF9 for its RX2 window.\n  LMIC.dn2Dr = DR_SF9;\n\n  // Set data rate and transmit power for uplink (note: txpow seems to be ignored by the library)\n  LMIC_setDrTxpow(DR_SF7, 14);\n\n  // Start job\n  do_send(&sendjob);\n}\n\nvoid loop() {\n  os_runloop_once();\n}\n\n// Disables all channels, except for the one defined above, and sets the\n// data rate (SF). This only affects uplinks; for downlinks the default\n// channels or the configuration from the OTAA Join Accept are used.\n//\n// Not LoRaWAN compliant; FOR TESTING ONLY!\n//\nvoid forceTxSingleChannelDr() {\n  for (int i = 0; i &lt; 9; i++) { // For EU; for US use i&lt;71\n    if (i != channel) {\n      LMIC_disableChannel(i);\n    }\n  }\n  // Set data rate (SF) and transmit power for uplink\n  //  LMIC_setDrTxpow(dr, 14);\n}</code></pre></div>\n\n\n\n<ul><li>หลังจากนั้นก็ทำการ Upload Sketch ไปยัง Arduino Board แล้วก็รอดูผลลัพธ์ได้เลยครับ โดยในฝั่งของ Arduino Board เราจะไม่รับ ACK กลับมาซึ่งจากโค๊ดข้างต้นผมได้กดหนดให้ส่ง interval ทุกๆ 15 วินาทีครับ <strong><em>ย้ำเพื่อทดสอบนะครับถ้าจะใช้งานจริง เราต้องคำนวณ duty cycle ของ LoRa ใหม่นะครับ</em></strong></li></ul>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>เท่านี้เราก็มี Private LoRa Server ไว้ใช้กันแล้วครับ สำหรับวันนี้ขอบคุณและสวัสดีครับ <img src=\"https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png\" alt=\"🙂\" class=\"wp-smiley\" style=\"height: 1em; max-height: 1em;\" /></p></blockquote>\n<p>The post <a rel=\"nofollow\" href=\"https://thanapon.info/lora-private-lorawan/\">[LoRa] ตั้งค่า LoRa Server Project เพื่อทำ Private LoRaWAN ครับ (ภาคต่อ)</a> appeared first on <a rel=\"nofollow\" href=\"https://thanapon.info\">Thanapon</a>.</p>","author":"thanapon.tap","siteTitle":"Thanapon","siteHash":"6a039c2f54d76e4c49227d80968f2a30de5427cc57525c047c383ea3563cde5f","entryHash":"55cfc547c72ee4b700ac6d600b6d850337e84987b9a9e4691eaf4f85e875f94d","category":"Thai"}