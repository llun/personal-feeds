{"title":"Onboarding Applications to Vault Using Terraform: A Practical Guide","link":"https://www.hashicorp.com/blog/onboarding-applications-to-vault-using-terraform-a-practical-guide","date":1624982400000,"content":"<p>In our conversations with numerous customers, we’ve learned that HashiCorp Vault is usually brought into an organization for a single use case that mitigates one specific risk, but interest then spreads quickly. Soon, many more departments want to adopt Vault and implement it in a more systematic way using more features. At this point, a plan for scaling and automation is needed to onboard and service a myriad of applications and use cases. A manual approach is unsustainable and goes against the ethos of using Vault in the first place.</p>\n<p>At this stage, we recommend codifying Vault configurations and using <a href=\"https://www.hashicorp.com/resources/what-is-infrastructure-as-code\">infrastructure as code</a> to manage Vault. Key benefits of this approach include:</p>\n<ul>\n<li><strong>Repeatability:</strong> Infrastructure as code (IaC) allows for a predictable and consistent process for applying changes. Every configuration begins with code.</li>\n<li><strong>Version Control:</strong> Configuration codified in a version control system is the source of truth. Security policy and organizational standards can be enforced on IaC modules. All changes are tracked and inspected through a code review process.</li>\n<li><strong>Automated workflows:</strong> Properly implemented IaC practices enable GitOps or CI/CD driven workflows that do not require manual intervention. Changes and updates can be safely tested before applying to production.</li>\n</ul>\n<p>By taking this approach to Vault onboarding, companies usually see two major benefits:</p>\n<ol>\n<li>Increased productivity from automation</li>\n<li>Mitigation of risk by reducing human errors</li>\n</ol>\n<p>The benefits of using IaC are truly realized when you are able to onboard applications to Vault hundreds of times through a single, automated workflow. Many of our customers already do this.</p>\n<p>In this tutorial, I’ll walk through the typical patterns and best practices we share with customers for onboarding applications to Vault.</p>\n<h2><a href=\"#process-milestones\">»</a><a></a>Process Milestones</h2>\n<p>Here is a flow chart outlining the key milestones of the onboarding process:</p><img src=\"https://www.datocms-assets.com/2885/1624893783-vtf-onboarding-1.png\" /><p><em>The key stages of app onboarding onto Vault.</em></p>\n<p>To follow along with the demo, please install the following prerequisites if you haven’t already:</p>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\">Docker</a></li>\n<li><a href=\"https://docs.docker.com/compose/\">Docker Compose</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/terraform/install-cli\">Terraform CLI</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2/Getting-Started-Installing-Git\">Git</a></li>\n</ul>\n<h2><a href=\"#set-up-the-repository\">»</a><a></a>Set Up the Repository</h2>\n<p>Clone the repository as shown below and cd into the project directory.</p><pre><code>git clone git@github.com:hashicorp/vault-guides.git\ncd vault-guides/operations/onboarding</code></pre><p>Next,  <code>cd</code> into the <code>docker-compose</code> directory and run <code>docker compose up</code> as shown below. The remaining terminal snippets in this post will assume that you are in the project directory <code>vault-guides/operations/onboarding</code>.</p><pre><code>cd docker-compose/ &amp;&amp; docker compose up</code></pre><p>Optionally, if you prefer using the tool <code>make</code>, there is a Makefile included in the project directory root. Run <code>make info</code> to see the available targets.</p>\n<h2><a href=\"#bootstrap-vault\">»</a><a></a>Bootstrap Vault</h2>\n<p>This step involves initializing and unsealing Vault, creating Vault namespaces (for Vault Enterprise), and creating one or more administrators. In another terminal, use the following commands to initialize and unseal the Docker compose demo Vault instance.</p><pre><code># Assuming you are in the project root directory\ncd docker-compose/scripts\n00-init.sh\nexport VAULT_ADDR=http://localhost:8200\nexport VAULT_TOKEN=\nvault token lookup</code></pre><p>If you need to look up the root token again, it is stored in the file: <code>docker-compose/scripts/vault.txt</code>. If you are using an existing Vault cluster, please skip running <code>00-init.sh</code> and instead run <code>export VAULT_ADDR=&lt;Vault-server-domain&gt;</code> to point to your Vault server.</p>\n<p><strong>Admin token (optional):</strong> You may prefer using an admin token instead of root (for example if you’re using an existing cluster). If so, create an admin token using the <code>vault-admin.hcl</code> policy file shown below. This admin policy is authored based on the <a href=\"https://learn.hashicorp.com/tutorials/vault/policies#write-a-policy\">Vault Policies guide</a>.</p><pre><code># Assuming that VAULT_TOKEN is set with root or higher Admin token\nvault policy write learn-admin admin-policy.hcl\nvault token create -policy=learn-admin\nexport VAULT_TOKEN=\nvault token lookup</code></pre><h2><a href=\"#establish-a-naming-convention\">»</a><a></a>Establish a Naming Convention</h2>\n<p>Naming standards allow applications to login and read secrets from consistent and predictable paths. Each application should have a unique identifier and be part of a logical group such as a line of business (LOB), project, etc. Below are some typical paths to plan for, along with example values:</p>\n<ul>\n<li>Auth method mount path — e.g. <code>approle</code>, <code>k8s-us-east1</code></li>\n<li>Auth method role name — e.g. <code>LOB1-app100</code>, <code>nginx</code></li>\n<li>Secret engine mount path — e.g. <code>kv/LOB1</code>, <code>db/postgres-us-east1-prod</code></li>\n<li>Secret access path — e.g. <code>kv/LOB1/app100</code>, <code>kv/nginx</code></li>\n<li>Entity name — e.g. <code>LOB1-app100</code>, <code>nginx</code></li>\n</ul>\n<p>We recommend that you build this out for a representative use case in your organization. If using Vault Enterprise Namespaces, the paths listed above will be prepended by the Namespace name. For example, the secret access path for namespace <code>ns1</code> will be <code>ns1/kv/LOB1/app100</code> for the <a href=\"https://www.vaultproject.io/docs/secrets/kv/kv-v1\">Key/Value (KV) Secrets Engine (/kv) version 1</a>. For the <a href=\"https://www.vaultproject.io/docs/secrets/kv/kv-v2\">KV Secrets Engine version 2</a> (HashiCorp offers <a href=\"https://www.vaultproject.io/docs/secrets/kv\">two versions of the KV secrets engine</a>), the secrets are versioned and stored under /data, therefore the effective secret access path will be <code>ns1/kv/LOB1/data/app100</code>.</p>\n<h2><a href=\"#terraform-configurations\">»</a><a></a>Terraform Configurations</h2>\n<p>We will use HashiCorp Terraform to onboard an application named <code>nginx</code>. In the file <code>variables.tf</code>, we have declared an <code>entities</code> variable that will hold a list of applications. To onboard more applications, we just need to append them to this list. Run the following commands to create all of the configurations:</p><pre><code># Please ensure you have VAULT_ADDR and VAULT_TOKEN set\ncd terraform\nterraform init\nterraform plan\nterraform apply --auto-approve\n# Restart vault-agent container to render secrets immediately\ndocker restart vault-agent</code></pre><p>Access <a href=\"http://localhost:8080/\">http://localhost:8080</a> on your browser, and you should be able to see the <code>nginx</code> application display a dynamic PostgreSQL database credential provided by Vault as shown below. Also try accessing <a href=\"http://localhost:8080/kv.html\">http://localhost:8080/kv.html</a> to see example static secret values.</p><img src=\"https://www.datocms-assets.com/2885/1624893789-vtf-onboarding-2.png\" /><p><em>Example dynamic credential read.</em></p>\n<p>The Terraform configurations for this demo are described in more detail below along with the corresponding source file names:</p>\n<p><strong>Application entity —</strong> <code>entity.tf</code>: Pre-creating the application entity is optional but encouraged. It allows easier auditing and more flexibility in attaching ACL policies. Please log in to the Vault UI on <a href=\"http://localhost:8200/\">http://localhost:8200</a> with the root token, then click Access &gt; Entities to see two pre-created entities: <code>nginx</code> and <code>app100</code>. Clicking into these entities will display an alias for the AppRole authentication method and the mapped entity ACL policies.</p>\n<p><strong>Authentication method —</strong> <code>auth.tf</code>: This demo uses the <a href=\"https://www.vaultproject.io/docs/auth/approle\">AppRole auth method</a>, which is a type of “trusted orchestrator” <a href=\"https://learn.hashicorp.com/tutorials/vault/secure-introduction\">secure introduction pattern</a>. An authentication method alias links the entity to the AppRole role.</p>\n<p><strong>ACL policy —</strong> <code>entity.tf</code>: We recommend using templated policies to reduce the overhead of policy management. This demo uses two templated policies: <code>kv_rw_policy</code> for accessing key-value secrets, and <code>postgres_creds_policy</code> for accessing dynamic Postgres credentials. These elements are represented as a Terraform graph diagram snippet, shown below:</p><img src=\"https://www.datocms-assets.com/2885/1624893793-vtf-onboarding-3.png\" /><p><em>Terraform graph snippet for authentication, entity, and ACL policy.</em></p>\n<p>Both ACL policies above have rules based on the <code>{{identity.entity.name}}</code> parameter. For example, if the entity name is <code>nginx</code>, during runtime, the effective path will be: <code>kv/data/nginx/*</code> for the KV secrets engine, and <code>postgres/creds/nginx</code> for the database secrets engine (see <a href=\"https://learn.hashicorp.com/tutorials/vault/policy-templating#available-templating-parameters\">Templating Parameters</a> for more details).</p>\n<p><strong>Secrets Engine —</strong> <code>kv-v2.tf</code> and <code>database.tf</code>: The relevant secrets engine should be mounted and application specific roles should be created as part of onboarding. These are shown in a similar graph diagram as before:</p><img src=\"https://www.datocms-assets.com/2885/1624893806-vtf-onboarding-4.png\" /><p><em>Terraform graph snippet for secret engine mount and roles.</em></p>\n<h2><a href=\"#application-integration-with-vault\">»</a><a></a>Application Integration with Vault</h2>\n<p>Now that the Vault configurations are built, we need the application to log in to Vault using AppRole credentials and fetch a secret. The demo uses Vault Agent to achieve this (see <a href=\"https://learn.hashicorp.com/collections/vault/app-integration\">App Integration</a> for more patterns).</p><img src=\"https://www.datocms-assets.com/2885/1624893810-vtf-onboarding-5.png\" /><p><em>Vault Agent workflow.</em></p>\n<p>The file <code>nginx-vault-agent.hcl</code> specifies how to authenticate the nginx container using AppRole. It also links two template files, <code>kv.hcl</code> and <code>postgres.hcl</code>, that tell Vault Agent how to render secrets from a KV and Database Secrets Engine respectively.</p>\n<h2><a href=\"#onboarding-the-next-application\">»</a><a></a>Onboarding the Next Application</h2>\n<p>To onboard another application, simply add its name to the default value of the <code>entities</code> variable in <code>variables.tf</code> as shown below for <code>app200</code>.</p><pre><code># Snippet from variables.tf after adding app200\nvariable \"entities\" {\n    description = \"A set of vault clients to create\"\n    default = [\n        \"nginx\",\n        \"app100\",\n        \"app200\"\n    ]\n}</code></pre><p>Then run <code>terraform apply</code> to create the additional Vault configurations for this application:</p><pre><code># Ensure that VAULT_TOKEN was set from before\ncd terraform\nterraform apply --auto-approve</code></pre><p>Verify from the Vault UI that there is a new entity called <code>app200</code> with an alias to the AppRole auth method:</p><img src=\"https://www.datocms-assets.com/2885/1624893814-vtf-onboarding-6.png\" /><p><em>Vault screenshot showing a new <code>app200</code> entity being added.</em></p>\n<p>A new Role ID and Secret ID have also been created, which you can find by running the <code>terraform output</code> command. We can use this to test authentication and secret access as shown below. Note that the Role ID, Secret ID, and Vault token will be unique in your case.</p><pre><code># Get Approle creds\nterraform output role_ids | grep app200\n  \"app200\" = \"ff2795c9-7f42-4233-eace-075c28869199\"\nterraform output secret_ids | grep app200\n  \"app200\" = \"e76ed3e5-e2c5-fd9e-14f1-554b40674d54\"\n\n# Login using AppRole\nvault write auth/approle/login \\\n  role_id=ff2795c9-7f42-4233-eace-075c28869199 \\\n  secret_id=e76ed3e5-e2c5-fd9e-14f1-554b40674d54\n\nKey                     Value\n---                     -----\ntoken                   s.JGHR7HEc0I51kOvYSfR1SfGj\ntoken_accessor          RgOTOtM2InSfF8oz62tvOOZF\ntoken_duration          768h\ntoken_renewable         true\ntoken_policies          [\"default\" \"kv_rw_policy\" \"postgres_creds_policy\"]\nidentity_policies       [\"kv_rw_policy\" \"postgres_creds_policy\"]\npolicies                [\"default\" \"kv_rw_policy\" \"postgres_creds_policy\"]\ntoken_meta_role_name    app200\n\n# Read KV secret\nexport VAULT_TOKEN=s.JGHR7HEc0I51kOvYSfR1SfGj\nvault kv get kv/app200/static\n\n====== Metadata ======\nKey              Value\n---              -----\ncreated_time     2021-06-05T13:44:18.9141257Z\ndeletion_time    n/a\ndestroyed        false\nversion          1\n\n====== Data ======\nKey         Value\n---         -----\napp         app200\npassword    cheese\nusername    app200</code></pre><p>To de-board an application, simply remove the entity from the same variable and re-rerun <code>terraform apply</code>.</p>\n<h2><a href=\"#automating-the-workflow-using-terraform-cloud-enterprise\">»</a><a></a>Automating the Workflow Using Terraform Cloud/Enterprise</h2>\n<p>Although we used Terraform CLI commands for this demo, the overall approach should be automated via a CI/CD pipeline or GitOps workflow. Terraform Cloud and Terraform Enterprise support different types of runs that can be used for automation. Below is an example screenshot showing <code>app200</code> being added through a <a href=\"https://www.terraform.io/docs/cloud/run/ui.html\">VCS-driven run</a>.</p><img src=\"https://www.datocms-assets.com/2885/1624893818-vtf-onboarding-7.png\" /><p><em>Terraform Cloud  UI showing <code>app200</code> related resources being created.</em></p>\n<p>Using Terraform Cloud or Terraform Enterprise provides more than just a push-button way to automate Vault onboarding in your delivery pipeline, they also allow us to securely maintain all Terraform state file versions, along with many other benefits.</p>\n<h2><a href=\"#testing-and-promotion-using-terraform-modules\">»</a><a></a>Testing and Promotion Using Terraform Modules</h2>\n<p>Using an IaC approach allows us to apply configurations in non-production, perform testing, and then promote them to higher environments. This process can be simplified by encapsulating Vault configuration as modules for Terraform and publishing them in the <a href=\"https://www.terraform.io/docs/cloud/registry/index.html\">private module registry (PMR)</a>.</p><img src=\"https://www.datocms-assets.com/2885/1624893822-vtf-onboarding-8.png\" /><p><em>The workflow for testing and promoting a Terraform module for Vault.</em></p>\n<p>In the diagram above, we are onboarding the dynamic Google Cloud (GCP) credentials Secrets Engine use-case by expressing it in a <code>terraform-vault-secrets-gcp</code> module and testing it in staging first. This approach allows supported use cases to be developed, tested, and versioned independently — resulting in greater velocity and cleaner separation of concerns.</p>\n<h2><a href=\"#recap-and-more-resources\">»</a><a></a>Recap and More Resources</h2>\n<p>In this walkthrough, I reviewed how to create Vault configurations using a codified approach that is repeatable and can be easily automated. Using IaC as the source of truth also makes it easier to audit how Vault is being used. Additional best practices referenced in this article included using ACL Policy templates and pre-creating application entities.</p>\n<p>Please see the links below for more details on the best practices I covered. You can run <code>make clean</code>, <code>terraform destroy</code>, and <code>docker-compose down</code> to clean up demo configurations.</p>\n<ul>\n<li><a href=\"https://github.com/devops-adeel?tab=repositories&amp;q=terraform-vault-&amp;type=public&amp;language=hcl&amp;sort=\">Example Terraform-Vault modules</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/vault/pattern-policy-templates\">Recommended Pattern: Vault ACL policy templates</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/vault/codify-mgmt-enterprise?in=vault/operations\">Guide: Codify Vault Enterprise management using Terraform</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/secure-infrastructure-provisioning-with-terraform-cloud-vault-gitlab-ci\">Secure infrastructure provisioning using GitLab CI/CD</a></li>\n<li><a href=\"https://www.terraform.io/docs/providers/vault/index.html\">Terraform Vault Provider</a></li>\n</ul>","author":"Kawsar Kamal","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"a12fbcd5abf7dc5c7bb0cde15b8cfd36c5d2a6910ea66b4d095b3e342f126de5","category":"Tech"}