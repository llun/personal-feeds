{"title":"A Guide To Newly Supported, Modern CSS Pseudo-Class Selectors","link":"https://smashingmagazine.com/2021/04/guide-supported-modern-css-pseudo-class-selectors/","date":1619166600000,"content":"<p>Pseudo-class selectors are the ones that begin with the colon character “<code>:</code>” and match based on a <em>state</em> of the current element. The state may be relative to the document tree, or in response to a change of state such as <code>:hover</code> or <code>:checked</code>.</p>\n<h3><code>:any-link</code></h3>\n<p>Although <a href=\"https://drafts.csswg.org/selectors-4/#the-any-link-pseudo\">defined in Selectors Level 4</a>, this pseudo-class has had <a href=\"https://caniuse.com/css-any-link\">cross-browser support</a> for quite some time. The <code>any-link</code> pseudo-class will match an anchor hyperlink as long as it has a <code>href</code>. It will match in a way equivalent to matching both <code>:link</code> and <code>:visited</code> at once. Essentially, this may reduce your styles by one selector if you are adding basic properties such as <code>color</code> that you’d like to apply to all links regardless of their visited status.</p>\n<pre><code>:any-link {\n  color: blue;\n  text-underline-offset: 0.05em;\n}\n</code></pre>\n\n<p>An important note about specificity is that <code>:any-link</code> will win against <code>a</code> as a selector even if <code>a</code> is placed lower in the cascade since it has the specificity of a class. In the following example, the links will be purple:</p>\n<pre><code>:any-link {\n  color: purple;\n}\n\na {\n  color: red;\n}\n</code></pre>\n\n<p>So if you introduce <code>:any-link</code>, be aware that you will need to include it on instances of <code>a</code> as a selector if they will be in direct competition for specificity.</p>\n<h3><code>:focus-visible</code></h3>\n<p>I’d bet that one of the most common accessibility violations across the web is removing <code>outline</code> on interactive elements like links, buttons, and form inputs for their <code>:focus</code> state. One of the main purposes of that <code>outline</code> is to serve as a visual indicator for users who primarily use keyboards to navigate. <strong>A visible focus state is critical</strong> as a way-finding tool as those users tab across an interface and to help reinforce what is an interactive element. Specifically, the visible focus is covered in the <a href=\"https://www.w3.org/WAI/WCAG22/Understanding/focus-appearance-minimum.html\">WCAG Success Criterion 2.4.11: Focus Appearance (Minimum)</a>.</p>\n<p>The <code>:focus-visible</code> pseudo-class is intended to only show a focus ring when the user agent determines via heuristics that it should be visible. Put another way: <strong>browsers will determine</strong> when to apply <code>:focus-visible</code> based on things like input method, type of element, and context of the interaction. For testing purposes via a desktop computer with keyboard and mouse input, you should see <code>:focus-visible</code> styles attached when you tab into an interactive element but not when you click it, with the exception of text inputs and textareas which should show <code>:focus-visible</code> for all focus input types.</p>\n<p><strong>Note</strong>: <em>For more details, review <a href=\"https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo\">the working draft of the</a> <a href=\"https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo\"><code>:focus-visible</code> spec</a>.</em></p>\n<p>The latest versions of Firefox and Chromium browsers seem to now be handling <code>:focus-visible</code> on form inputs according to the spec which says that the UA should remove <code>:focus</code> styles when <code>:focus-visible</code> matches. Safari is not yet supporting <code>:focus-visible</code> so we need to ensure a <code>:focus</code> style is included as a fallback to avoid removing the <code>outline</code> for accessibility.</p>\n<p>Given a button and text input with the following set of styles, let’s see what happens:</p>\n<pre><code>input:focus,\nbutton:focus {\n  outline: 2px solid blue;\n  outline-offset: 0.25em;\n}\n\ninput:focus-visible {\n  outline: 2px solid transparent;\n  border-color: blue;\n}\n\nbutton:focus:not(:focus-visible) {\n  outline: none;\n}\n\nbutton:focus-visible {\n  outline: 2px solid transparent;\n  box-shadow: 0 0 0 2px #fff, 0 0 0 4px blue;\n}\n</code></pre>\n\n<h4>Chromium and Firefox</h4>\n<ul>\n<li><code>input</code><br />Correctly remove <code>:focus</code> styles when elements are focused via mouse input in favor of <code>:focus-visible</code> resulting in changing the <code>border-color</code> and hiding the <code>outline</code> on keyboard input</li>\n<li><code>button</code><br />Does not only use <code>:focus-visible</code> without the extra rule for <code>button:focus:not(:focus-visible)</code> that removes the outline on <code>:focus</code>, but will allow visibility of the <code>box-shadow</code> only on keyboard input</li>\n</ul>\n<h4>Safari</h4>\n<ul>\n<li><code>input</code><br />Continues using only the <code>:focus</code> styles</li>\n<li><code>button</code><br />This <em>seems</em> to now be partially respecting the intent of <code>:focus-visible</code> on the button by hiding the <code>:focus</code> styles on click, but still showing the <code>:focus</code> styles on keyboard interaction</li>\n</ul>\n<p>So for now, the recommendation would be to continue including <code>:focus</code> styles and then progressively enhance up to using <code>:focus-visible</code> which the demo code allows. Here’s a CodePen for you to continue testing with:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/MWJZbew\">Testing application of :focus-visible</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<h3><code>:focus-within</code></h3>\n<p>The <code>:focus-within</code> pseudo-class has support among all modern browsers, and acts <em>almost</em> like a parent selector but only for a very specific condition. When attached to a containing element and a child element matches for <code>:focus</code>, styles can be added to the containing element <em>and/or</em> any other elements within the container.</p>\n<p>A practical enhancement to use this behavior for is <strong>styling a form label</strong> when the associated input has focus. For this to work, we wrap the label and input in a container, and then attach <code>:focus-within</code> to that container as well as selecting the label:</p>\n<pre><code>.form-group:focus-within label {\n  color: blue;\n}\n</code></pre>\n\n<p>This results in the label turning blue when the input has focus.</p>\n<p>This CodePen demo also includes adding an outline directly to the <code>.form-group</code> container:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/xxgmREq\">Testing application of :focus-within</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<h3><code>:is()</code></h3>\n<p>Also known as the “matches any” pseudo-class, <code>:is()</code> can take a list of selectors to try to match against. For example, instead of listing heading styles individually, you can group them under the selector of <code>:is(h1, h2, h3)</code>.</p>\n<p>A couple of unique behaviors about the  <code>:is()</code>  selector list:</p>\n<ul>\n<li>If a listed selector is invalid, the rule will continue to match the valid selectors. Given <code>:is(-ua-invalid, article, p)</code> the rule will match <code>article</code> and <code>p</code>.</li>\n<li>The computed specificity will equal that of the passed selector with the highest specificity. For example,  <code>:is(#id, p)</code> will have the specificity of the <code>#id</code> — 1.0.0 — whereas <code>:is(p, a)</code> will have a specificity of 0.0.1.</li>\n</ul>\n<p>The first behavior of ignoring invalid selectors is a key benefit. When using other selectors in a group where one selector is invalid, the browser will throw out the whole rule. This comes into play for a few instances where vendor prefixes are still necessary, and grouping prefixed and non-prefixed selectors causes the rule to fail among all browsers. With <code>:is()</code> you can safely group those styles and they will apply when they match and be ignored when they don’t.</p>\n<p>To me, <strong>grouping heading styles</strong> as previously mentioned is already a big win with this selector. It’s also the type of rule that I would feel comfortable using without a fallback when applying non-critical styles, such as:</p>\n<pre><code>:is(h1, h2, h3) {\n  line-height: 1.2;\n}\n\n:is(h2, h3):not(:first-child) {\n  margin-top: 2em;\n}\n</code></pre>\n\n<p>In this example (which comes from <a href=\"https://smolcss.dev/#smol-document-styles\">the document styles in my project SmolCSS</a>), having the greater <code>line-height</code> inherited from base styles or lacking the <code>margin-top</code> is not really a problem for non-supporting browsers. It’s simply less than ideal. What you wouldn’t want to use <code>:is()</code> for quite yet would be <strong>critical layout styles</strong> such as Grid or Flex that significantly control your interface.</p>\n<p>Additionally, when chained to another selector, you can test whether the base selector matches a descendent selector within <code>:is()</code>. For example, the following rule selects only paragraphs that are direct descendants of articles. The universal selector is being used as a reference to the <code>p</code> base selector.</p>\n<pre><code>p:is(article &gt; *)\n</code></pre>\n\n<p>For the <a href=\"https://caniuse.com/css-matches-pseudo\">best current support</a>, if you’d like to start using it you’ll also want to <strong>double-up on styles</strong> by including duplicate rules using <code>:-webkit-any()</code> and <code>:matches()</code>. Remember to make these individual rules, or even the supporting browser will throw it out! In other words, include all of the following:</p>\n<pre><code>:matches(h1, h2, h3) { }\n\n:-webkit-any(h1, h2, h3) { }\n\n:is(h1, h2, h3) { }\n</code></pre>\n\n<p>Worth mentioning at this point is that along with the newer selectors themselves is an updated variation of <code>@supports</code> which is <code>@supports selector</code>. This is also available as <code>@supports not selector</code>.</p>\n<p><strong>Note</strong>: <em>At present (of the modern browsers), only Safari does not support this at-rule.</em></p>\n<p>You could check for <code>:is()</code> support with something like the following, but you’d actually be losing out on supporting Safari since Safari supports <code>:is()</code> but doesn’t support <code>@supports selector</code>.</p>\n<pre><code>@supports selector(:is(h1)) {\n  :is(h1, h2, h3) {\n    line-height: 1.1;\n  }\n}\n</code></pre>\n\n\n\n<h3><code>:where()</code></h3>\n<p>The pseudo-class <code>:where()</code> is almost identical to <code>:is()</code> except for one critical difference: it will <em>always</em> have zero-specificity. This has incredible implications for <strong>folks who are building frameworks, themes, and design systems</strong>. Using <code>:where()</code>, an author can set defaults and downstream developers can include overrides or extensions without specificity clashing.</p>\n<p>Consider the following set of <code>img</code>  styles. Using <code>:where()</code>, even with a higher specificity selector, the specificity remains zero. In the following example, which color border do you think the image will have?</p>\n<pre><code>:where(article img:not(:first-child)) {\n    border: 5px solid red;\n}\n\n:where(article) img {\n  border: 5px solid green;\n}\n\nimg {\n  border: 5px solid orange;\n}\n</code></pre>\n\n<p>The first rule has zero specificity since its wholly contained within <code>:where()</code>. So directly against the second rule, the second rule wins. Introducing the <code>img</code> element-only selector as the last rule, it’s going to win due to the cascade. This is because it will compute to the same specificity as the <code>:where(article) img</code> rule since the <code>:where()</code> portion does not increase specificity.</p>\n<p>Using <code>:where()</code> alongside fallbacks is a little more difficult due to the zero-specificity feature since that feature is likely why you would <em>want</em> to use it over <code>:is()</code>. And if you add fallback rules, those are likely to beat <code>:where()</code> due to its very nature. And, it has <strong>better overall support</strong> than the <code>@supports selector</code> so trying to use that to craft a fallback isn’t likely to provide much (if any) of a gain. Basically, be aware of the inability to correctly create fallbacks for <code>:where()</code> and carefully check your own data to determine if it’s safe to begin using for your unique audience.</p>\n<p>You can further test <code>:where()</code> with the following CodePen that uses the <code>img</code> selectors from above:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/jOyXVMg\">Testing <code>:where()</code> specificity</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<h3>Enhanced <code>:not()</code></h3>\n<p>The base <code>:not()</code> selector has been supported since Internet Explorer 9. But Selectors Level 4 enhances <code>:not()</code> by allowing it to take a selector list, just like <code>:is()</code> and <code>:where()</code>.</p>\n<p>The following rules provide the same result in supporting browsers:</p>\n<pre><code>article :not(h2):not(h3):not(h4) {\n  margin-bottom: 1.5em;\n}\n\narticle :not(h2, h3, h4) {\n  margin-bottom: 1.5em;\n}\n</code></pre>\n\n<p>The ability of <code>:not()</code> to accept a selector list <a href=\"https://caniuse.com/css-not-sel-list\">has great modern browser support</a>. </p>\n<p>As we saw with <code>:is()</code>, enhanced <code>:not()</code> can also contain a reference to the base selector as a descendent using <code>*</code>. This CodePen demonstrates this ability by selecting links that are <em>not</em> descendants of <code>nav</code>.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/BapvQQv\">Testing :not() with a descendent selector</a> by <a href=\"https://codepen.io/5t3ph\">Stephanie Eckles</a>.</p>\n<p><strong>Bonus</strong>: The previous demo also includes an example of chaining <code>:not()</code> and <code>:is()</code> to select images that are not adjacent siblings of either <code>h2</code> or <code>h3</code> elements.</p>\n<h3>Proposed but “at risk” — <code>:has()</code></h3>\n<p>The final pseudo-class that is a very exciting proposal but has no current browser implementing it even in an experimental way is <code>:has()</code>. In fact, it is listed in the <a href=\"https://drafts.csswg.org/selectors-4/#has-pseudo\">Selector Level 4 Editor’s Draft</a> as “at-risk” which means that it is recognized to have difficulties in completing its implementation and so it <em>may</em> be dropped from the recommendation.</p>\n<p>If implemented, <code>:has()</code> would essentially be the “parent selector” that many CSS folks have longed to have available. It would work with logic similar to a combination of both <code>:focus-within</code> and <code>:is()</code> with descendent selectors, where you are looking for the <strong>presence of descendants</strong> but the applied styling would be to the parent element.</p>\n<p>Given the following rule, if navigation contained a button, then the navigation would have decreased top and bottom padding:</p>\n<pre><code>nav {\n  padding: 0.75rem 0.25rem;\n\nnav:has(button) {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n}\n</code></pre>\n\n<p>Again, this is <em>not</em> currently implemented in any browser even experimentally — but it is fun to think about! Robin Rendle provided <a href=\"https://css-tricks.com/did-you-know-about-the-has-css-selector/\">additional insights into this future selector</a> over on CSS-Tricks.</p>\n<h3>Honorable Mention from Level 3: <code>:empty</code></h3>\n<p>A useful pseudo-class you may have missed from Selectors Level 3 is <code>:empty</code> which matches an element when it has <em>no</em> child elements, including text nodes. </p>\n<p>The rule <code>p:empty</code> will match <code>&lt;p&gt;&lt;/p&gt;</code> but not <code>&lt;p&gt;Hello&lt;/p&gt;</code>.</p>\n<p>One way you can use <code>:empty</code> is to hide elements that are perhaps placeholders for dynamic content that is populated with JavaScript. Perhaps you have a div that will receive search results, and when it’s populated it will have a border and some padding. But with no results yet, you don’t want it to take up space on the page. Using <code>:empty</code> you can hide it with:</p>\n<pre><code>.search-results:empty {\n  display: none;\n}\n</code></pre>\n\n<p>You may be thinking about adding a message in the empty state and be tempted to add it with a pseudo-element and <code>content</code>. The pitfall here is that messages may not be available to users of assistive technology which are inconsistent on whether they can access <code>content</code>. In other words, to <strong>make sure a “no results” type of message is accessible</strong>, you would want to add that as a real element like a paragraph (an <code>aria-label</code> would no longer be accessible for a hidden div).</p>\n<h4>Resources for Learning About Selectors</h4>\n<p>CSS has many more selectors inclusive of pseudo-classes. Here are a few more places to learn more about what’s available:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\">MDN CSS selectors documentation</a> includes a comprehensive categorized list;</li>\n<li>I’ve written a two-part guide to advanced CSS selectors, you can <a href=\"https://moderncss.dev/guide-to-advanced-css-selectors-part-one/\">start with part one</a>;</li>\n<li>Have fun learning about CSS selectors with the game <a href=\"https://flukeout.github.io/\">CSS Diner</a>;</li>\n<li>Kitty Giraudel created a <a href=\"https://kittygiraudel.github.io/selectors-explained/\">selector explanation tool</a> that will break down and describe parts of a provided selector.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4dec8bfd52b33f5dd2507bf3ecf5ea53f2109e6ffe8fbfb64a6a8f09e10d3c67","category":"Tech"}