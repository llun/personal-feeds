{"title":"New – AWS App Runner: From Code to a Scalable, Secure Web Application in Minutes","link":"https://aws.amazon.com/blogs/aws/app-runner-from-code-to-scalable-secure-web-apps/","date":1621379574000,"content":"<p>Containers have become the default way that I package my web applications. Although I love the speed, productivity, and consistency that containers provide, there is one aspect of the container development workflow that I do not like: the lengthy routine I go through when I deploy a container image for the first time.</p> \n<p>You might recognize this routine: setting up a load balancer, configuring the domain, setting up TLS, creating a CI/CD pipeline, and deploying to a container service.</p> \n<p>Over the years, I have tweaked my workflow and I now have a boilerplate <a href=\"https://aws.amazon.com/cdk/\">AWS Cloud Development Kit</a> project that I use, but it has taken me a long time to get to this stage. Although this boilerplate project is great for larger applications, it does feel like a lot of work when all I want to do is deploy and scale a single container image.</p> \n<p>At AWS, we have a number of services that provide granular control over your containerized application, but many customers have asked if AWS can handle the configuration and operations of their container environments. They simply want to point to their existing code or container repository and have their application run and scale in the cloud without having to configure and manage infrastructure services.</p> \n<p>Because customers asked us to create something simpler, our engineers have been hard at work creating a new service you are going to love.</p> \n<p><span><strong>Introducing <span>AWS App Runner</span></strong></span><br /> <a href=\"https://aws.amazon.com/apprunner\">AWS App Runner</a> makes it easier for you to deploy web apps and APIs to the cloud, regardless of the language they are written in, even for teams that lack prior experience deploying and managing containers or infrastructure. The service has AWS operational and security best practices built-it and automatically scale up or down at a moment’s notice, with no cold starts to worry about.</p> \n<p><span><strong>Deploying from Source</strong></span><br /> <span>App Runner</span> can deploy your app by either connecting to your source code or to a container registry. I will first show you how it works when connecting to source code. I have a Python web application in a GitHub repository. I will connect <span>App Runner</span> to this project, so you can see how it compiles and deploys my code to AWS.</p> \n<p>In the <span>App Runner</span> console, I choose <strong>Create an App Runner service</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/17/app-runner0.jpg\" /></p> \n<p>For <strong>Repository type</strong>, I choose <strong>Source code repository </strong>and then follow the instructions to connect the service to my GitHub account. For <strong>Repository</strong>, I choose the repository that contains the application I want to deploy. For <strong>Branch</strong>, I choose <strong>main</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner1.jpg\" /></p> \n<p>For <strong>Deployment trigger</strong>, I choose <strong>Automatic</strong>. This means when <span>App Runner</span> discovers a change to my source code, it automatically builds and deploys the updated version to my <span>App Runner</span> service</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/edt-deployment-settings.jpg\" /></p> \n<p>I can now configure the build. For <strong>Runtime</strong>, I choose <strong>Python 3</strong>. The service currently supports two languages: Python and Node.js. If you require other languages, then you will need to use the container registry workflow (which I will demonstrate later). I also complete the <strong>Build command</strong>, <strong>Start command</strong>, and <strong>Port </strong>fields, as shown here:</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/edt-configure-build.jpg\" /></p> \n<p>I now give my service a name and choose the CPU and memory size that I want my container to have. The choices I make here will affect the price I pay. Because my application requires very little CPU or memory, I choose 1 vCPU and 2 GB to keep my costs low. I can also provide any environment variables here to configure my application.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner4.jpg\" /></p> \n<p>The console allows me to customize several different settings for my service.</p> \n<p>I can configure the auto scaling behavior. By default, my service will have one instance of my container image, but if the service receives more than 80 concurrent requests, it will scale to multiple instances. You can optionally specify a maximum number for cost control.</p> \n<p>I can expand <strong>Health check</strong>, and set a path to which <span>App Runner</span> sends health check requests. If I do not set the path, <span>App Runner</span> attempts to make a TCP connection to verify health. By default, if <span>App Runner</span> receives five consecutive health check failures, it will consider the instance unhealthy and replace it.</p> \n<p>I can expand <strong>Security</strong>, and choose an IAM role to be used by the instance. This will give permission for the container to communicate with other AWS services. <span>App Runner</span> encrypts all stored copies of my application source image or source bundle. If I provide a customer-managed key (CMK), <span>App Runner</span> uses it to encrypt my source. If I do not provide one, <span>App Runner</span> uses an AWS-managed key instead.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner5.jpg\" /></p> \n<p>Finally, I review the configuration of the service and then choose <strong>Create &amp; deploy</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner6.jpg\" /></p> \n<p>After a few minutes, my application was deployed and the service provided a URL that points to my deployed web application. <span>App Runner</span> ensures that https is configured so I can share it with someone on my team to test the application, without them receiving browser security warnings. I do not need to implement the handling of HTTPS secure traffic in my container image <span>App Runner</span> configures the whole thing.</p> \n<p>I now want to set up a custom domain. The service allows me to configure it without leaving the console. I open my service, choose the <strong>Custom domains</strong> tab, and then choose<strong> Add domain</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner7.jpg\" /></p> \n<p>In <strong>Domain name</strong>, I enter the domain I want to use for my app, and then choose <strong>Save</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/app-runner8.jpg\" /></p> \n<p>After I prove ownership of the domain, the app will be available at my custom URL. Next, I will show you how <span>App Runner</span> works with container images.</p> \n<p><strong><u>Deploy from a Container Image</u></strong><br /> I created a .NET web application, built it as a container image, and then pushed this container image to Amazon ECR Public (our public container registry).</p> \n<p>Just as I did in the first demo, I choose <strong>Create service</strong>. On <strong>Source and deployment</strong>, for <strong>Repository type</strong>, I choose <strong>Container registry</strong>. For <strong>Provider</strong>, I choose <strong>Amazon ECR Public</strong>. In <strong>Container image URI</strong>, I enter the URI to the image.</p> \n<p>The deployment settings now only provide the option to manually trigger the deployment. This is because I chose <strong>Amazon ECR Public</strong>. If I wanted to deploy every time a container changed, then for <strong>Provider</strong>, I would need to choose <strong>Amazon ECR</strong>.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/18/edit-source-deployment.jpg\" /></p> \n<p>From this point on, the instructions are identical to those in the “Deploying from Source” section. After the deployment, the service provides a URL, and my application is live on the internet.</p> \n<p><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/17/speaker-app-runner.jpg\" /></p> \n<p><strong><u>Things to Know</u></strong><br /> <span>App Runner</span> implements the file system in your container instance as ephemeral storage. Files are temporary. For example, they do not persist when you pause and resume your <span>App Runner</span> service. More generally, files are not guaranteed to persist beyond the processing of a single request, as part of the stateless nature of your application. Stored files do, however, take up part of the storage allocation of your <span>App Runner</span> service for the duration of their lifespan. Although ephemeral storage files are not guaranteed to persist across requests, they might sometimes persist. You can opportunistically take advantage of it. For example, when handling a request, you can cache files that your application downloads if future requests might need them. This might speed up future request handling, but I cannot guarantee the speed gains. Your code should not assume that a file that has been downloaded in a previous request still exists. For guaranteed caching, use a high-throughput, low-latency, in-memory data store like <a href=\"https://aws.amazon.com/elasticache/\">Amazon ElastiCache</a>.</p> \n<p><span><strong>Partners in Action</strong></span><br /> We have been working with partners such as MongoDB, Datadog and HashiCorp to integrate with <span>App Runner</span>. Here is a flavor of what they have been working on:</p> \n<p><strong>MongoDB</strong> – “We’re excited to integrate App Runner with MongoDB Atlas so that developers can leverage the scalability and performance of our global, cloud-native database service for their App Runner applications.”</p> \n<p><strong>Datadog</strong> – “Using AWS App Runner, customers can now more easily deploy and scale their web applications from a container image or source code repository. With our new integration, customers can monitor their App Runner metrics, logs, and events to troubleshoot issues faster, and determine the best resource and scaling settings for their app.”</p> \n<p><strong>HashiCorp</strong> – “Integrating HashiCorp Terraform with AWS App Runner means developers have a faster, easier way to deploy production cloud applications, with less infrastructure to configure and manage.”</p> \n<p>We also have exciting integrations from Pulumi, Logz.io, Trek10, and Sysdig which will allow <span>App Runner</span> customers to use the tools and services they already know and trust.</p> \n<p><strong><u>Availability and Pricing</u></strong><br /> <a href=\"https://aws.amazon.com/apprunner\">AWS App Runner</a> is available today in <span>US East (N. Virginia)</span>, <span>US West (Oregon)</span>, <span>US East (Ohio)</span>, <span>Asia Pacific (Tokyo)</span>, <span>Europe (Ireland)</span>. You can use <span>App Runner</span> with the AWS Management Console and AWS Copilot CLI.</p> \n<p>With <span>App Runner</span>, you pay for the compute and memory resources used by your application. <span>App Runner</span> automatically scales the number of active containers up and down to meet the processing requirements of your application. You can set a maximum limit on the number of containers your application uses so that costs do not exceed your budget.</p> \n<p>You are only billed for <span>App Runner</span> when it is running and you can pause your application easily and resume it quickly. This is particularly useful in development and test situations as you can switch off an application when you are not using it, helping you manage your costs. For more information, see the <span>App Runner</span> <a href=\"https://aws.amazon.com/apprunner/pricing\">pricing page</a>.</p> \n<p><strong>Start using <a href=\"https://aws.amazon.com/apprunner\">AWS App Runner</a> today and run your web applications at scale, quickly and securely.</strong></p> \n<a href=\"https://twitter.com/thebeebs\">— Martin</a> \n<p> </p>","author":"Martin Beeby","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"218e4e33e5e6315cd1eeb3db0ae47ba5b9f4007c74e571342788f97a5bd7e1dc","category":"Tech"}