{"title":"Managing SSH Access at Scale with HashiCorp Vault","link":"https://www.hashicorp.com/blog/managing-ssh-access-at-scale-with-hashicorp-vault","date":1625673600000,"content":"<p>As enterprises accelerate their digital strategies, adoption of hybrid or multi-cloud architectures are becoming the new norm, requiring a fundamental shift in how infrastructure is provisioned and managed. When managing secure administration access to Unix-like servers, SSH is still the standard connectivity method. However, it does come with challenges and risks, especially in relation to key management.</p>\n<p>The common reaction to the growing risks around key management is to simply seek out “SSH key management tools” in Google and review industry reports. But implementing products in this one category is just treating a symptom of a bigger challenge: <a href=\"https://www.hashicorp.com/products/vault/secrets-management\">secrets management</a>. In this blog post, I will show you an SSH access architecture that will simplify SSH access using a scalable, secure, and consistent experience both on-premises and in public clouds. You can also view a demonstration of this architecture in this  presentation: <a href=\"https://www.hashicorp.com/resources/leveraging-signed-ssh-for-remote-access-with-vault\">Leveraging Signed SSH for Remote Access with Vault</a>.</p>\n<h2><a href=\"#risks-with-ssh-key-based-authentication\">»</a><a></a>Risks with SSH Key Based Authentication</h2>\n<p>Let’s begin by reviewing the limitations of SSH key-based authentication and what problems we are trying to solve:</p>\n<ul>\n<li><strong>Risk of private key compromise</strong>: Users will sometimes mishandle private keys, intentionally or unintentionally exposing them to other users or placing them in insecure locations.</li>\n<li><strong>Key rotation</strong>: Revoking private keys is a complex operation. How do you ensure that all copies of the private key are accounted for? What happens when administrators who have made copies of private keys leave the company?</li>\n<li><strong>Risk of unauthorized access</strong>: Over time, large collections of keys are created and implemented in multiple systems. Not having an inventory that tracks the usage of these keys, their relationships, what systems they access, and their usage patterns raises the risks of unauthorized access.</li>\n<li><strong>Scalability and complexity</strong>: Managing the keys across multiple systems and cloud environments consistently is a complex operation. Different architectures are introduced depending on which cloud environment the hosts are deployed to.</li>\n</ul>\n<p>The likelihood of incidents due to SSH key mismanagement is growing, and so is the level of harm these incidents can cause. When organizations Google “SSH key management tools” looking for answers, the results are often expensive and complex solutions that weren’t built for the low-trust perimeters of the public cloud. Any service outage in one of these SSH key management tools typically results in no access to any host.</p>\n<h2><a href=\"#a-much-better-alternative\">»</a><a></a>A (Much) Better Alternative</h2>\n<p>I’ve already mentioned that organizations need a solution that addresses all of the challenges listed above — improving the SSH user experience and the security of SSH access to your hosts using a standard architecture that can be deployed in any environment. Many of the Global 2000 customers I’ve worked with are getting this result using a combination of <a href=\"https://www.vaultproject.io/\">HashiCorp Vault</a> and SSH certificate authentication. I’m going to show you how this looks.</p>\n<h2><a href=\"#architecture-requirements\">»</a><a></a>Architecture Requirements</h2>\n<p>This architecture is designed to achieve the following outcomes:</p>\n<ul>\n<li>Enable and enforce <a href=\"https://www.hashicorp.com/resources/why-should-we-use-identity-based-security-as-we-ado\">identity-based security</a>, where users and applications must authenticate first before being granted the ability to SSH into a host.</li>\n<li>Enable a role-based access control (RBAC) model for SSH access to hosts where policies control which hosts can be accessed by the SSH client.</li>\n<li>Provide short-lived SSH credentials that expire.</li>\n<li>Simplify the SSH workflows and key management.</li>\n<li>Be applicable in any environment: private, hybrid, and multi-cloud.</li>\n</ul>\n<h2><a href=\"#ssh-certificate-authentication\">»</a><a></a>SSH Certificate Authentication</h2>\n<p>SSH certificates work in a way similar to SSL certificates. SSH certs are simply a public key signed by a trusted entity called the certificate authority (CA). They introduce important features that will be used in this architecture:</p>\n<ul>\n<li>SSH certificates are signed with a valid time and will automatically expire once the certificate has reached its expiry time. It can no longer be used by a client to connect to the target host once expired.</li>\n<li>Valid SSH certificates can only be signed by the trusted CA’s private key.</li>\n<li>It is possible to pass on additional SSH instructions in the signing of the SSH certificate, such as disabling port forwarding or adding usernames the certificate will be signed for.</li>\n</ul>\n<h2><a href=\"#ssh-configuration-features\">»</a><a></a>SSH Configuration Features</h2>\n<p>There are many SSH host configurations. Some are not used commonly since they do not typically apply to SSH key authentication methods. There is a specific configuration that is used to complete this architecture, the sshd <a href=\"https://man.openbsd.org/sshd_config#AuthorizedPrincipalsFile\">AuthorizedPrincipalsFile</a> configuration.</p>\n<h2><a href=\"#ssh-certificate-authority-ca-hashicorp-vault\">»</a><a></a>SSH Certificate Authority (CA) — HashiCorp Vault</h2>\n<p>HashiCorp Vault is a secrets management solution that programmatically brokers access to systems for both humans and machines. It can provide just-in-time secrets such as database credentials, PKI certificates, cloud IAM credentials, and many others.</p>\n<p>In this use case, Vault will use its <a href=\"https://www.vaultproject.io/docs/secrets/ssh\">SSH Secrets Engine</a>, allowing it to function as our SSH CA. It also provides granular access controls to SSH certificate parameters and signing, which is enforced by Vault policies.</p>\n<h2><a href=\"#the-workflow-outline\">»</a><a></a>The Workflow Outline</h2>\n<p>My architecture to implement SSH certificate authentication with HashiCorp Vault looks like this:</p><img src=\"https://www.datocms-assets.com/2885/1625670267-ssh-architecture.png\" /><p>The numbers in the diagram represent the following steps:</p>\n<ol>\n<li>User creates a personal SSH key pair.</li>\n<li>User authenticates to Vault with their Identity Provider (IDP) credentials.</li>\n<li>Once authenticated, the user sends their SSH public key to Vault for signing.</li>\n<li>Vault signs the SSH key and return the SSH certificate to the user.</li>\n<li>User initiates SSH connection using the SSH certificate.</li>\n<li>Host verifies the client SSH certificate is signed by the trusted SSH CA and allows connection.</li>\n</ol>\n<p>To expand on this, the Vault SSH Secret Engine can contain multiple Vault roles, where each role will contain the parameters that will be used during the SSH key signing. This allows different SSH certificates to be signed with different parameters and principals depending on the Vault role configurations. By using Vault policies, we achieve further control over who has access to these SSH CA roles.</p>\n<p>The Vault SSH Secret Engine and roles diagram below illustrates an example:</p><img src=\"https://www.datocms-assets.com/2885/1625670375-vault-ssh-secret-engine-and-roles.png\" /><p>Once a user successfully authenticates to Vault, a Vault token will be dynamically generated with an attached policy that dictates which services and secrets can be accessed by the user.</p>\n<h2><a href=\"#prerequisites\">»</a><a></a>Prerequisites</h2>\n<p>For the configurations below, you will need to have Vault running and unsealed. It is possible to test these configurations out locally by running Vault in dev mode. For Vault installation instructions, read the <a href=\"https://learn.hashicorp.com/tutorials/vault/getting-started-install?in=vault/getting-started\">getting started with Vault guide</a>.</p>\n<h2><a href=\"#user-requirements\">»</a><a></a>User Requirements</h2>\n<p>The configurations will be used to set up the following user access requirements.</p><img src=\"https://www.datocms-assets.com/2885/1625671815-vault-user-roles.png\" /><p>I will expand on these requirements in the subsequent sections.</p>\n<h2><a href=\"#vault-configurations\">»</a><a></a>Vault Configurations</h2>\n<p>The following steps will be used to configure Vault. For all the configurations I’ll use the Vault CLI.</p>\n<h3><a href=\"#mount-userpass-authentication-method-create-users-and-attach-policies\">»</a><a></a>Mount UserPass Authentication Method, Create Users, and Attach Policies</h3>\n<p>For the sake of simplicity, we’ll use the UserPass authentication method. Vault will act as your identity broker, giving you the ability to leverage many other authentication methods that Vault supports such as LDAP or OIDC authentication. Here is an example of <a href=\"https://learn.hashicorp.com/tutorials/vault/oidc-auth-azure?in=vault/auth-methods\">how to set up OIDC authentication with Azure AD</a>.</p>\n<p>Let’s set up three Vault accounts to represent the users that require SSH client access to hosts.</p><img src=\"https://www.datocms-assets.com/2885/1625670678-user-functional-role.png\" /><pre><code>vault auth enable userpass\n\nvault write auth/userpass/users/alice password=\"passw0rd\" policies=\"administrator-policy\"\n\nvault write auth/userpass/users/bob password=\"passw0rd\" policies=\"team-a-policy\"\n\nvault write auth/userpass/users/tim password=\"passw0rd\" policies=\"team-b-policy\"</code></pre><p>The Vault policies will be set up at a later stage.</p>\n<h3><a href=\"#mount-vault-ssh-certificate-secret-engine-and-generate-ssh-ca-key-pair\">»</a><a></a>Mount Vault SSH Certificate Secret Engine and Generate SSH CA Key Pair</h3>\n<p>The Vault SSH secret engine will need to be mounted and a signing key generated.</p><pre><code>vault secrets enable -path=ssh-client-signer ssh\n\nvault write ssh-client-signer/config/ca generate_signing_key=true</code></pre><p>You should get the following output, showing the SSH CA public key, which will be used later on in the host configurations.</p><pre><code>Success! Enabled the ssh secrets engine at: ssh-client-signer/\n\nKey Value\n— — — — -\npublic_key ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDthG9+wjEvCgqBVlBpifXK2PhjXzmjt2+3kN6J6CGsZpeevdlMtxutaAmALfREGYKGol4pqwzJrT5iGp3LAenuiC97x1skItXWrM+BYwyiaU0f8XjBIOPrviBN0v+H6XgoFlujxvdKgJ4+diORkaqtW4gz3Fhe/Gq/3s5WZ5MnB+UZsvYPhd0zuQorEoaYAqarwxq30XPSYEFaH6zqefddJaejMd8PiKGuFdhLHjnZ5jU0r+vpZfrcuQ+81RhVxD4wtiKmouO3zW8bBVrYoURKLap5UlPu8RzPwbJ3PtqtNDkV7SxeNvbXP9mmfkwyBqsU4zaenDRlFqc8UG0SyU6JMM4nL6pLpicC8EC/tHb434U/WwmuHrYhKmpXt25G6cCAHyWxu/9WXqrj4C4Cn2w495WgxGs3EqM+DotSRPw7GkfyCujnpCddcjPc1L5RdHk/tGI26UrnxMHOEBa+zXVmTlEeRyqg3HCSwBejAk3AT1lk1I+D89ANWDgipnNY7UZG+lSsRZHyiKKbfyhaoUFo8JW0KR6vujqflPrzmOHHHyW6zYmBKO+EYTlaiwWAV8nUMl5XfnARmq4Lv6WL3dbdhur6LWY1WiDNviByntYaEDViRXl6lyqrYhrXONJbi0PLB9HuKL7z4m3K9OYgYS5ofFjoCVb9HGytGgEko1wQ==</code></pre><h3><a href=\"#create-vault-roles-for-signing-client-ssh-keys\">»</a><a></a>Create Vault Roles for signing client SSH keys</h3>\n<p>To sign the client keys, we will configure Vault roles to sign and issue SSH certificates with specific configurations based on users’ functional roles.</p><img src=\"https://www.datocms-assets.com/2885/1625671581-vault-ssh-role.png\" /><p>Three Vault SSH roles will be configured for signing SSH client keys, where each role will sign for a specific SSH principal.</p>\n<p>Before we get to the code, A few important notes regarding Vault SSH role configurations:</p>\n<p><code>allowed_users</code>: This is the list of allowed users this CA role will sign for. If the requester attempts to get a key signed by specifying a different user not in the <code>allowed_users</code> list for that role, it will fail.</p>\n<p><code>ttl</code>: This is where certificate expiry is set when signing an SSH key. In this example it is set for 30 minutes. Once the certificate expires, a user must authenticate to Vault and request another signed SSH certificate.</p>\n<p><strong>administrator-role</strong></p><pre><code>vault write ssh-client-signer/roles/administrator-role -&lt;</code></pre><p><strong>team-a-role</strong></p><pre><code>vault write ssh-client-signer/roles/team-a-role -&lt;</code></pre><p><strong>team-b-role</strong></p><pre><code>vault write ssh-client-signer/roles/team-b-role -&lt;</code></pre><h2><a href=\"#create-vault-policies\">»</a><a></a>Create Vault Policies</h2>\n<p>For each user created earlier, a corresponding policy will need to be configured. Here are the policy names:</p><img src=\"https://www.datocms-assets.com/2885/1625672191-vault-policy.png\" /><p>These policies will restrict each user’s access to their authorized Vault SSH role for key signing. For example, Alice is an administrator and will require the SSH certificate signed with the <code>administrator</code> principal. She will have permissions to get her SSH public key signed by the <em>administrator-role</em>. She will not be able to use any other Vault SSH role as per the policy. There is an implicit deny on everything else.</p>\n<p><strong>administrator-policy</strong></p><pre><code>vault policy write administrator-policy — &lt;&lt; EOF\n# List available SSH roles\npath “ssh-client-signer/roles/*” {\n capabilities = [“list”]\n}\n# Allow access to SSH role\npath “ssh-client-signer/sign/administrator-role” {\n capabilities = [“create”,”update”]\n}\nEOF</code></pre><p><strong>team-a-policy</strong></p><pre><code>vault policy write team-a-policy — &lt;&lt; EOF\n# List available SSH roles\npath “ssh-client-signer/roles/*” {\n capabilities = [“list”]\n}\n# Allow access to SSH role\npath “ssh-client-signer/sign/team-a-role” {\n capabilities = [“create”,”update”]\n}\nEOF</code></pre><p><strong>team-b-policy</strong></p><pre><code>vault policy write team-b-policy — &lt;&lt; EOF\n# List available SSH roles\npath “ssh-client-signer/roles/*” {\n capabilities = [“list”]\n}\n# Allow access to SSH role\npath “ssh-client-signer/sign/team-b-role” {\n capabilities = [“create”,”update”]\n}\nEOF</code></pre><h2><a href=\"#host-configurations\">»</a><a></a>Host Configurations</h2>\n<p>A few steps are required to complete the SSH configurations on the host, however you can automate this setup by baking in these configurations into <a href=\"https://github.com/piontas/packer-golden-images\">golden image servers</a> or using configuration management tools. These steps are:</p>\n<ol>\n<li>Create local users on the server. These are the users that clients will use to SSH into the server.</li>\n<li>Setup an SSH CA public key on the server.</li>\n<li>Setup the <code>AuthorizedPrincipalsFile</code> and SSH principal names.</li>\n<li>Update <code>sshd_config</code> and restart the SSH service.</li>\n</ol>\n<p>Let's proceed with the configuration:</p><img src=\"https://www.datocms-assets.com/2885/1625672373-server-user-account-principal.png\" /><h3><a href=\"#create-local-users\">»</a><a></a>Create Local Users</h3>\n<p>These Linux accounts will be used for administrator and application user logins.</p><pre><code>sudo useradd -m admin\nsudo useradd -m appadmin</code></pre><h3><a href=\"#update-trusted-ssh-ca-public-key\">»</a><a></a>Update Trusted SSH CA Public Key</h3>\n<p>Navigate to the SSH directory and create a file that contains the SSH CA public key, this was previously configured in the <em>Mount Vault SSH Certificate Secret Engine and Generate SSH CA Key Pair</em> section.</p><pre><code>cd /etc/ssh\n \nsudo echo ‘ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDthG9+wjEvCgqBVlBpifXK2PhjXzmjt2+3kN6J6CGsZpeevdlMtxutaAmALfREGYKGol4pqwzJrT5iGp3LAenuiC97x1skItXWrM+BYwyiaU0f8XjBIOPrviBN0v+H6XgoFlujxvdKgJ4+diORkaqtW4gz3Fhe/Gq/3s5WZ5MnB+UZsvYPhd0zuQorEoaYAqarwxq30XPSYEFaH6zqefddJaejMd8PiKGuFdhLHjnZ5jU0r+vpZfrcuQ+81RhVxD4wtiKmouO3zW8bBVrYoURKLap5UlPu8RzPwbJ3PtqtNDkV7SxeNvbXP9mmfkwyBqsU4zaenDRlFqc8UG0SyU6JMM4nL6pLpicC8EC/tHb434U/WwmuHrYhKmpXt25G6cCAHyWxu/9WXqrj4C4Cn2w495WgxGs3EqM+DotSRPw7GkfyCujnpCddcjPc1L5RdHk/tGI26UrnxMHOEBa+zXVmTlEeRyqg3HCSwBejAk3AT1lk1I+D89ANWDgipnNY7UZG+lSsRZHyiKKbfyhaoUFo8JW0KR6vujqflPrzmOHHHyW6zYmBKO+EYTlaiwWAV8nUMl5XfnARmq4Lv6WL3dbdhur6LWY1WiDNviByntYaEDViRXl6lyqrYhrXONJbi0PLB9HuKL7z4m3K9OYgYS5ofFjoCVb9HGytGgEko1wQ==’ &gt; trusted-CA.pem</code></pre><h3><a href=\"#create-authorizedprincipalsfile-file-structure\">»</a><a></a>Create AuthorizedPrincipalsFile File Structure</h3>\n<p>The <code>AuthorizedPrincipalsFile</code> configurations are important to further control which SSH principals are accepted for certificate authentication. For client authentication to be successful, the principal in the signed SSH certificate must appear in the <code>AuthorizedPrincipalsFile</code> file. For now, let’s set up <code>AuthorizedPrincipalsFile</code> for the administrator and team-a principals only. We will revisit team-b principal later on.</p><pre><code>cd /etc/ssh\n \nmkdir auth_principals/\n \nsudo echo ‘administrator’ &gt; admin\nsudo echo ‘team-a’ &gt; appadmin</code></pre><h3><a href=\"#update-sshd_config-configuration-and-restart-service\">»</a><a></a>Update sshd_config Configuration and Restart Service</h3>\n<p>Update the SSH configuration file to reflect the required changes and enable SSH Certificate authentication. Add the following configurations to the <code>sshd_config</code> file.</p><pre><code>AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u\nChallengeResponseAuthentication no\nPasswordAuthentication no\nTrustedUserCAKeys /etc/ssh/trusted-CA.pem</code></pre><p>The <code>AuthorizedPrincipalsFile</code> is the path containing the files listing the accepted principal names. The <code>%u</code> signifies that the file name will be the username of the Linux user. So in our case, the <code>admin</code> user will contain the <code>administrator</code> principal, the <code>appadmin</code> user will contain the <code>team-a</code> principal.</p>\n<p>Don’t forget to restart the sshd service.</p><pre><code>sudo service sshd restart</code></pre><h2><a href=\"#client-configurations\">»</a><a></a>Client Configurations</h2>\n<p>The user will only need to create an SSH key pair. The user’s SSH public key will be signed by the Vault SSH CA and returned to the user. This signed SSH certificate will then be used to connect to the target host.</p>\n<p>Let's go through what that may look like for Alice, who is a systems administrator.</p>\n<h3><a href=\"#create-ssh-key-pair\">»</a><a></a>Create SSH Key Pair</h3><pre><code>ssh-keygen -b 2048 -t rsa -f ~/.ssh/alice-key\nssh-add ~/.ssh/alice-key</code></pre><h3><a href=\"#login-to-vault\">»</a><a></a>Login to Vault</h3>\n<p>Let’s login to Vault as Alice (administrator role), she should have permissions to access both servers. We are going to use the Vault CLI to authenticate with the UserPass authentication method. Notice the assigned policy:</p><pre><code>vault login -method=userpass username=alice password=passw0rd\n \nSuccess! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run “vault login” again. Future Vault requests will automatically use this token.\nKey                  Value\n — —                 — — -\ntoken               s.QuJwJTa14g9EvPUPsVx0Lta2\ntoken_accessor      wzxbGGElsJsyLibwVHOyBLjM\ntoken_duration      768h\ntoken_renewable     true\ntoken_policies      [“administrator-policy” “default”]\nidentity_policies   []\npolicies            [“administrator-policy” “default”]\ntoken_meta_username alice</code></pre><h3><a href=\"#request-signing-of-user-ssh-public-key\">»</a><a></a>Request Signing of User SSH Public Key</h3>\n<p>Once authenticated, she should have permissions to use the Vault SSH role <code>administrator-role</code> to sign her public SSH key.</p>\n<p>The signed certificate that is returned can be output to <code>alice-signed-key.pub</code>.</p><pre><code>vault write -field=signed_key ssh-client-signer/sign/administrator-role \\\n public_key=@$HOME/.ssh/alice-key.pub valid_principals=administrator &gt; ~/.ssh/alice-signed-key.pub</code></pre><p>Take note of the <code>valid_principals</code> requested: <code>administrator</code>. If Alice attempts to request any other principal not in the <code>allowed_users list</code> of the Vault SSH CA role, it will fail. This ensures that only authorized lists of SSH principals can be signed for, preventing a user from requesting other principals used by other teams.</p>\n<p>In the next code snippet, note the contents of the certificate, specifically the <code>Key ID</code>, <code>ttl</code>, and the configured principal. It is possible to adjust these configurations in the Vault SSH role. For example, you could extend the TTL of the certificate to one hour or another length of time.</p><pre><code>ssh-keygen -Lf ~/.ssh/alice-signed-key.pub\nalice-signed-key.pub:\n Type: ssh-rsa-cert-v01@openssh.com user certificate\n Public key: RSA-CERT SHA256:xSGrnRx5QLitljNNWonCJtAzNhGqqVkt06hvlHSCy0w\n Signing CA: RSA SHA256:ZMDd6dr1awUMgkrYEwx6KO76BlIjTkvBTbxoHXryMHc (using ssh-rsa)\n Key ID: “vault-userpass-alice-c521ab9d1c7940b8ad96334d5a89c226d0333611aaa9592dd3a86f947482cb4c”\n Serial: 1539122095861524177\n Valid: from 2021–06–10T14:52:30 to 2021–06–10T15:23:00\n Principals:\n administrator\n Critical Options: (none)\n Extensions:\n permit-pty</code></pre><h3><a href=\"#login-with-ssh-certificate\">»</a><a></a>Login with SSH Certificate</h3>\n<p>The client should be able to SSH into the host using the signed SSH certificate:</p><pre><code>ssh -i ~/.ssh/alice-signed-key.pub admin@server \"whoami\"\nadmin</code></pre><p>If Alice attempts to login with any other username, for example <code>appadmin</code> user, it will fail:</p><pre><code>ssh -i ~/.ssh/alice-signed-key.pub appadmin@server “whoami”\nappadmin@server: Permission denied (publickey).</code></pre><p>If you recall, the <code>AuthorizedPrincipalsFile</code> configuration for <code>appadmin</code> only has <code>team-a</code> as a listed principal. The <code>administrator</code> principal is not listed in the <code>AuthorizedPrincipalsFile</code> admin file.</p>\n<h3><a href=\"#what-about-bob-and-tim\">»</a><a></a>What About Bob and Tim?</h3>\n<p>Bob is in <code>team-a</code> and requirements specify that Bob should also have SSH access to the server. Let’s test Bob’s login:</p>\n<p>Generate an SSH key pair for Bob:</p><pre><code>ssh-keygen -b 2048 -t rsa -f ~/.ssh/bob-key -q -N “” 0&gt;&amp;-\nssh-add ~/.ssh/bob-key</code></pre><p>Login to Vault:</p><pre><code>vault login -method=userpass username=bob password=passw0rd\n \nSuccess! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run “vault login” again. Future Vault requests will automatically use this token.\nKey                      Value\n — —                      — — -\ntoken                     s.9INPgEYJQqRKeZ0FxRekQpHD\ntoken_accessor            dUYyvvFsCbGTRKQNI4O8K9WO\ntoken_duration            768h\ntoken_renewable           true\ntoken_policies            [“default” “team-a-policy”]\nidentity_policies         []\npolicies                  [“default” “team-a-policy”]\ntoken_meta_username bob</code></pre><p>Let's get the public key signed by Vault:</p><pre><code>vault write -field=signed_key ssh-client-signer/sign/team-a-role \\\n public_key=@$HOME/.ssh/bob-key.pub valid_principals=team-a &gt; ~/.ssh/bob-signed-key.pub</code></pre><p>Let's confirm the principal in the certificate <code>team-a</code>:</p><pre><code>ssh-keygen -Lf ~/.ssh/bob-signed-key.pub\n \nbob-signed-key.pub:\n Type: ssh-rsa-cert-v01@openssh.com user certificate\n Public key: RSA-CERT SHA256:moR3M+yGM2sQvRSmgobZx5OH/14rpGYIbmo9dw+VePg\n Signing CA: RSA SHA256:APvCMzgQirBY6PX8ZSaXgXVO6Bpops17pjHVo1RhUHo (using ssh-rsa)\n Key ID: “vault-userpass-bob-9a847733ec86336b10bd14a68286d9c79387ff5e2ba466086e6a3d770f9578f8”\n Serial: 3154484434744577453\n Valid: from 2021–06–11T17:26:49 to 2021–06–11T17:57:19\n Principals:\n team-a\n Critical Options: (none)\n Extensions:\n permit-pty</code></pre><p>Now Bob can use the signed certificate to sign in with the <code>appadmin</code> user and <code>team-a</code> principal:</p><pre><code>ssh -i ~/.ssh/bob-signed-key.pub -i ~/.ssh/bob-key appadmin@server “whoami”\nappadmin</code></pre><p>However, if Bob attempts to use the admin user, it will fail since the <code>team-a</code> principal is not allowed in the admin user on the host:</p><pre><code>ssh -i ~/.ssh/bob-signed-key.pub -i ~/.ssh/bob-key admin@server “whoami”\nadmin@server: Permission denied (publickey).</code></pre><p>What if Bob attempts to get his SSH public key signed with the <code>administrator</code> principal?</p><pre><code>vault write -field=signed_key ssh-client-signer/sign/team-a-role \\\n public_key=@$HOME/.ssh/bob-key.pub valid_principals=administrator &gt; ~/.ssh/bob-signed-key.pub\nError writing data to ssh-client-signer/sign/administrator-role: Error making API request.\nURL: PUT http://localhost:8200/v1/ssh-client-signer/sign/team-a-role\nCode: 400. Errors:\n* administrator is not a valid value for valid_principals</code></pre><p>As for Tim, he will have no access at all to the server since the <code>team-b</code> principal has not been added to any of the <code>AuthorizedPrincipalsFile</code> configurations. Feel free to follow the same steps shown earlier for Bob to test access.</p>\n<p>To allow Tim access to this specific server, the <code>AuthorizedPrincipalsFile</code> configuration will need to include the <code>team-b</code> principal under the <code>appadmin</code> file:</p><pre><code>cd /etc/ssh/auth_principals\n \nsudo echo ‘team-b’ &gt;&gt; appadmin</code></pre><h2><a href=\"#why-is-this-secure\">»</a><a></a>Why is This Secure?</h2>\n<p>There are many advantages to this architecture for SSH access. Here are a few:</p>\n<ul>\n<li>Short-lived SSH certificates minimize the impact of leaked credentials.</li>\n<li>All certificate signing requests require authentication to the IDP. This behavior allows enterprises to use a central identity provider for authorized SSH access to servers. Multi-factor authentication can also be enabled in the process for better security.</li>\n<li>Minimal changes are needed on the host side with no requirements for additional components such as SSH privileged access management (PAM) or 3rd party plugins.</li>\n<li>When using <code>AuthorizedPrincipalsFile</code> in conjunction with Vault SSH roles you can provide granular SSH access to selective hosts based on the user’s role, function, or team.</li>\n<li>There are no requirements in this setup for hosts to connect to Vault directly since the hosts only require the SSH CA public certificate.</li>\n<li>The SSH CA private key is protected and never leaves the Vault.</li>\n<li>All Vault authentication attempts and key signing requests are logged in an audit trail.</li>\n<li>It is possible to create multiple SSH CA instances with Vault that cater to different environments such as dev, test, and production servers.</li>\n<li>This architecture is very flexible and can be used across any cloud and on-premises for SSH access to Linux servers. Multiple Vault SSH CAs can be configured for different environments, each one having its own SSH roles and associated policies to further control which target hosts can be accessed.</li>\n</ul><img src=\"https://www.datocms-assets.com/2885/1625674720-final-big-vault-roles-image.png\" /><p><em>Above is an architecture diagram of multiple Vault SSH CAs managing multiple SSH roles for different permissions.</em></p>\n<h2><a href=\"#review-and-additional-resources\">»</a><a></a>Review and Additional Resources</h2>\n<p>We have covered a lot in this post, with detailed insights on how to effectively manage SSH access at scale using Vault and SSH certificates. Managing SSH access across multiple environments with SSH key authentication is challenging and many enterprises struggle as they scale while trying to manage SSH access to hundreds or thousands of hosts.  For more information, here are a few resources:</p>\n<ul>\n<li><a href=\"https://learn.hashicorp.com/tutorials/vault/ssh-otp?in=vault/secrets-management\">SSH Secrets Engine: One-Time SSH Password</a></li>\n<li><a href=\"https://www.vaultproject.io/docs/secrets/ssh/signed-ssh-certificates\">Signed SSH Certificates - SSH - Secrets Engines</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/leveraging-signed-ssh-for-remote-access-with-vault\">Leveraging Signed SSH for Remote Access with Vault</a></li>\n<li><a href=\"https://man.openbsd.org/sshd_config#AuthorizedPrincipalsFile\">sshd_config(5)</a></li>\n</ul>\n<p>If you need more clarification on this walkthrough, feel free to message me on <a href=\"https://twitter.com/moayadis\">Twitter</a>.</p>","author":"Moayad Ismail","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"b3d5427de42a1456607313f1a83b1d82ac67b87acf73277060745861ceb9f5cf","category":"Tech"}