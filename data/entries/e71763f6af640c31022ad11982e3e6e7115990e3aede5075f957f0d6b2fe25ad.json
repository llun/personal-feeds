{"title":"A Guide To Undoing Mistakes With Git (Part 2)","link":"https://smashingmagazine.com/2021/05/undoing-mistakes-git-part2/","date":1621951200000,"content":"<p>In this second part of our series on \"Undoing Mistakes with Git\", weâ€™ll bravely look danger in the eye again: Iâ€™ve prepared four new doomsday scenarios â€” including, of course, some clever ways to save our necks! But before we dive in: take a look at the check out <a href=\"http://smashingmagazine.com/category/git/\">previous articles on Git</a> for even more self-rescue methods that help you undo your mistakes with Git!</p>\n<p>Letâ€™s go!</p>\n<h3>Recovering a Deleted Branch Using the Reflog</h3>\n<p>Have you ever deleted a branch and, shortly after, realized that you shouldnâ€™t have? In the unlikely event that you donâ€™t know this feeling, I can tell you that itâ€™s not a good one. A mixture of sadness and anger creeps up on you, while you think of all the hard work that went into that branchâ€™s commits, all the valuable code that youâ€™ve now lost.</p>\n<p>Luckily, thereâ€™s a way to bring that branch back from the dead â€” with the help of a Git tool named \"Reflog\". We had used this tool in the <a href=\"https://www.smashingmagazine.com/2021/05/undoing-mistakes-git-part1/\">first part of our series</a>, but hereâ€™s a little refresher: the Reflog is like a journal where Git notes every movement of the HEAD pointer in your local repository. In other, less nerdy words: any time you checkout, commit, merge, rebase, cherry-pick, and so on, a journal entry is created. This makes the Reflog a perfect safety net when things go wrong!</p>\n<p>Letâ€™s take a look at a concrete example:</p>\n<pre><code>$ git branch\n* feature/login\nmaster\n</code></pre>\n\n<p>We can see that we currently have our branch <code>feature/login</code> checked out. Letâ€™s say that this is the branch weâ€™re going to delete (inadvertently). Before we can do that, however, we need to switch to a different branch because we cannot delete our current HEAD branch!</p>\n<pre><code>$ git checkout master\n$ git branch -d feature/login\n</code></pre>\n\n<p>Our valuable feature branch is now gone â€” and Iâ€™ll give you a minute to (a) understand the gravity of our mistake and (b) to mourn a little. After youâ€™ve wiped away the tears, we need to find a way to bring back this branch! Letâ€™s open the Reflog (simply by typing <code>git reflog</code>) and see what it has in store for us:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9ee79e32-1818-4bf4-8aa3-68f194545b54/reflog-deleted-branch-2x.png\" /></p>\n<p>Here are some comments to help you make sense of the output:</p>\n<ul>\n<li>First of all, you need to know that the Reflog sorts its entries chronologically: the newest items are at the top of the list.</li>\n<li>The topmost (and therefore newest) item is the <code>git checkout</code> command that we performed before deleting the branch. Itâ€™s logged here in the Reflog because itâ€™s one of these \"HEAD pointer movements\" that the Reflog so dutifully records.</li>\n<li>To undo our grave mistake, we can simply return to the state <em>before</em> that â€” which is also cleanly and clearly recorded in the Reflog!</li>\n</ul>\n<p>So letâ€™s try this, by creating a new branch (with the name of our \"lost\" branch) that starts at this \"before\" state SHA-1 hash:</p>\n<pre><code>$ git branch feature/login 776f8ca\n</code></pre>\n\n<p>And voila! Youâ€™ll be delighted to see that weâ€™ve now restored our seemingly lost branch! ðŸŽ‰</p>\n<p>If youâ€™re using a <a href=\"https://www.git-tower.com/?utm_source=smashingmagazine&amp;utm_medium=guestpost&amp;utm_campaign=undoing-mistakes-02\">Git desktop GUI like \"Tower\"</a>, you can take a nice shortcut: simply hit CMD + Z on your keyboard to undo the last command â€” even if youâ€™ve just violently deleted a branch!</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8df4871c-b565-48af-8446-2ec35dcb0f86/commit-on-wrong-branch-2x.png\" /></p>\n<p>Luckily, these types of problems can be easily corrected. Letâ€™s roll up our sleeves and get to work.</p>\n<p>The first step is to switch to the correct destination branch and then move the commit overusing the <code>cherry-pick</code> command:</p>\n<pre><code>$ git checkout feature/login\n$ git cherry-pick 776f8caf\n</code></pre>\n\n<p>You will now have the commit on the desired branch, where it should have been in the first place. Awesome!</p>\n<p>But thereâ€™s still one thing left to do: we need to clean up the branch where it <em>accidentally</em> landed at first! The <code>cherry-pick</code> command, so to speak, created a copy of the commit â€” but the original is still present on our long-running branch:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d362e9cd-0b1a-4a8c-ad97-e03d083b243a/remove-commit-from-branch-2x.png\" /></p>\n<p>This means we have to switch back to our long-running branch and use <code>git reset</code> to remove it:</p>\n<pre><code>$ git checkout main\n$ git reset --hard HEAD~1\n</code></pre>\n\n<p>As you can see, weâ€™re using the <code>git reset</code> command here to erase the faulty commit. The <code>HEAD~1</code> parameter tells Git to \"go back 1 revision behind HEAD\", effectively erasing the topmost (and in our case: unwanted) commit from the history of that branch.</p>\n<p>And voila: the commit is now where it should have been in the first place <em>and</em> our long-running branch is clean â€” as if our mistake had never happened!</p>\n<h3>Editing the Message of an Old Commit</h3>\n<p>Itâ€™s all too easy to smuggle a typo into a commit message â€” and only discover it much later. In such a case, the good old <code>--amend</code> option of <code>git commit</code> cannot be used to fix this problem, because it only works for the very last commit. To correct any commit that is older than that, we have to resort to a Git tool called \"Interactive Rebase\".</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ea8f2b3b-17e4-46e4-bafa-ee428927cc8d/edit-commit-message-2x.png\" /></p>\n<p>First, we have to tell Interactive Rebase which part of the commit history we want to edit. This is done by feeding it a commit hash: the <em>parent</em> commit of the one we want to manipulate.</p>\n<pre><code>$ git rebase -i 6bcf266b\n</code></pre>\n\n<p>An editor window will then open up. It contains a list of all commits <em>after</em> the one we provided as a basis for the Interactive Rebase in the command:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b1b82e30-28e1-46d9-b526-ec3f17c78286/interactive-rebase-reword-commit-list-2x.png\" /></p>\n<p>Here, itâ€™s important that you <em>donâ€™t</em> follow your first impulse: in this step, we do <em>not</em> edit the commit message, yet. Instead, we only tell Git what <em>kind of manipulation</em> we want to do with which commit(s). Quite conveniently, thereâ€™s a list of action keywords noted in the comments at the bottom of this window. For our case, we mark up line #1 with <code>reword</code> (thereby replacing the standard <code>pick</code>).</p>\n<p>All thatâ€™s left to do in this step is to save and close the editor window. In return, a new editor window will open up that contains the current message of the commit we marked up. And <em>now</em> is finally the time to make our edits!</p>\n<p>Hereâ€™s the whole process at a glance for you:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a362d6e3-489b-4eee-a5c6-c773206f1ee9/fixing-commits-with-bandaids-2x.png\" /></p>\n<p>This is where <code>fixup</code> comes in. It allows you to still make this correcting band-aid commit. But here comes the magic: it then applies it to the original, broken commit (repairing it that way) and then discards the ugly band-aid commit completely!</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b6122872-491a-4a24-83ac-2db6331f9956/fixup-workflow-2x.png\" /></p>\n<p>We can go through a practical example together! Letâ€™s say that the selected commit here is broken.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dc43d8cf-8e3b-45c9-8a6d-6a30d1ebfe1c/fixup-broken-commit-2x.png\" /></p>\n<p>Letâ€™s <em>also</em> say that I have prepared changes in a file named <code>error.html</code> that will solve the problem. Hereâ€™s the first step we need to make:</p>\n<pre><code>$ git add error.html\n$ git commit --fixup 2b504bee\n</code></pre>\n\n<p>Weâ€™re creating a new commit, but weâ€™re telling Git this is a special one: itâ€™s a fix for an old commit with the specified SHA-1 hash (<code>2b504bee</code> in this case).</p>\n<p>The second step, now, is to start an Interactive Rebase session â€” because <code>fixup</code> belongs to the big toolset of Interactive Rebase.</p>\n<pre><code>$ git rebase -i --autosquash 0023cddd\n</code></pre>\n\n<p>Two things are worth explaining about this command. First, why did I provide <code>0023cddd</code> as the revision hash here? Because we need to start our Interactive Rebase session at the parent commit of our broken fellow.</p>\n<p>Second, what is the <code>--autosquash</code> option for? It takes a lot of work off our shoulders! In the editor window that now opens, everything is already prepared for us:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e1e78ea1-12dc-4879-807a-7eb5b623ea68/fixup-editor-2x.png\" /></p>\n<p>Thanks to the <code>--autosquash</code> option, Git has already done the heavy lifting for us:</p>\n<ol>\n<li>It marked our little band-aid commit with the <code>fixup</code> action keyword. That way, Git will combine it with the commit directly <em>above</em> and then discard it.</li>\n<li>It also reordered the lines accordingly, moving our band-aid commit directly below the commit we want to fix (again: <code>fixup</code> works by combining the marked-up commit with the one <em>above</em>!).</li>\n</ol>\n<p>In short: Thereâ€™s nothing to do for us but close the window!</p>\n<p>Letâ€™s take a final look at the end result.</p>\n<ul>\n<li>The formerly broken commit is fixed: it now contains the changes we prepared in our band-aid commit.</li>\n<li>The ugly band-aid commit itself has been discarded: the commit history is clean and easy to read â€” as if no mistake had occurred at all.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b96df80d-96e0-4a90-ba35-f616eccc8e5c/fixup-end-situation-2x.png\" /></p>\n<h3>Knowing How to Undo Mistakes is a Superpower</h3>\n<p>Congratulations! You are now able to save your neck in many difficult situations! We cannot really avoid these situations: no matter how experienced we are as developers, mistakes are simply part of the job. But now that you know how to deal with them, you can face them with a laid-back heart rate. ðŸ’š</p>\n<p>If you want to learn more about undoing mistakes with Git, I can recommend the free \"<a href=\"https://www.git-tower.com/learn/git/first-aid-kit?utm_source=smashingmagazine&amp;utm_medium=guestpost&amp;utm_campaign=undoing-mistakes-02\">First Aid Kit for Git</a>\", a series of short videos about exactly this topic.</p>\n<p>Have fun making mistakes â€” and, of course, undoing them with ease!</p>","author":"","siteTitle":"Articles on Smashing Magazine â€” For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"e71763f6af640c31022ad11982e3e6e7115990e3aede5075f957f0d6b2fe25ad","category":"Tech"}