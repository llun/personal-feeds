{"title":"Terraform Mono Repo vs. Multi Repo: The Great Debate","link":"https://www.hashicorp.com/blog/terraform-mono-repo-vs-multi-repo-the-great-debate","date":1611864000000,"content":"<p>A commonly asked question on HashiCorp forums, posts, blogs, and even at conferences or webinars is: Should my organization use a monolithic source repository (mono repo) or multiple source repositories (multi repo)? The short answer is this: It will depend on your organization and has everything to do with organizational patterns. This post will discuss the nuances of using each approach and when you should eventually break your mono repo into a multi repo.</p>\n<p>For the purposes of this blog post, a mono repo keeps many Terraform configurations as separate directories in a single repository. By comparison, a multi repo approach organizes each Terraform configuration in a separate repository. What happens when you run terraform init? It uses <a href=\"https://github.com/hashicorp/go-getter\">go-getter</a> to download all needed modules and, in essence, behaves like a mono repo. While Terraform supports the local referencing of modules, it handles the sourcing of remote modules, which lends well to a multi repo structure.</p>\n<h2><a class=\"__permalink-h\" href=\"#monolithic-source-repositories-mono-repos\" aria-label=\"monolithic source repositories mono repos permalink\">»</a><a class=\"__target-h\" id=\"monolithic-source-repositories-mono-repos\" aria-hidden></a>Monolithic Source Repositories (Mono Repos)</h2>\n<p>When we refer to mono repos, do we include application code and its infrastructure? In this blog, we focus on a mono repo for infrastructure components, such as networking, compute, or software as a service (SaaS) resources.</p>\n<p>Mono repos work if you have a personal project or a smaller team, and you need visibility into all of the infrastructure you're creating and uniform access to your configurations. What kind of mono repo structure will help you get the most out of your collaboration efforts and infrastructure as code? In a mono repo, divide your modules into a separate folder with the smallest grouping of resources and their dependencies. For example, you create individual module folders for AWS lambda (<code>function</code>), queue, and virtual network (<code>vpc</code>).</p><pre><code>> tree my-company-functions\n└── modules\n    ├── function\n    │   ├── main.tf      // contains aws_iam_role, aws_lambda_function\n    │   ├── outputs.tf\n    │   └── variables.tf\n    ├── queue\n    │   ├── main.tf      // contains aws_sqs_queue\n    │   ├── outputs.tf\n    │   └── variables.tf\n    └── vpc\n        ├── main.tf      // contains aws_vpc, aws_subnet\n        ├── outputs.tf\n        └── variables.tf</code></pre><p>To version modules, you can copy the module folder and append a version number to it. Otherwise, you might need to use some complex repository tagging to achieve versioning.</p>\n<p>Then, separate environment configurations into individual folders per business domain, product, or team. The following example represents two business domains, one related to collecting document metadata and the other translating them, and two environments, production and staging.</p><pre><code>> tree my-company-functions\n├── modules\n├── production\n│   ├── document-metadata\n│   │   └── main.tf\n│   └── document-translate\n│       └── main.tf\n└── staging\n    ├── document-metadata\n    │   └── main.tf\n    └── document-translate\n        └── main.tf</code></pre><p>The configurations for production and staging reference the <code>modules</code> directory to create the function, queue, and network. This can be per business domain, product, or team. Some examples of dividing by business domain or team could be:</p>\n<ul>\n<li>Infrastructure team</li>\n<li>Shared services team (CI team)</li>\n<li>Application / product team</li>\n<li>Security team</li>\n</ul>\n<p>To apply changes to configuration, you must develop a continuous integration pipeline to reference differences in each subdirectory, change directories, and apply changes in each directory individually.</p>\n<h3><a class=\"__permalink-h\" href=\"#advantages\" aria-label=\"advantages permalink\">»</a><a class=\"__target-h\" id=\"advantages\" aria-hidden></a>Advantages</h3>\n<ul>\n<li>A mono repo becomes a single source of truth to get all infrastructure configuration.</li>\n<li>It consolidates infrastructure configuration for testing and debugging, which can be important for database testing, queues, event streaming, or data pipelines.</li>\n</ul>\n<h3><a class=\"__permalink-h\" href=\"#disadvantages\" aria-label=\"disadvantages permalink\">»</a><a class=\"__target-h\" id=\"disadvantages\" aria-hidden></a>Disadvantages</h3>\n<ul>\n<li>When you update modules over time, module maintenance overhead increases. Module and provider versioning and dependencies can be fairly confusing to debug in this paradigm. As a best practice, you should <a href=\"https://www.terraform.io/docs/language/modules/develop/providers.html\">pin provider versions</a> in each module. However, separating and versioning modules by subdirectory can make it difficult to debug which provider versions are used in each module.</li>\n<li>In addition, your build system cannot scale as you create more subdirectories and environments. When you apply changes through a pipeline, you need to go into every folder and check for changes. Many CI frameworks use changesets to evaluate differences, which can increase your pipeline runtime.</li>\n<li>Access control is applied to the entire mono repo by default. In some circumstances, you might only want a user or group to access specific subdirectories. For example, you may not want all team members to have access to change users and groups. This might be something that has to be approved first by an operations team in a <code>CODEOWNERS</code> file.</li>\n</ul>\n<p>If you find yourself spending more time maintaining your build system logic to accommodate your infrastructure mono repo, you may want to break down your mono repo into multiple repositories.</p>\n<h2><a class=\"__permalink-h\" href=\"#multiple-source-repositories-multi-repos\" aria-label=\"multiple source repositories multi repos permalink\">»</a><a class=\"__target-h\" id=\"multiple-source-repositories-multi-repos\" aria-hidden></a>Multiple Source Repositories (Multi Repos)</h2>\n<p>A multi repo can better support granular access control and configuration changes. If you have a large team that collaborates on a complex infrastructure system, multiple source repositories allow you to localize changes and lessen the blast radius of failed infrastructure updates across the system. You can scope changes to the teams responsible for the infrastructure.</p>\n<p>There are many approaches to organization your multi repo. For example, you can divide each module into its own repository. In the case of the serverless function, queue, and network, you would create individual repositories for AWS lambda (<code>function</code>), queue, and virtual network (<code>network</code>). Individual business units or products would reference these remote modules. Environments would be captured by subdirectories in each product or business repository.</p><img src=https://www.datocms-assets.com/2885/1611862219-mono-multi-terraform-repo.png alt=Terraform multiple source repository structure><p>Use release tagging to handle the versioning of modules. By separating the modules into their own source repositories, you can test them independently, allow dependent configurations to reference the module version, and update the provider version with the module version.</p>\n<p>You can further structure your multi repo with separate repositories for each business domain, product, or team. Use subdirectories within these repositories to separate environments, which offers visibility into configuration differences between environments. Since you use a repository for each business domain or product, continuous integration pipelines have fewer subdirectories to recursively check for changes. You can optimize your pipelines for each configuration or module.</p>\n<h3><a class=\"__permalink-h\" href=\"#advantages\" aria-label=\"advantages permalink\">»</a><a class=\"__target-h\" id=\"advantages\" aria-hidden></a>Advantages</h3>\n<ul>\n<li>Multi repos enable teams to self-service and compose based on shared building blocks.</li>\n<li>Independent repositories allow isolated testing for module security &#x26; functionality.</li>\n<li>You can apply module versioning using release tagging and existing tag constructs.</li>\n<li>Individual repositories allow for access control of modules and configurations.</li>\n<li>Scoping changes to a specific repository can minimize the blast radius of changes.</li>\n</ul>\n<h3><a class=\"__permalink-h\" href=\"#disadvantage\" aria-label=\"disadvantage permalink\">»</a><a class=\"__target-h\" id=\"disadvantage\" aria-hidden></a>Disadvantage</h3>\n<ul>\n<li>If you have a configuration that references many remote modules, Terraform will take time to download them. Try using git submodules to clone the remote repository and store it locally based on commit.</li>\n</ul>\n<h2><a class=\"__permalink-h\" href=\"#conclusion\" aria-label=\"conclusion permalink\">»</a><a class=\"__target-h\" id=\"conclusion\" aria-hidden></a>Conclusion</h2>\n<p>There is no right or wrong answer when discussing the use of mono repos and multi repos. By taking a step back and observing different organizational patterns, we can determine which environment structure works best for us.</p>\n<p>For more information on separating configurations for environments, take a look at the <a href=\"https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html\">Terraform Recommended Practices</a> documentation. best practices for code for Terraform Cloud workspaces, review our documentation on <a href=\"https://www.terraform.io/docs/cloud/workspaces/configurations.html#code-organization-and-repository-structure\">code organization and workspace structure</a>. To restructure your Terraform for production, review our blog on <a href=\"https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production\">refactoring configuration</a>. For best practices and pitfalls in a large Terraform mono repo, check out lessons learned from <a href=\"https://www.hashicorp.com/resources/closing-keynote-terraform-at-google\">Terraform at Google</a>. To try a hands-on example of breaking up a mono repo into separate dev and prod envoronments with a module shared between them, follow the Learn tutorial, <a href=\"https://learn.hashicorp.com/tutorials/terraform/organize-configuration?in=terraform/modules\">Separate Development and Production Environments</a>.</p>","author":"Tracy Holmes","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"9df7aa187d630f1ae390d81281ed0f9b58ce123f371146469354d47a9bba5ec1","category":"Tech"}