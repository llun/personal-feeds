{"title":"เล่นแลกของขวัญให้ไม่ได้ของตัวเอง","link":"https://neizod.github.io/2021/06/20/unbiased-all-derangement.html","date":1624206265000,"content":"<p>เคยตั้งข้อสังเกตไว้<a href=\"/2015/12/29/get-self-gift-from-party.html\">กว่าครึ่งทศวรรษ</a>ว่า งานปาร์ตี้แลกของขวัญมักมีคนที่ได้ของขวัญของตัวเองอยู่บ่อยๆ ซึ่งจากการวิเคราะห์ความน่าจะเป็นทำให้เห็นว่าโอกาสที่งานปาร์ตี้หนึ่งๆ จะไม่มีใครได้ของขวัญของตัวเองเลยนั้นลู่เข้าหา $1/e$ แต่ยังเหลือคำถามสำคัญที่ไม่ได้ตอบคือ แล้วเราจะมีวิธีแลกของขวัญที่แฟร์และไม่มีใครได้ของขวัญของตัวเองมั้ย?</p>\n\n<p>ก่อนอื่นระลึกกันอีกครั้งว่า จากคนที่มาเล่นเกมแลกของขวัญ $n$ คน จำนวนวิธีการการแลกของขวัญที่ไม่มีใครได้ของตัวเองมีทั้งหมด</p>\n\n\\[\\begin{align}\nd(0) &amp;= 1 \\\\\nd(1) &amp;= 0 \\\\\nd(n) &amp;= (n-1) \\Big( d(n-1) + d(n-2) \\Big)\n      = \\left\\lceil \\frac{n!}e \\right\\rfloor\n\\end{align}\\]\n\n<p>แต่เพราะจำนวนวิธีการแลกของขวัญทั้งหมดที่สามารถมีคนได้ของตัวเองได้คือ $n!$ ซึ่งจะเห็นว่าลู่เข้า ดังนั้น $d(n)/n! \\approx 1/e$ หรือประมาณ $36\\%$ นี่ทำให้เรามีขั้นตอนวิธีที่ง่ายดายสำหรับการแลกของขวัญที่ไม่มีใครได้ของตัวเอง ซึ่งก็คือการสุ่มแลกของขวัญไปเรื่อยๆ จนครบทุกคนนั่นแหละ แต่ถ้าระหว่างทางมีใครจับได้ของขวัญของตัวเองก็จะต้องกลับไปเริ่มการแลกของขวัญใหม่ตั้งแต่ต้น (ถ้าไม่โละกระดานเริ่มใหม่จะได้ผลลัพธ์ที่ไม่แฟร์) เนื่องจากโอกาสที่จะไม่มีใครได้ของขวัญของตัวเองเป็นค่าคงที่ประมาณหนึ่งในสาม ดังนั้นโดยเฉลี่ยแล้วเราจะเริ่มใหม่ประมาณสามรอบถึงจะเจอการแลกของขวัญที่ต้องการ</p>\n\n<p>แม้วิธีข้างต้นจะถือว่าไม่เลวในมุมมองอัลกอริทึมสำหรับคอมพิวเตอร์ แต่หากนำไปใช้งานจริงในปาร์ตี้ก็อาจจะดูแปลกจนน่าเวียนหัว เพราะระหว่างทางที่แลกของขวัญ คนที่ร่วมเล่นเกมจะได้กล่องของขวัญของคนอื่นมาวางไว้ตรงหน้าด้วยความตื่นเต้นแล้ว แต่ก็ยังเปิดกล่องของขวัญไม่ได้จนกว่าการแลกของขวัญจะสิ้นเสร็จถูกต้องสมบูรณ์จนถึงคนสุดท้าย และยังมีโอกาสสูงมากที่จะต้องโบกมือลาบ๊ายบายกล่องของขวัญที่แลกมาระหว่างทางเพราะต้องเริ่มเล่นแลกของขวัญใหม่ทั้งหมดอีกรอบด้วย</p>\n\n<p>เราอาจเปลี่ยนไปใช้วิธีของ Hannah Fry ใน<a href=\"//youtu.be/5kC5k5QBqcc\">วิดีโอ Secret Santa</a> ก็ได้ ซึ่งให้ผลลัพธ์การแลกของขวัญที่ทุกคนมีโอกาสได้ของคนอื่นเท่าๆ กันโดยไม่มีโอกาสได้ของตัวเองเลย แต่กระบวนการดังกล่าวจะให้ผลลัพธ์ไม่ครอบคลุมวิธีการแลกของขวัญทั้งหมด เพราะมีเพียงแค่การแลกของขวัญเป็นวงกลมวงใหญ่เพียงวงเดียวเท่านั้นที่สามารถเป็นผลลัพธ์ได้ ในขณะที่วิธีการแลกของขวัญทั้งหมดสามารถมีวงแลกของขวัญย่อยๆ ได้หลายวงเลย</p>\n\n<p>และแม้วิธีดังกล่าวจะมีขั้นตอนเรียบง่ายทั้งยังให้ผลลัพธ์ที่ถือว่าแฟร์แล้ว แต่จุดตายสำคัญคือการออกแบบวิธีที่ขาดส่วนร่วมจากผู้เล่นแต่ละคนที่อุตสาห์เฟ้นหาของขวัญมาเล่นเกมนี้ เพราะขั้นตอนวิธีดังกล่าวอาศัยเพียงแค่กรรมการหนึ่งคนก็เพียงพอแล้วที่จะจัดเรียงหาว่าใครควรได้ของขวัญจากใคร ผู้เล่นแต่ละคนแค่นำกล่องของขวัญมาวางไว้ตอนเริ่มปาร์ตี้แล้วก็หยิบกล่องของขวัญตามคำบอกกลับบ้านตอนจบปาร์ตี้ได้เลย ไม่ต้องออกแรงสุ่มด้วยตนเองใดๆ ทั้งสิ้น</p>\n\n<p>เช่นนี้แล้วเราจะสิ้นหวังหาทางออกที่บาลานซ์ระหว่างความถูกต้องทางคณิตศาสตร์และความสนุกตื่นเต้นเร้าใจและมีส่วนร่วมของมนุษย์ให้กับเรื่องนี้ไม่ได้เลยหรือ? โชคดีที่ <a href=\"//facebook.com/nat.sothanaphan\">Nat Sothanaphan</a> ส่งข่าวว่ามาว่าเปเปอร์ [<a href=\"//epubs.siam.org/doi/abs/10.1137/1.9781611972986.7\">Martínez-Panholzer-Prodinger 2008</a>] ได้เขียนรายละเอียดการสร้างลำดับสุ่มโดยห้ามของอยู่ซ้ำที่เดิมในแง่มุมทางคณิตศาสตร์ไปเรียบร้อยแล้ว ซึ่งใจความสำคัญสามารถสรุปเป็นโค้ด Python ได้ดังนี้</p>\n\n<div><div><pre><code><span>import</span> <span>random</span>\n\n<span>def</span> <span>d</span><span>(</span><span>n</span><span>,</span> <span>memo</span><span>=</span><span>{</span><span>0</span><span>:</span> <span>1</span><span>,</span> <span>1</span><span>:</span> <span>0</span><span>}):</span>\n    <span>if</span> <span>n</span> <span>not</span> <span>in</span> <span>memo</span><span>:</span>\n        <span>memo</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>(</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>*</span> <span>(</span><span>d</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>+</span> <span>d</span><span>(</span><span>n</span><span>-</span><span>2</span><span>))</span>\n    <span>return</span> <span>memo</span><span>[</span><span>n</span><span>]</span>\n\n<span>def</span> <span>random_close_loop</span><span>(</span><span>r</span><span>):</span>\n    <span>return</span> <span>random</span><span>.</span><span>choices</span><span>([</span><span>True</span><span>,</span> <span>False</span><span>],</span> <span>weights</span><span>=</span><span>[</span><span>d</span><span>(</span><span>r</span><span>-</span><span>1</span><span>),</span> <span>d</span><span>(</span><span>r</span><span>)])[</span><span>0</span><span>]</span>\n\n<span>def</span> <span>derangement</span><span>(</span><span>n</span><span>):</span>\n    <span>if</span> <span>n</span> <span>==</span> <span>1</span><span>:</span>\n        <span>raise</span> <span>Exception</span><span>(</span><span>'can not do derangement with only 1 item'</span><span>)</span>\n    <span>hat</span> <span>=</span> <span>set</span><span>(</span><span>range</span><span>(</span><span>n</span><span>))</span>\n    <span>result</span> <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>n</span><span>))</span>\n    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>n</span><span>):</span>\n        <span>if</span> <span>i</span> <span>in</span> <span>hat</span><span>:</span>\n            <span>hat</span> <span>-=</span> <span>{</span><span>i</span><span>}</span>\n            <span>j</span> <span>=</span> <span>random</span><span>.</span><span>choice</span><span>(</span><span>list</span><span>(</span><span>avail</span><span>))</span>\n            <span>result</span><span>[</span><span>i</span><span>],</span> <span>result</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>result</span><span>[</span><span>j</span><span>],</span> <span>result</span><span>[</span><span>i</span><span>]</span>\n            <span>if</span> <span>random_close_loop</span><span>(</span><span>len</span><span>(</span><span>avail</span><span>)):</span>\n                <span>hat</span> <span>-=</span> <span>{</span><span>j</span><span>}</span>\n    <span>return</span> <span>result</span>\n</code></pre></div></div>\n\n<p>หรือเล่าเป็นขั้นตอนให้คนทั่วไปที่อยากลองเอาไปทดลองตามได้ว่า</p>\n\n<ol>\n  <li>เตรียมฉลากที่มีชื่อคนทุกคนที่จะเล่นแลกของขวัญใส่ไหจับฉลาก</li>\n  <li>ประธานจับฉลากหนึ่งใบ (ไม่ใส่คืน) เพื่อหาคนเริ่มต้นวงจับของขวัญ (หรือจบเกมเมื่อไม่เหลือฉลาก)</li>\n  <li>เอาของขวัญของคนที่มีชื่อบนฉลากมาวางบนแท่นของขวัญสำหรับการจบรอบวงย่อย</li>\n  <li>ให้คนที่มีชื่อบนฉลาก เป็นคนจับฉลากใบถัดไปเพื่อหาว่าเขาจะได้รับของขวัญจากใคร</li>\n  <li>คนจับฉลากในข้อที่ผ่านมารับของขวัญจากคนที่มีชื่อบนฉลากในข้อที่ผ่านมา</li>\n  <li>นับจำนวนคนที่เหลือที่ยังไม่ได้ของขวัญแล้วให้เป็นค่า $r$ (ไม่ต้องนับคนที่เพิ่งได้ของขวัญในข้อที่แล้ว)</li>\n  <li>คนที่มีชื่อบนฉลาก โยนเหรียญไบแอสที่มีน้ำหนักดังนี้\n    <ul>\n      <li>ออกก้อยด้วยน้ำหนัก $d(r)$ ไม่มีเหตุการณ์ที่น่าสนใจเกิดขึ้น แค่วนกลับไปทำข้อ 4. ไล่ลงมา</li>\n      <li>ออกหัวด้วยน้ำหนัก $d(r-1)$ ถือว่าได้ของขวัญจบวงย่อย ดังนั้นวนกลับไปทำข้อ 2. ไล่ลงมา</li>\n    </ul>\n  </li>\n  <li>ประธานกล่าวปิดงาน 😝</li>\n</ol>\n\n<blockquote>\n  <p><img src=\"/images/math/derangement-example.png\" /></p>\n\n  <p>ตัวอย่างการสุ่มแลกของขวัญที่ไม่มีใครได้ของตัวเองเมื่อ $n=6$ ผลลัพธ์นี้ได้วงย่อยของการแลกของขวัญเป็นจำนวนสองวง</p>\n</blockquote>\n\n<p>จากตัวอย่างการแลกของขวัญของกลุ่มคนหกคนในรูปข้างต้น อธิบายแต่ละขั้นตอนได้คือ</p>\n\n<ol>\n  <li>ประธานจับฉลากใบแรกเพื่อหาคนเริ่มต้นวงย่อยการแลกของขวัญ ซึ่งก็คือน้ำเงิน</li>\n  <li>น้ำเงินนำกล่องของขวัญตัวเองมาวางไว้บนแท่น พร้อมจับฉลากใบถัดไปและได้ชมพู</li>\n  <li>เพราะตอนนี้ $r=5$ ชมพูโยนเหรียญด้วยน้ำหนักหัว $d(4)$ ต่อน้ำหนักก้อย $d(5)$ และออกหัว</li>\n  <li>ชมพูได้รับของขวัญบนแท่น และปิดวงย่อยของการแลกของขวัญที่มีแค่สองคน 💏</li>\n  <li>ประธานจับฉลากอีกครั้งเพื่อหาคนเริ่มวงย่อยเพื่อแลกของขวัญรอบถัดไป ซึ่งคราวนี้ได้เหลือง</li>\n  <li>เหลืองเอาของขวัญตัวเองมาวางแท่น แล้วจับฉลากได้แดง</li>\n  <li>แดงโยนเหรียญด้วยน้ำหนักออกหัว $d(2)$ ต่อน้ำหนักออกก้อย $d(3)$ และออกก้อย</li>\n  <li>แดงอดได้ของขวัญบนแท่น จึงต้องจับฉลากและจับได้ฟ้า</li>\n  <li>เหลือสองคนสุดท้าย ฟ้าไม่จำเป็นต้องโยนเหรียญแล้ว เพราะน้ำหนักออกหัวคือ $d(1)=0$ จึงต้องจับฉลากแน่นอน และฉลากก็เหลือเพียงใบเดียวฟ้าจึงไม่มีทางเลือกนอกจากได้ของขวัญจากเขียว (ส่วนเขียวก็ไม่ต้องทำอะไรเพราะน้ำหนักโยนเหรียญออกก้อยคือ $d(1)=0$ ซึ่งก็คือต้องรับของขวัญบนแท่นนั่นเอง)</li>\n  <li>สรุปผลวงย่อยของการแลกของขวัญวงที่สอง ที่มีคนสี่คนแลกของขวัญกันเป็นวงตามรูป 👨‍👩‍👧‍👧</li>\n</ol>\n\n<p>อย่างไรก็ตาม เราคงไม่สามารถหาเหรียญที่ปรับน้ำหนักของแต่ละด้านอย่างละเอียดตามที่อัลกอริทึมต้องการได้ หรือถ้าจะย้ายไปคำนวณเชิงตัวเลขล้วนๆ ด้วยคอมพิวเตอร์เพียง ก็อาจนำมาซึ่งปัญหาเรื่องความเชื่อใจของมนุษย์ต่อเครื่องจักรและ RNGsus แทนอีก เช่นนี้แล้วเราควรทำอย่างไรดี?</p>\n\n<p>สังเกตว่าสำหรับแต่ละค่า $r$ ความน่าจะเป็นของการโยนเหรียญออกหัวคือ</p>\n\n\\[\\begin{array}{c|cc|cl}\nr &amp; \\text{weight H} &amp; \\text{weight T} &amp; P(\\text{toss H}) \\\\\n\\hline\n1 &amp; 1 &amp; 0 &amp; \\dfrac1{1+0} = 1 \\\\\n2 &amp; 0 &amp; 1 &amp; \\dfrac0{0+1} = 0 \\\\\n3 &amp; 1 &amp; 2 &amp; \\dfrac1{1+2} = \\dfrac13 \\\\\n4 &amp; 2 &amp; 9 &amp; \\dfrac2{2+9} = \\dfrac2{11} &amp; \\approx \\dfrac15 \\;\\;\\text{(error $9\\%$)} \\\\\n5 &amp; 9 &amp; 44 &amp; \\dfrac9{9+44} = \\dfrac9{53} &amp; \\approx \\dfrac16 \\;\\;\\text{(error $2\\%$)} \\\\\n6 &amp; 44 &amp; 265 &amp; \\dfrac{44}{44+265} = \\dfrac{44}{309} &amp; \\approx \\dfrac17 \\\\\n\\vdots &amp; &amp; &amp; \\vdots \\\\\nr &amp; d(r-1) &amp; d(r) &amp; \\dfrac{d(r-1)}{d(r-1)+d(r)} &amp; \\approx \\dfrac1{1+r}\n\\end{array}\\]\n\n<p>นอกจากที่ค่า $r$ น้อยมากๆ แล้ว จะเห็นว่าโอกาสออกหัวอยู่ที่ประมาณ $\\frac1{1+r}$ ซึ่งเราสามารถมาถึงข้อสรุปนี้ได้จาก สมการ $d(r) = \\left\\lceil \\frac{r!}e \\right\\rfloor$ ที่แสดงให้เห็นว่า</p>\n\n\\[\\frac{d(r-1)}{d(r-1) + d(r)}\n\\approx \\frac{(r-1)!}{(r-1)! + r!}\n= \\frac{(r-1)!}{(r-1)!(1+r)} = \\frac1{1+r}\\]\n\n<p>จากค่าประมาณอัตราส่วนสวยๆ เช่นนี้ หมายความว่าเราสามารถนำไพ่มาช่วยในการสุ่มได้! ซึ่งเป็นผลดีทางจิตวิทยาของมนุษย์มากกว่าเพราะมันทำให้เราเข้าใจความน่าจะเป็นได้แจ่มชัดกว่าการเห็นเพียงแค่ตัวเลข<sup><a href=\"#fn:1\">1</a></sup> และวิธีการใช้งานมันก็ง่ายดายยิ่งกว่าการหาเหรียญไบแอสมาโยนเป็นไหนๆ เช่นเมื่อ $r=6$ เราสามารถใช้ไพ่เพียงเจ็ดใบที่หนึ่งในนั้นเป็นหน้าโจ๊กเกอร์ได้เลย หากสับไพ่แล้วเปิดเจอโจ๊กเกอร์ก็คือการแลกของขวัญในวงย่อยวงนี้ถึงที่สิ้นสุดนั่นเอง</p>\n\n<p>ข้อสังเกตสำคัญคือกรณีที่ $r=4$ จะเห็นว่าแม้ค่าประมาณนั้นจะมีหน้าตาไล่เลขลดลงมาเรื่อยๆ มาอย่างสวยงาม แต่ความเพี้ยนของการประมาณที่จุดนี้สูงถึงเกือบ $10\\%$ ดังนั้นเราจึงควรใช้อัตราส่วน $2:9$ ที่หมายถึงมีโจ๊กเกอร์สองใบต่อไพ่อื่นๆ อีกเก้าใบถึงจะให้ผลลัพธ์การสุ่มที่แฟร์กว่า</p>\n\n<div><div><pre><code><span>def</span> <span>random_close_loop_approx</span><span>(</span><span>r</span><span>):</span>\n    <span>if</span> <span>r</span> <span>&gt;</span> <span>4</span><span>:</span>\n        <span>return</span> <span>random</span><span>.</span><span>choices</span><span>([</span><span>True</span><span>,</span> <span>False</span><span>],</span> <span>weights</span><span>=</span><span>[</span><span>1</span><span>,</span> <span>r</span><span>])[</span><span>0</span><span>]</span>\n    <span>if</span> <span>r</span> <span>==</span> <span>4</span><span>:</span>\n        <span>return</span> <span>random</span><span>.</span><span>choices</span><span>([</span><span>True</span><span>,</span> <span>False</span><span>],</span> <span>weights</span><span>=</span><span>[</span><span>2</span><span>,</span> <span>9</span><span>])[</span><span>0</span><span>]</span>\n    <span>if</span> <span>r</span> <span>==</span> <span>3</span><span>:</span>\n        <span>return</span> <span>random</span><span>.</span><span>choices</span><span>([</span><span>True</span><span>,</span> <span>False</span><span>],</span> <span>weights</span><span>=</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>])[</span><span>0</span><span>]</span>\n    <span>if</span> <span>r</span> <span>==</span> <span>2</span><span>:</span>\n        <span>return</span> <span>False</span>\n    <span>if</span> <span>r</span> <span>==</span> <span>1</span><span>:</span>\n        <span>return</span> <span>True</span>\n    <span>raise</span> <span>KeyError</span><span>(</span><span>'undefined behavior'</span><span>)</span>\n</code></pre></div></div>\n\n<p>แล้วทำไมถึงต้องมีการสุ่มเพื่อปิดวงเช่นนี้ด้วยหละ? ย้อนกลับไปตีความการสร้างคำตอบจากสมการเวียนเกิดเมื่อเพิ่มของชิ้นที่ $k$ เข้าไป จะเห็นว่า</p>\n\n\\[d(k) = (k-1) \\Big( \\underbrace{d(k-1)}_\\text{EXISTS} + \\underbrace{d(k-2)}_\\text{CREATE} \\Big)\\]\n\n<ul>\n  <li><strong>EXISTS</strong> อาจจะมีวงย่อยมาก่อนกี่วงก็ได้ แล้วของชิ้นที่ $k$ เข้าไปแทรกในวงย่อยวงใดวงหนึ่งที่เคยมี</li>\n  <li><strong>CREATE</strong> สร้างวงย่อยใหม่ซึ่งมีของเพียงสองชิ้นพอดี คือชิ้นที่ $k$ กับอีกชิ้นที่มาก่อน $k$ ที่ถูกเลือกมาอย่างสุ่ม (อย่างไรก็ตาม เมื่อใส่ของชิ้นหลังจาก $k$ ไปเรื่อยๆ วงนี้อาจถูกขยายขนาดทีหลังได้)</li>\n</ul>\n\n<p>แต่สิ่งที่อัลกอริทึมสุ่มลำดับไม่ซ้ำที่เดิมทำนั้น จะเปลี่ยนเป็นวิ่งสวนทางโดยลดค่า $k$ ลงเรื่อยๆ แทน ดังนั้นเราต้องตีความการ <strong>CREATE</strong> กลับด้าน โดยหมายความว่าหลังจากพิจารณาของชิ้นที่ $k$ ออกมาแล้ว เราจะเหลือของอยู่ $r=k-1$ ชิ้น และเราจะถามต่อทันทีว่าของชิ้นต่อไปที่จะเอาออกควรย้อนกลับไป<strong>ปิด</strong>วงย่อยที่มีของชิ้นที่ $k$ หรือเปล่า ซึ่งสัดส่วนจำนวนเหตุการณ์ที่เกิดก็คือ $\\frac{\\text{#CREATE}}{\\text{#CREATE}+\\text{#EXISTS}}$ นั่นเอง</p>\n\n<p>หวังว่าจะได้ทริกดีๆ ไว้ทำให้ปาร์ตี้แลกของขวัญสนุกยิ่งขึ้นนะ 🃏</p>\n\n<div>\n  <ol>\n    <li>\n      <p><a href=\"//youtu.be/dwI5b-wRLic\">วิดีโอ</a>จาก GMTK นาทีที่ 15:50-17:07 <a href=\"#fnref:1\">↩</a></p>\n    </li>\n  </ol>\n</div>","author":"","siteTitle":"neizod's speculation","siteHash":"939338c5557b1743f2c128736c6006e145dcabc81da9970f1c0dc8ae2feb0830","entryHash":"e986b7fac215c1f7044b460482d4261073765baa45855829be93a852b257ccc5","category":"Thai"}