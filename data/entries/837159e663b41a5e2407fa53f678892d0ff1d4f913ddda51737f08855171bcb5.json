{"title":"Building A Stocks Price Notifier App Using React, Apollo GraphQL And Hasura","link":"https://smashingmagazine.com/2020/12/stocks-price-notifier-app-react-apollo-graphql-hasura/","date":1608548400000,"content":"<p>The concept of getting notified when the event of your choice has occurred has become popular compared to being glued onto the continuous stream of data to find that particular occurrence yourself. People prefer to get relevant emails/messages when their preferred event has occurred as opposed to being hooked on the screen to wait for that event to happen. The events-based terminology is also quite common in the world of software. </p>\n<p><em>How awesome would that be if you could get the updates of the price of your favorite stock on your phone?</em> </p>\n<p>In this article, we’re going to build a <em>Stocks Price Notifier</em> application by using React, Apollo GraphQL, and Hasura GraphQL engine. We’re going to start the project from a <a href=\"https://reactjs.org/docs/create-a-new-react-app.html\"><code>create-react-app</code></a> boilerplate code and would build everything ground up. We’ll learn how to set up the database tables, and events on the Hasura console. We’ll also learn how to wire up Hasura’s events to get stock price updates using web-push notifications.</p>\n<p>Here’s a quick glance at what we would be building:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db8ddfc8-2f91-41ec-8153-6108153da4db/11-stocks-price-notifier-app-react-apollo-graphql-hasura.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/db8ddfc8-2f91-41ec-8153-6108153da4db/11-stocks-price-notifier-app-react-apollo-graphql-hasura.gif\" /></a>Stock Price Notifier Application\n\n<p>Let’s get going!</p>\n<h3>An Overview Of What This Project Is About</h3>\n<p>The stocks data (including metrics such as <em>high</em>, <em>low</em>, <em>open</em>, <em>close</em>, <em>volume</em>) would be stored in a Hasura-backed Postgres database. The user would be able to subscribe to a particular stock based on some value or he can opt to get notified every hour. The user will get a web-push notification once his subscription criteria are fulfilled. </p>\n<p>This looks like a lot of stuff and there would obviously be some open questions on how we’ll be building out these pieces.</p>\n<p>Here’s a plan on how we would accomplish this project in four steps:</p>\n<ol>\n  <li><strong>Fetching the stocks data using a NodeJs script</strong><br />We’ll start by fetching the stock data using a simple NodeJs script from one of the providers of stocks API — <a href=\"https://www.alphavantage.co/\">Alpha Vantage</a>. This script will fetch the data for a particular stock in intervals of 5mins. The response of the API includes <em>high</em>, <em>low</em>, <em>open</em>, <em>close</em> and <em>volume</em>. This data will be then be inserted in the Postgres database that is integrated with the Hasura back-end.</li>\n  <li><strong>Setting up The Hasura GraphQL engine</strong><br />We’ll then set-up some tables on the Postgres database to record data points. Hasura automatically generates the GraphQL schemas, queries, and mutations for these tables.</li>\n  <li><strong>Front-end using React and Apollo Client</strong><br />The next step is to integrate the GraphQL layer using the Apollo client and Apollo Provider (the GraphQL endpoint provided by Hasura). The data-points will be shown as charts on the front-end. We’ll also build the subscription options and will fire corresponding mutations on the GraphQL layer.</li>\n  <li><strong>Setting up Event/Scheduled triggers</strong><br />Hasura provides an excellent tooling around triggers. We’ll be adding event &amp; scheduled triggers on the stocks data table. These triggers will be set if the user is interested in getting a notification when the stock prices reach a particular value (event trigger). The user can also opt for getting a notification of a particular stock every hour (scheduled trigger).</li>\n</ol>\n\n<p>Now that the plan is ready, let’s put it into action!</p>\n<p><em><a href=\"https://github.com/ankitamasand/stocks-price-notifier\">Here’s the GitHub repository</a> for this project. If you get lost anywhere in the code below, refer to this repository and get back to speed!</em></p>\n<h3>Fetching The Stocks Data Using A NodeJs Script</h3>\n<p>This is not that complicated as it sounds! We’ll have to write a function that fetches data using the <a href=\"https://www.alphavantage.co\">Alpha Vantage</a> endpoint and this fetch call should be fired in an interval of <em>5 mins</em> (You guessed it right, we'll have to put this function call in <code>setInterval</code>).</p>\n<p>If you’re still wondering what Alpha Vantage is and just want to get this out of your head before hopping onto the coding part, then here it is:</p>\n<blockquote><a href=\"https://www.alphavantage.co/#about\">Alpha Vantage Inc.</a> is a leading provider of free APIs for realtime and historical data on stocks, forex (FX), and digital/cryptocurrencies.</blockquote>\n\n<p>We would be using <a href=\"https://www.alphavantage.co/documentation/#intraday\">this</a> endpoint to get the required metrics of a particular stock. This API expects an API key as one of the parameters. You can get your free API key from <a href=\"https://www.alphavantage.co/support/#api-key\">here</a>. We’re now good to get onto the interesting bit — let’s start writing some code!</p>\n<h4>Installing Dependencies</h4>\n<p>Create a <code>stocks-app</code> directory and create a <code>server</code> directory inside it. Initialize it as a node project using <code>npm init</code> and then install these dependencies:</p>\n<pre><code>npm i isomorphic-fetch pg nodemon --save</code></pre>\n\n<p>These are the only three dependencies that we’d need to write this script of fetching the stock prices and storing them in the Postgres database.</p>\n<p>Here’s a brief explanation of these dependencies:</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/isomorphic-fetch\"><code>isomorphic-fetch</code></a><br />It makes it easy to use <code>fetch</code> isomorphically (in the same form) on both the client and the server. </li>\n<li><a href=\"https://www.npmjs.com/package/pg\"><code>pg</code></a><br />It is a non-blocking PostgreSQL client for NodeJs.</li>\n<li><a href=\"https://www.npmjs.com/package/nodemon\"><code>nodemon</code></a><br />It automatically restarts the server on any file changes in the directory.</li>\n</ul>\n<h5>Setting up the configuration</h5>\n<p>Add a <code>config.js</code> file at the root level. Add the below snippet of code in that file for now:</p>\n<pre><code>const config = {\n  user: '&lt;DATABASE_USER&gt;',\n  password: '&lt;DATABASE_PASSWORD&gt;',\n  host: '&lt;DATABASE_HOST&gt;',\n  port: '&lt;DATABASE_PORT&gt;',\n  database: '&lt;DATABASE_NAME&gt;',\n  ssl: '&lt;IS_SSL&gt;',\n  apiHost: 'https://www.alphavantage.co/',\n};\n\nmodule.exports = config;</code></pre>\n\n<p>The <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>, <code>database</code>, <code>ssl</code> are related to the Postgres configuration. We’ll come back to edit this while we set up the Hasura engine part!</p>\n<h4>Initializing The Postgres Connection Pool For Querying The Database</h4>\n<p>A <code>connection pool</code> is a common term in computer science and you’ll often hear this term while dealing with databases. </p>\n<p>While querying data in databases, you’ll have to first establish a connection to the database. This connection takes in the database credentials and gives you a hook to query any of the tables in the database.</p>\n<p><strong>Note</strong>: <em>Establishing database connections is costly and also wastes significant resources. A connection pool caches the database connections and re-uses them on succeeding queries. If all the open connections are in use, then a new connection is established and is then added to the pool.</em></p>\n<p>Now that it is clear what the connection pool is and what is it used for, let’s start by creating an instance of the <code>pg</code> connection pool for this application:</p>\n<p>Add <code>pool.js</code> file at the root level and create a pool instance as:</p>\n<pre><code>const { Pool } = require('pg');\nconst config = require('./config');\n\nconst pool = new Pool({\n  user: config.user,\n  password: config.password,\n  host: config.host,\n  port: config.port,\n  database: config.database,\n  ssl: config.ssl,\n});\n\nmodule.exports = pool;</code></pre>\n\n<p>The above lines of code create an instance of <code>Pool</code> with the configuration options as set in the config file. We’re yet to complete the config file but there won’t be any changes related to the configuration options. </p>\n<p>We’ve now set the ground and are ready to start making some API calls to the Alpha Vantage endpoint. </p>\n<p>Let’s get onto the interesting bit! </p>\n<h4>Fetching The Stocks Data</h4>\n<p>In this section, we’ll be fetching the stock data from the Alpha Vantage endpoint. Here’s the <code>index.js</code> file:</p>\n<div>\n<pre><code>const fetch = require('isomorphic-fetch');\nconst getConfig = require('./config');\nconst { insertStocksData } = require('./queries');\n\nconst symbols = [\n  'NFLX',\n  'MSFT',\n  'AMZN',\n  'W',\n  'FB'\n];\n\n(function getStocksData () {\n\n  const apiConfig = getConfig('apiHostOptions');\n  const { host, timeSeriesFunction, interval, key } = apiConfig;\n\n  symbols.forEach((symbol) =&gt; {\n    fetch(<code>${host}query/?function=${timeSeriesFunction}&amp;symbol=${symbol}&amp;interval=${interval}&amp;apikey=${key}</code>)\n    .then((res) =&gt; res.json())\n    .then((data) =&gt; {\n      const timeSeries = data['Time Series (5min)'];\n      Object.keys(timeSeries).map((key) =&gt; {\n        const dataPoint = timeSeries[key];\n        const payload = [\n          symbol,\n          dataPoint['2. high'],\n          dataPoint['3. low'],\n          dataPoint['1. open'],\n          dataPoint['4. close'],\n          dataPoint['5. volume'],\n          key,\n        ];\n        insertStocksData(payload);\n      });\n    });\n  })\n})()</code></pre>\n</div>\n\n<p>For the purpose of this project, we’re going to query prices only for these stocks — NFLX (Netflix), MSFT (Microsoft), AMZN (Amazon), W (Wayfair), FB (Facebook).</p>\n<p>Refer <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/server/config.js\">this</a> file for the config options. The IIFE <code>getStocksData</code> function is not doing much! It loops through these symbols and queries the Alpha Vantage endpoint <code>${host}query/?function=${timeSeriesFunction}&amp;symbol=${symbol}&amp;interval=${interval}&amp;apikey=${key}</code> to get the metrics for these stocks. </p>\n<p>The <code>insertStocksData</code> function puts these data points in the Postgres database. Here’s the <code>insertStocksData</code> function:</p>\n<div>\n<pre><code>const insertStocksData = async (payload) =&gt; {\n  const query = 'INSERT INTO stock_data (symbol, high, low, open, close, volume, time) VALUES ($1, $2, $3, $4, $5, $6, $7)';\n  pool.query(query, payload, (err, result) =&gt; {\n    console.log('result here', err);\n  });\n};</code></pre>\n</div>\n\n<p>This is it! We have fetched data points of the stock from the Alpha Vantage API and have written a function to put these in the Postgres database in the <code>stock_data</code> table. There is just one missing piece to make all this work! We’ve to populate the correct values in the config file. We’ll get these values after setting up the Hasura engine. Let’s get to that right away!</p>\n<p>Please refer to the <a href=\"https://github.com/ankitamasand/stocks-price-notifier/tree/main/server\"><code>server</code></a> directory for the complete code on fetching data points from Alpha Vantage endpoint and populating that to the Hasura Postgres database.</p>\n<p><em>If this approach of setting up connections, configuration options, and inserting data using the raw query looks a bit difficult, please don’t worry about that! We’re going to learn how to do all this the easy way with a GraphQL mutation once the Hasura engine is set up!</em></p>\n<h3>Setting Up The Hasura GraphQL Engine</h3>\n<p>It is really simple to set up the Hasura engine and get up and running with the GraphQL schemas, queries, mutations, subscriptions, event triggers, and much more!</p>\n<p>Click on <a href=\"https://hasura.io/\">Try Hasura</a> and enter the project name:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f581d459-24a5-4195-ab4c-8766d8198e2e/1-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>I’m using the Postgres database hosted on Heroku. Create a database on Heroku and link it to this project. You should then be all set to experience the power of query-rich Hasura console.</p>\n<p>Please copy the Postgres DB URL that you’ll get after creating the project. We’ll have to put this in the config file.</p>\n<p>Click on Launch Console and you’ll be redirected to this view:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1bc259c6-c80a-4bbe-8e9f-fee6bef97dff/6-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>Let’s start building the table schema that we’d need for this project.</p>\n<h4>Creating Tables Schema On The Postgres Database</h4>\n<p>Please go to the Data tab and click on Add Table! Let’s start creating some of the tables:</p>\n<h5><code>symbol</code> table</h5>\n<p>This table would be used for storing the information of the symbols. For now, I’ve kept two fields here — <code>id</code> and <code>company</code>. The field <code>id</code> is a primary key and <code>company</code> is of type <code>varchar</code>. Let’s add some of the symbols in this table:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7eac955e-a99e-4667-b694-8119bb6d1d09/15-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<h5><code>stock_data</code> table</h5>\n<p>The <code>stock_data</code> table stores <code>id</code>, <code>symbol</code>, <code>time</code> and the metrics such as <code>high</code>, <code>low</code>, <code>open</code>, <code>close</code>, <code>volume</code>. The NodeJs script that we wrote earlier in this section will be used to populate this particular table.</p>\n<p>Here’s how the table looks like:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d32c33e6-8d91-4900-aff3-c44791777688/12-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>Neat! Let’s get to the other table in the database schema!</p>\n<h5><code>user_subscription</code> table</h5>\n<p>The <code>user_subscription</code> table stores the subscription object against the user Id. This subscription object is used for sending web-push notifications to the users. We’ll learn later in the article how to generate this subscription object.</p>\n<p>There are two fields in this table — <code>id</code> is the primary key of type <code>uuid</code> and subscription field is of type <code>jsonb</code>.</p>\n<h5><code>events</code> table</h5>\n<p>This is the important one and is used for storing the notification event options. When a user opts-in for the price updates of a particular stock, we store that event information in this table. This table contains these columns:</p>\n<ul>\n<li><code>id</code>: is a primary key with the auto-increment property.</li>\n<li><code>symbol</code>: is a text field.</li>\n<li><code>user_id</code>: is of type <code>uuid</code>.</li>\n<li><code>trigger_type</code>: is used for storing the event trigger type — <code>time/event</code>.</li>\n<li><code>trigger_value</code>: is used for storing the trigger value. For example, if a user has opted in for price-based event trigger — he wants updates if the price of the stock has reached 1000, then the <code>trigger_value</code> would be 1000 and the <code>trigger_type</code> would be <code>event</code>. </li>\n</ul>\n<p>These are all the tables that we'd need for this project. We also have to set up relations among these tables to have a smooth data flow and connections. Let’s do that!</p>\n<h5>Setting up relations among tables</h5>\n<p>The <code>events</code> table is used for sending web-push notifications based on the event value. So, it makes sense to connect this table with the <code>user_subscription</code> table to be able to send push notifications on the subscriptions stored in this table.</p>\n<pre><code>events.user_id  → user_subscription.id</code></pre>\n\n<p>The <code>stock_data</code> table is related to the symbols table as:</p>\n<pre><code>stock_data.symbol  → symbol.id</code></pre>\n\n<p>We also have to construct some relations on the <code>symbol</code> table as:</p>\n<pre><code>stock_data.symbol  → symbol.id\nevents.symbol  → symbol.id</code></pre>\n\n<p>We’ve now created the required tables and also established the relations among them! Let’s switch to the <code>GRAPHIQL</code> tab on the console to see the magic!</p>\n<p>Hasura has already set up the GraphQL queries based on these tables:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7c71324a-8639-4952-a028-5a76e3d7d813/5-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>It is plainly simple to query on these tables and you can also apply any of these filters/properties (<code>distinct_on</code>, <code>limit</code>, <code>offset</code>, <code>order_by</code>, <code>where</code>) to get the desired data.</p>\n<p>This all looks good but we have still not connected our server-side code to the Hasura console. Let’s complete that bit!</p>\n<h4>Connecting The NodeJs Script To The Postgres Database</h4>\n<p>Please put the required options in the <code>config.js</code> file in the <code>server</code> directory as:</p>\n<pre><code>const config = {\n  databaseOptions: {\n    user: '&lt;DATABASE_USER&gt;',\n    password: '&lt;DATABASE_PASSWORD&gt;',\n    host: '&lt;DATABASE_HOST&gt;',\n    port: '&lt;DATABASE_PORT&gt;',\n    database: '&lt;DATABASE_NAME&gt;',\n    ssl: true,\n  },\n  apiHostOptions: {\n    host: 'https://www.alphavantage.co/',\n    key: '&lt;API_KEY&gt;',\n    timeSeriesFunction: 'TIME_SERIES_INTRADAY',\n    interval: '5min'\n  },\n  graphqlURL: '&lt;GRAPHQL_URL&gt;'\n};\n\nconst getConfig = (key) =&gt; {\n  return config[key];\n};\n\nmodule.exports = getConfig;</code></pre>\n\n<p>Please put these options from the database string that was generated when we created the Postgres database on Heroku. </p>\n<p>The <code>apiHostOptions</code> consists of the API related options such as <code>host</code>, <code>key</code>, <code>timeSeriesFunction</code> and <code>interval</code>. </p>\n<p>You’ll get the <code>graphqlURL</code> field in the <em>GRAPHIQL</em> tab on the Hasura console.</p>\n<p>The <code>getConfig</code> function is used for returning the requested value from the config object. We’ve already used this in <code>index.js</code> in the <code>server</code> directory.</p>\n<p>It’s time to run the server and populate some data in the database. I’ve added one script in <code>package.json</code> as:</p>\n<pre><code>\"scripts\": {\n    \"start\": \"nodemon index.js\"\n}</code></pre>\n\n<p>Run <code>npm start</code> on the terminal and the data points of the symbols array in <code>index.js</code> should be populated in the tables.</p>\n<h4>Refactoring The Raw Query In The NodeJs Script To GraphQL Mutation</h4>\n<p>Now that the Hasura engine is set up, let’s see how easy can it be to call a mutation on the <code>stock_data</code> table.</p>\n<p>The function <code>insertStocksData</code> in <code>queries.js</code> uses a raw query: </p>\n<div>\n<pre><code>const query = 'INSERT INTO stock_data (symbol, high, low, open, close, volume, time) VALUES ($1, $2, $3, $4, $5, $6, $7)';</code></pre>\n</div>\n\n<p>Let’s refactor this query and use mutation powered by the Hasura engine. Here’s the refactored <code>queries.js</code> in the server directory:</p>\n<div>\n<pre><code>\nconst { createApolloFetch } = require('apollo-fetch');\nconst getConfig = require('./config');\n\nconst GRAPHQL_URL = getConfig('graphqlURL');\nconst fetch = createApolloFetch({\n  uri: GRAPHQL_URL,\n});\n\nconst insertStocksData = async (payload) =&gt; {\n  const insertStockMutation = await fetch({\n    query: <code>mutation insertStockData($objects: [stock_data_insert_input!]!) {\n      insert_stock_data (objects: $objects) {\n        returning {\n          id\n        }\n      }\n    }</code>,\n    variables: {\n      objects: payload,\n    },\n  });\n  console.log('insertStockMutation', insertStockMutation);\n};\n\nmodule.exports = {\n  insertStocksData\n}</code></pre>\n</div>\n\n<p><strong>Please note:</strong> We’ve to add <code>graphqlURL</code> in the <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/server/config.js\"><code>config.js</code></a> file.</p>\n<p>The <code>apollo-fetch</code> module returns a fetch function that can be used to query/mutate the date on the GraphQL endpoint. Easy enough, right?</p>\n<p>The only change that we’ve to do in <code>index.js</code> is to return the stocks object in the format as required by the <code>insertStocksData</code> function. Please check out <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/server/index2.js\"><code>index2.js</code></a> and <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/server/queries2.js\"><code>queries2.js</code></a> for the complete code with this approach.</p>\n<p>Now that we’ve accomplished the data-side of the project, let’s move onto the front-end bit and build some interesting components!</p>\n<p><strong>Note</strong>: <em>We don’t have to keep the database configuration options with this approach!</em></p>\n<h3>Front-end Using React And Apollo Client</h3>\n<p>The front-end project is in the <a href=\"https://github.com/ankitamasand/stocks-price-notifier\">same</a> repository and is created using the <a href=\"https://github.com/facebook/create-react-app\"><code>create-react-app</code></a> package. The service worker generated using this package supports assets caching but it doesn’t allow more customizations to be added to the service worker file. There are already <a href=\"https://github.com/facebook/create-react-app/pull/5369\">some</a> open issues to add support for custom service worker options. There are ways to get away with this problem and add support for a custom service worker. </p>\n<p>Let’s start by looking at the structure for the front-end project:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2cbd4b54-b527-47f6-98e8-e6b4a511d739/10-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>Please check the <code>src</code> directory! Don’t worry about the service worker related files for now. We’ll learn more about these files later in this section. The rest of the project structure looks simple. The <code>components</code> folder will have the components (Loader, Chart); the <code>services</code> folder contains some of the helper functions/services used for transforming objects in the required structure; <code>styles</code> as the name suggests contains the sass files used for styling the project; <code>views</code> is the main directory and it contains the view layer components.</p>\n<p>We’d need just two view components for this project — The Symbol List and the Symbol Timeseries. We’ll build the time-series using the Chart component from the highcharts library. Let’s start adding code in these files to build up the pieces on the front-end!</p>\n<h4>Installing Dependencies</h4>\n<p>Here’s the list of dependencies that we’ll need:</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/apollo-boost\"><code>apollo-boost</code></a><br />Apollo boost is a zero-config way to start using Apollo Client. It comes bundled with the default configuration options.</li>\n<li><a href=\"https://www.npmjs.com/package/reactstrap\"><code>reactstrap</code></a> and <a href=\"https://www.npmjs.com/package/bootstrap\"><code>bootstrap</code></a><br />The components are built using these two packages.</li>\n<li><a href=\"https://www.npmjs.com/package/graphql\"><code>graphql</code></a> and <a href=\"https://www.npmjs.com/package/graphql-type-json\"><code>graphql-type-json</code></a><br /><code>graphql</code> is a required dependency for using <code>apollo-boost</code> and <code>graphql-type-json</code> is used for supporting the <code>json</code> datatype being used in the GraphQL schema.</li>\n<li><p><a href=\"https://www.npmjs.com/package/highcharts\"><code>highcharts</code></a> and <a href=\"https://www.npmjs.com/package/highcharts-react-official\"><code>highcharts-react-official</code></a><br />And these two packages will be used for building the chart:</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/node-sass\"><code>node-sass</code></a><br />This is added for supporting sass files for styling.</p>\n</li>\n<li><a href=\"https://www.npmjs.com/package/uuid\"><code>uuid</code></a><br />This package is used for generating strong random values.</li>\n</ul>\n<p>All of these dependencies will make sense once we start using them in the project. Let’s get onto the next bit!</p>\n<h4>Setting Up Apollo Client</h4>\n<p>Create a <code>apolloClient.js</code> inside the <code>src</code> folder as:</p>\n<pre><code>import ApolloClient from 'apollo-boost';\n\nconst apolloClient = new ApolloClient({\n  uri: '&lt;HASURA_CONSOLE_URL&gt;'\n});\n\nexport default apolloClient;</code></pre>\n\n<p>The above code instantiates ApolloClient and it takes in <code>uri</code> in the config options. The <code>uri</code> is the URL of your Hasura console. You’ll get this <code>uri</code> field on the <code>GRAPHIQL</code> tab in the <em>GraphQL Endpoint</em> section. </p>\n<p>The above code looks simple but it takes care of the main part of the project! It connects the GraphQL schema built on Hasura with the current project.</p>\n<p>We also have to pass this apollo client object to <code>ApolloProvider</code> and wrap the root component inside <code>ApolloProvider</code>. This will enable all the nested components inside the main component to use <code>client</code> prop and fire queries on this client object.</p>\n<p>Let’s modify the <code>index.js</code> file as:</p>\n<pre><code>const Wrapper = () =&gt; {\n/* some service worker logic - ignore for now */\n  const [insertSubscription] = useMutation(subscriptionMutation);\n  useEffect(() =&gt; {\n    serviceWorker.register(insertSubscription);\n  }, [])\n  /* ignore the above snippet */\n  return &lt;App /&gt;;\n}\n\nReactDOM.render(\n  &lt;ApolloProvider client={apolloClient}&gt;\n    &lt;Wrapper /&gt;\n  &lt;/ApolloProvider&gt;,\n  document.getElementById('root')\n);</code></pre>\n\n<p>Please ignore the <code>insertSubscription</code> related code. We’ll understand that in detail later. The rest of the code should be simple to get around. The <code>render</code> function takes in the root component and the elementId as parameters. Notice <code>client</code> (ApolloClient instance) is being passed as a prop to <code>ApolloProvider</code>. You can check the complete <code>index.js</code> file <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/index.js\">here</a>.</p>\n<h4>Setting Up The Custom Service Worker</h4>\n<p>A Service worker is a JavaScript file that has the capability to intercept network requests. It is used for querying the cache to check if the requested asset is already present in the cache instead of making a ride to the server. Service workers are also used for sending web-push notifications to the subscribed devices. </p>\n<p>We’ve to send web-push notifications for the stock price updates to the subscribed users. Let’s set the ground and build this service worker file!</p>\n<p>The <code>insertSubscription</code> related snipped in the <code>index.js</code> file is doing the work of registering service worker and putting the subscription object in the database using <code>subscriptionMutation</code>. </p>\n<p>Please refer <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/queries.js\">queries.js</a> for all the queries and mutations being used in the project.</p>\n<p><code>serviceWorker.register(insertSubscription);</code> invokes the <code>register</code> function written in the <code>serviceWorker.js</code> file. Here it is:</p>\n<pre><code>export const register = (insertSubscription) =&gt; {\n  if ('serviceWorker' in navigator) {\n    const swUrl = `${process.env.PUBLIC_URL}/serviceWorker.js`\n    navigator.serviceWorker.register(swUrl)\n      .then(() =&gt; {\n        console.log('Service Worker registered');\n        return navigator.serviceWorker.ready;\n      })\n      .then((serviceWorkerRegistration) =&gt; {\n        getSubscription(serviceWorkerRegistration, insertSubscription);\n        Notification.requestPermission();\n      })\n  }\n}</code></pre>\n\n<p>The above function first checks if <code>serviceWorker</code> is supported by the browser and then registers the service worker file hosted on the URL <code>swUrl</code>. We’ll check this file in a moment!</p>\n<p>The <code>getSubscription</code> function does the work of getting the subscription object using the <code>subscribe</code> method on the <code>pushManager</code> object. This subscription object is then stored in the <code>user_subscription</code> table against a userId. Please note that the userId is being generated using the <code>uuid</code> function. Let’s check out the <code>getSubscription</code> function:</p>\n<div>\n<pre><code>const getSubscription = (serviceWorkerRegistration, insertSubscription) =&gt; {\n  serviceWorkerRegistration.pushManager.getSubscription()\n    .then ((subscription) =&gt; {\n      const userId = uuidv4();\n      if (!subscription) {\n        const applicationServerKey = urlB64ToUint8Array('&lt;APPLICATION_SERVER_KEY&gt;')\n        serviceWorkerRegistration.pushManager.subscribe({\n          userVisibleOnly: true,\n          applicationServerKey\n        }).then (subscription =&gt; {\n          insertSubscription({\n            variables: {\n              userId,\n              subscription\n            }\n          });\n          localStorage.setItem('serviceWorkerRegistration', JSON.stringify({\n            userId,\n            subscription\n          }));\n        })\n      }\n    })\n}</code></pre>\n</div>\n\n<p>You can check <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/serviceWorker.js\"><code>serviceWorker.js</code></a> file for the complete code!</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfc82ced-d5f3-465f-ad40-8bd54628eb1c/8-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p><code>Notification.requestPermission()</code> invoked this popup that asks the user for the permission for sending notifications. Once the user clicks on Allow, a subscription object is generated by the push service. We’re storing that object in the localStorage as:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/18c44c45-e3be-44c1-802e-b1005b38398d/16-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>The field <code>endpoint</code> in the above object is used for identifying the device and the server uses this endpoint to send web push notifications to the user. </p>\n<p>We have done the work of initializing and registering the service worker. We also have the subscription object of the user! This is working all good because of the <code>serviceWorker.js</code> file present in the <code>public</code> folder. Let’s now set up the service worker to get things ready!</p>\n<p>This is a bit difficult topic but let’s get it right! As mentioned earlier, the <code>create-react-app</code> utility doesn't support customizations by default for the service worker. We can achieve customer service worker implementation using <a href=\"https://developers.google.com/web/tools/workbox/modules/workbox-build\"><code>workbox-build</code></a> module. </p>\n<p>We also have to make sure that the default behavior of pre-caching files is intact. We’ll modify the part where the service worker gets build in the project. And, workbox-build helps in achieving exactly that! Neat stuff! Let’s keep it simple and list down all that we have to do to make the custom service worker work:</p>\n<ul>\n<li>Handle the pre-caching of assets using <code>workboxBuild</code>.</li>\n<li>Create a service worker template for caching assets.</li>\n<li>Create <code>sw-precache-config.js</code> file to provide custom configuration options.</li>\n<li>Add the build service worker script in the build step in <code>package.json</code>.</li>\n</ul>\n<p>Don’t worry if all this sounds confusing! The article doesn’t focus on explaining the semantics behind each of these points. We’ve to focus on the implementation part for now! I’ll try to cover the reasoning behind doing all the work to make a custom service worker in another article.</p>\n<p>Let’s create two files <code>sw-build.js</code> and <code>sw-custom.js</code> in the <code>src</code> directory. Please refer to the links to these files and add the code to your project.</p>\n<p>Let’s now create <code>sw-precache-config.js</code> file at the root level and add the following code in that file:</p>\n<pre><code>module.exports = {\n  staticFileGlobs: [\n    'build/static/css/**.css',\n    'build/static/js/**.js',\n    'build/index.html'\n  ],\n  swFilePath: './build/serviceWorker.js',\n  stripPrefix: 'build/',\n  handleFetch: false,\n  runtimeCaching: [{\n    urlPattern: /this\\\\.is\\\\.a\\\\.regex/,\n    handler: 'networkFirst'\n  }]\n}</code></pre>\n\n<p>Let’s also modify the <code>package.json</code> file to make room for building the custom service worker file:</p>\n<p>Add these statements in the <code>scripts</code> section:</p>\n<div>\n<pre><code>\"build-sw\": \"node ./src/sw-build.js\",\n\"clean-cra-sw\": \"rm -f build/precache-manifest.*.js &amp;&amp; rm -f build/service-worker.js\",</code></pre>\n</div>\n\n<p>And modify the <code>build</code> script as:</p>\n<div>\n<pre><code>\"build\": \"react-scripts build &amp;&amp; npm run build-sw &amp;&amp; npm run clean-cra-sw\",</code></pre>\n</div>\n\n<p>The setup is finally done! We now have to add a custom service worker file inside the <code>public</code> folder:</p>\n<pre><code>function showNotification (event) {\n  const eventData = event.data.json();\n  const { title, body } = eventData\n  self.registration.showNotification(title, { body });\n}\n\nself.addEventListener('push', (event) =&gt; {\n  event.waitUntil(showNotification(event));\n})</code></pre>\n\n<p>We’ve just added one <code>push</code> listener to listen to push-notifications being sent by the server. The function <code>showNotification</code> is used for displaying web push notifications to the user. </p>\n<p>This is it! We’re done with all the hard work of setting up a custom service worker to handle web push notifications. We’ll see these notifications in action once we build the user interfaces!</p>\n<p>We’re getting closer to building the main code pieces. Let’s now start with the first view!</p>\n<h4>Symbol List View</h4>\n<p>The <code>App</code> component being used in the previous section looks like this:</p>\n<pre><code>import React from 'react';\nimport SymbolList from './views/symbolList';\n\nconst App = () =&gt; {\n  return &lt;SymbolList /&gt;;\n};\n\nexport default App;</code></pre>\n\n<p>It is a simple component that returns <code>SymbolList</code> view and <code>SymbolList</code> does all the heavy-lifting of displaying symbols in a neatly tied user interface.</p>\n<p>Let’s look at <code>symbolList.js</code> inside the <code>views</code> folder:</p>\n<p>Please refer to the file <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/views/symbolList.js\">here</a>!</p>\n<p>The component returns the results of the <code>renderSymbols</code> function. And, this data is being fetched from the database using the <code>useQuery</code> hook as:</p>\n<div>\n<pre><code>const { loading, error, data } = useQuery(symbolsQuery, {variables: { userId }});</code></pre>\n</div>\n\n<p>The <code>symbolsQuery</code> is defined as:</p>\n<pre><code>export const symbolsQuery = gql`\n  query getSymbols($userId: uuid) {\n    symbol {\n      id\n      company\n      symbol_events(where: {user_id: {_eq: $userId}}) {\n        id\n        symbol\n        trigger_type\n        trigger_value\n        user_id\n      }\n      stock_symbol_aggregate {\n        aggregate {\n          max {\n            high\n            volume\n          }\n          min {\n            low\n            volume\n          }\n        }\n      }\n    }\n  }\n`;</code></pre>\n\n<p>It takes in <code>userId</code> and fetches the subscribed events of that particular user to display the correct state of the notification icon (bell icon that is being displayed along with the title). The query also fetches the max and min values of the stock. Notice the use of <code>aggregate</code> in the above query. <a href=\"https://hasura.io/docs/1.0/graphql/core/queries/aggregation-queries.html\">Hasura's Aggregation queries</a> do the work behind the scenes to fetch the aggregate values like <code>count</code>, <code>sum</code>, <code>avg</code>, <code>max</code>, <code>min</code>, etc.</p>\n<p>Based on the response from the above GraphQL call, here’s the list of cards that are displayed on the front-end:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/48a1f714-14b3-41ce-999a-2087cbd83b42/13-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>The card HTML structure looks something like this:</p>\n<div>\n<pre><code>&lt;div key={id}&gt;\n  &lt;div className=\"card-container\"&gt;\n    &lt;Card&gt;\n      &lt;CardBody&gt;\n        &lt;CardTitle className=\"card-title\"&gt;\n          &lt;span className=\"company-name\"&gt;{company}  &lt;/span&gt;\n            &lt;Badge color=\"dark\" pill&gt;{id}&lt;/Badge&gt;\n            &lt;div className={classNames({'bell': true, 'disabled': isSubscribed})} id={<code>subscribePopover-${id}</code>}&gt;\n              &lt;FontAwesomeIcon icon={faBell} title=\"Subscribe\" /&gt;\n            &lt;/div&gt;\n        &lt;/CardTitle&gt;\n        &lt;div className=\"metrics\"&gt;\n          &lt;div className=\"metrics-row\"&gt;\n            &lt;span className=\"metrics-row--label\"&gt;High:&lt;/span&gt; \n            &lt;span className=\"metrics-row--value\"&gt;{max.high}&lt;/span&gt;\n            &lt;span className=\"metrics-row--label\"&gt;{' '}(Volume: &lt;/span&gt; \n            &lt;span className=\"metrics-row--value\"&gt;{max.volume}&lt;/span&gt;)\n          &lt;/div&gt;\n          &lt;div className=\"metrics-row\"&gt;\n            &lt;span className=\"metrics-row--label\"&gt;Low: &lt;/span&gt;\n            &lt;span className=\"metrics-row--value\"&gt;{min.low}&lt;/span&gt;\n            &lt;span className=\"metrics-row--label\"&gt;{' '}(Volume: &lt;/span&gt;\n            &lt;span className=\"metrics-row--value\"&gt;{min.volume}&lt;/span&gt;)\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;Button className=\"timeseries-btn\" outline onClick={() =&gt; toggleTimeseries(id)}&gt;Timeseries&lt;/Button&gt;{' '}\n      &lt;/CardBody&gt;\n    &lt;/Card&gt;\n    &lt;Popover\n      className=\"popover-custom\" \n      placement=\"bottom\" \n      target={<code>subscribePopover-${id}</code>}\n      isOpen={isSubscribePopoverOpen === id}\n      toggle={() =&gt; setSubscribeValues(id, symbolTriggerData)}\n    &gt;\n      &lt;PopoverHeader&gt;\n        Notification Options\n        &lt;span className=\"popover-close\"&gt;\n          &lt;FontAwesomeIcon \n            icon={faTimes} \n            onClick={() =&gt; handlePopoverToggle(null)}\n          /&gt;\n        &lt;/span&gt;\n      &lt;/PopoverHeader&gt;\n      {renderSubscribeOptions(id, isSubscribed, symbolTriggerData)}\n    &lt;/Popover&gt;\n  &lt;/div&gt;\n  &lt;Collapse isOpen={expandedStockId === id}&gt;\n    {\n      isOpen(id) ? &lt;StockTimeseries symbol={id}/&gt; : null\n    }\n  &lt;/Collapse&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<p>We’re using the <a href=\"https://reactstrap.github.io/components/card/\"><code>Card</code></a> component of ReactStrap to render these cards. The <code>Popover</code> component is used for displaying the subscription-based options:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c041addf-6297-4300-bb1e-0f5e621d4092/7-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>When the user clicks on the <code>bell</code> icon for a particular stock, he can opt-in to get notified every hour or when the price of the stock has reached the entered value. We’ll see this in action in the Events/Time Triggers section.</p>\n<p><strong>Note</strong>: <em>We’ll get to the <code>StockTimeseries</code> component in the next section!</em></p>\n<p>Please refer to <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/views/symbolList.js\"><code>symbolList.js</code></a> for the complete code related to the stocks list component.</p>\n<h4>Stock Timeseries View</h4>\n<p>The <code>StockTimeseries</code> component uses the query <code>stocksDataQuery</code>:</p>\n<div>\n<pre><code>export const stocksDataQuery = gql<code>query getStocksData($symbol: String) {\n    stock_data(order_by: {time: desc}, where: {symbol: {_eq: $symbol}}, limit: 25) {\n      high\n      low\n      open\n      close\n      volume\n      time\n    }\n  }</code>;</code></pre>\n</div>\n\n<p>The above query fetches the recent 25 data points of the selected stock. For example, here is the chart for the Facebook stock <em>open</em> metric:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9859088b-e013-4f6f-be16-8657e565d94c/14-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>This is a straightforward component where we pass in some chart options to [<code>HighchartsReact</code>] component. Here are the chart options:</p>\n<pre><code>const chartOptions = {\n  title: {\n    text: `${symbol} Timeseries`\n  },\n  subtitle: {\n    text: 'Intraday (5min) open, high, low, close prices &amp; volume'\n  },\n  yAxis: {\n    title: {\n      text: '#'\n    }\n  },\n  xAxis: {\n    title: {\n      text: 'Time'\n    },\n    categories: getDataPoints('time')\n  },\n  legend: {\n    layout: 'vertical',\n    align: 'right',\n    verticalAlign: 'middle'\n  },\n  series: [\n    {\n      name: 'high',\n      data: getDataPoints('high')\n    }, {\n      name: 'low',\n      data: getDataPoints('low')\n    }, {\n      name: 'open',\n      data: getDataPoints('open')\n    },\n    {\n      name: 'close',\n      data: getDataPoints('close')\n    },\n    {\n      name: 'volume',\n      data: getDataPoints('volume')\n    }\n  ]\n}</code></pre>\n\n<p>The X-Axis shows the time and the Y-Axis shows the metric value at that time. The function <code>getDataPoints</code> is used for generating a series of points for each of the series. </p>\n<pre><code>const getDataPoints = (type) =&gt; {\n  const values = [];\n  data.stock_data.map((dataPoint) =&gt; {\n    let value = dataPoint[type];\n    if (type === 'time') {\n      value = new Date(dataPoint['time']).toLocaleString('en-US');\n    }\n    values.push(value);\n  });\n  return values;\n}</code></pre>\n\n<p>Simple! That’s how the Chart component is generated! Please refer to <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/components/chart.js\">Chart.js</a> and <a href=\"https://github.com/ankitamasand/stocks-price-notifier/blob/main/src/views/stockTimeseries.js\"><code>stockTimeseries.js</code></a> files for the complete code on stock time-series.</p>\n<p>You should now be ready with the data and the user interfaces part of the project. Let’s now move onto the interesting part — setting up event/time triggers based on the user’s input.</p>\n<h3>Setting Up Event/Scheduled Triggers</h3>\n<p>In this section, we’ll learn how to set up triggers on the Hasura console and how to send web push notifications to the selected users. Let’s get started!</p>\n<h4>Events Triggers On Hasura Console</h4>\n<p>Let’s create an event trigger <code>stock_value</code> on the table <code>stock_data</code> and <code>insert</code> as the trigger operation. The webhook will run every time there is an insert in the <code>stock_data</code> table. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fac40d58-a914-4a0c-8d43-8145b1645c3c/4-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>We’re going to create a <a href=\"https://glitch.com/\">glitch project</a> for the webhook URL. Let me put down a bit about webhooks to make easy clear to understand:</p>\n<p><em>Webhooks are used for sending data from one application to another on the occurrence of a particular event. When an event is triggered, an HTTP POST call is made to the webhook URL with the event data as the payload.</em></p>\n<p>In this case, when there is an insert operation on the <code>stock_data</code> table, an HTTP post call will be made to the configured webhook URL (post call in the glitch project).</p>\n<h4>Glitch Project For Sending Web-push Notifications</h4>\n<p>We’ve to get the webhook URL to put in the above event trigger interface. Go to glitch.com and create a new project. In this project, we’ll set up an express listener and there will be an HTTP post listener. The HTTP POST payload will have all the details of the stock datapoint including <code>open</code>, <code>close</code>, <code>high</code>, <code>low</code>, <code>volume</code>, <code>time</code>. We’ll have to fetch the list of users subscribed to this stock with the value equal to the <code>close</code> metric.</p>\n<p>These users will then be notified of the stock price via web-push notifications. </p>\n<p>That’s all we've to do to achieve the desired target of notifying users when the stock price reaches the expected value!</p>\n<p>Let’s break this down into smaller steps and implement them!</p>\n<h5>Installing Dependencies</h5>\n<p>We would need the following dependencies:</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/express\"><code>express</code></a>: is used for creating an express server.</li>\n<li><a href=\"https://www.npmjs.com/package/apollo-fetch\"><code>apollo-fetch</code></a>: is used for creating a fetch function for getting data from the GraphQL endpoint.</li>\n<li><a href=\"https://www.npmjs.com/package/web-push\"><code>web-push</code></a>: is used for sending web push notifications.</li>\n</ul>\n<p>Please write this script in <code>package.json</code> to run <code>index.js</code> on <code>npm start</code> command:</p>\n<pre><code>\"scripts\": {\n  \"start\": \"node index.js\"\n}</code></pre>\n\n<h5>Setting Up Express Server</h5>\n<p>Let’s create an <code>index.js</code> file as:</p>\n<pre><code>const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst handleStockValueTrigger = (eventData, res) =&gt; {\n  /* Code for handling this trigger */\n}\n\napp.post('/', (req, res) =&gt; {\n  const { body } = req\n  const eventType = body.trigger.name\n  const eventData = body.event\n\n  switch (eventType) {\n    case 'stock-value-trigger':\n      return handleStockValueTrigger(eventData, res);\n  }\n\n});\n\napp.get('/', function (req, res) {\n  res.send('Hello World - For Event Triggers, try a POST request?');\n});\n\nvar server = app.listen(process.env.PORT, function () {\n    console.log(`server listening on port ${process.env.PORT}`);\n});\n</code></pre>\n\n<p>In the above code, we’ve created <code>post</code> and <code>get</code> listeners on the route <code>/</code>. <code>get</code> is simple to get around! We’re mainly interested in the post call. If the <code>eventType</code> is <code>stock-value-trigger</code>, we’ll have to handle this trigger by notifying the subscribed users. Let’s add that bit and complete this function!</p>\n<h5>Fetching Subscribed Users</h5>\n<div>\n<pre><code>const fetch = createApolloFetch({\n  uri: process.env.GRAPHQL_URL\n});\n\nconst getSubscribedUsers = (symbol, triggerValue) =&gt; {\n  return fetch({\n    query: <code>query getSubscribedUsers($symbol: String, $triggerValue: numeric) {\n      events(where: {symbol: {_eq: $symbol}, trigger_type: {_eq: \"event\"}, trigger_value: {_gte: $triggerValue}}) {\n        user_id\n        user_subscription {\n          subscription\n        }\n      }\n    }</code>,\n    variables: {\n      symbol,\n      triggerValue\n    }\n  }).then(response =&gt; response.data.events)\n}\n\n\nconst handleStockValueTrigger = async (eventData, res) =&gt; {\n  const symbol = eventData.data.new.symbol;\n  const triggerValue = eventData.data.new.close;\n  const subscribedUsers = await getSubscribedUsers(symbol, triggerValue);\n  const webpushPayload = {\n    title: <code>${symbol} - Stock Update</code>,\n    body: <code>The price of this stock is ${triggerValue}</code>\n  }\n  subscribedUsers.map((data) =&gt; {\n    sendWebpush(data.user_subscription.subscription, JSON.stringify(webpushPayload));\n  })\n  res.json(eventData.toString());\n}\n</code></pre>\n</div>\n\n<p>In the above <code>handleStockValueTrigger</code> function, we’re first fetching the subscribed users using the <code>getSubscribedUsers</code> function. We’re then sending web-push notifications to each of these users. The function <code>sendWebpush</code> is used for sending the notification. We’ll look at the web-push implementation in a moment. </p>\n<p>The function <code>getSubscribedUsers</code> uses the query: </p>\n<div>\n<pre><code>query getSubscribedUsers($symbol: String, $triggerValue: numeric) {\n  events(where: {symbol: {_eq: $symbol}, trigger_type: {_eq: \"event\"}, trigger_value: {_gte: $triggerValue}}) {\n    user_id\n    user_subscription {\n      subscription\n    }\n  }\n}</code></pre>\n</div>\n\n<p>This query takes in the stock symbol and the value and fetches the user details including <code>user-id</code> and <code>user_subscription</code> that matches these conditions:</p>\n<ul>\n<li><code>symbol</code> equal to the one being passed in the payload.</li>\n<li><code>trigger_type</code> is equal to <code>event</code>.</li>\n<li><code>trigger_value</code> is greater than or equal to the one being passed to this function (<code>close</code> in this case).</li>\n</ul>\n<p>Once we get the list of users, the only thing that remains is sending web-push notifications to them! Let’s do that right away!</p>\n<h5>Sending Web-Push Notifications To The Subscribed Users</h5>\n<p>We’ve to first get the public and the private VAPID keys to send web-push notifications. Please store these keys in the <code>.env</code> file and set these details in <code>index.js</code> as:</p>\n<div>\n<pre><code>webPush.setVapidDetails(\n  'mailto:&lt;YOUR_MAIL_ID&gt;',\n  process.env.PUBLIC_VAPID_KEY,\n  process.env.PRIVATE_VAPID_KEY\n);\n\nconst sendWebpush = (subscription, webpushPayload) =&gt; {\n  webPush.sendNotification(subscription, webpushPayload).catch(err =&gt; console.log('error while sending webpush', err))\n}</code></pre>\n</div>\n\n<p>The <code>sendNotification</code> function is used for sending the web-push on the subscription endpoint provided as the first parameter. </p>\n<p>That’s all is required to successfully send web-push notifications to the subscribed users. Here’s the complete code defined in <code>index.js</code>:</p>\n<div>\n<pre><code>const express = require('express');\nconst bodyParser = require('body-parser');\nconst { createApolloFetch } = require('apollo-fetch');\nconst webPush = require('web-push');\n\nwebPush.setVapidDetails(\n  'mailto:&lt;YOUR_MAIL_ID&gt;',\n  process.env.PUBLIC_VAPID_KEY,\n  process.env.PRIVATE_VAPID_KEY\n);\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst fetch = createApolloFetch({\n  uri: process.env.GRAPHQL_URL\n});\n\nconst getSubscribedUsers = (symbol, triggerValue) =&gt; {\n  return fetch({\n    query: <code>query getSubscribedUsers($symbol: String, $triggerValue: numeric) {\n      events(where: {symbol: {_eq: $symbol}, trigger_type: {_eq: \"event\"}, trigger_value: {_gte: $triggerValue}}) {\n        user_id\n        user_subscription {\n          subscription\n        }\n      }\n    }</code>,\n    variables: {\n      symbol,\n      triggerValue\n    }\n  }).then(response =&gt; response.data.events)\n}\n\nconst sendWebpush = (subscription, webpushPayload) =&gt; {\n  webPush.sendNotification(subscription, webpushPayload).catch(err =&gt; console.log('error while sending webpush', err))\n}\n\nconst handleStockValueTrigger = async (eventData, res) =&gt; {\n  const symbol = eventData.data.new.symbol;\n  const triggerValue = eventData.data.new.close;\n  const subscribedUsers = await getSubscribedUsers(symbol, triggerValue);\n  const webpushPayload = {\n    title: <code>${symbol} - Stock Update</code>,\n    body: <code>The price of this stock is ${triggerValue}</code>\n  }\n  subscribedUsers.map((data) =&gt; {\n    sendWebpush(data.user_subscription.subscription, JSON.stringify(webpushPayload));\n  })\n  res.json(eventData.toString());\n}\n\napp.post('/', (req, res) =&gt; {\n  const { body } = req\n  const eventType = body.trigger.name\n  const eventData = body.event\n\n  switch (eventType) {\n    case 'stock-value-trigger':\n      return handleStockValueTrigger(eventData, res);\n  }\n\n});\n\napp.get('/', function (req, res) {\n  res.send('Hello World - For Event Triggers, try a POST request?');\n});\n\nvar server = app.listen(process.env.PORT, function () {\n    console.log(\"server listening\");\n});</code></pre>\n</div>\n\n<p>Let’s test out this flow by subscribing to stock with some value and manually inserting that value in the table (for testing)!</p>\n<p>I subscribed to <code>AMZN</code> with value as <code>2000</code> and then inserted a data point in the table with this value. Here’s how the stocks notifier app notified me right after the insertion:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/49a66ddb-c9ed-4149-9f7c-8f3c1f039db6/9-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>Neat! You can also check the event invocation log here:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8aa94a19-05d0-4ee5-b31a-1b39690ceeb9/3-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>The webhook is doing the work as expected! We’re all set for the event triggers now!</p>\n<h5>Scheduled/Cron Triggers</h5>\n<p>We can achieve a time-based trigger for notifying the subscriber users every hour using the Cron event trigger as:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/46bc4f7d-7fce-48d7-a1c6-15914e4d9542/2-stocks-price-notifier-app-react-apollo-graphql-hasura.png\" /></p>\n<p>We can use the same webhook URL and handle the subscribed users based on the trigger event type as <code>stock_price_time_based_trigger</code>. The implementation is similar to the event-based trigger.</p>\n<h3>Conclusion</h3>\n<p>In this article, we built a stock price notifier application. We learned how to fetch prices using the Alpha Vantage APIs and store the data points in the Hasura backed Postgres database. We also learned how to set up the Hasura GraphQL engine and create event-based and scheduled triggers. We built a glitch project for sending web-push notifications to the subscribed users.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"837159e663b41a5e2407fa53f678892d0ff1d4f913ddda51737f08855171bcb5","category":"Tech"}