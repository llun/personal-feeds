{"title":"Testing HashiCorp Terraform","link":"https://www.hashicorp.com/blog/testing-hashicorp-terraform","date":1614704400000,"content":"<p>How do you know if you can run <code>terraform apply</code> to your infrastructure without affecting critical business applications? You can <code>terraform validate</code> and <code>terraform plan</code> to check your configuration, but will that be enough? Whether you’ve updated some HashiCorp Terraform configuration or a new version of a <a href=\"https://learn.hashicorp.com/tutorials/terraform/module?utm_source=WEBSITE&#x26;utm_medium=WEB_BLOG&#x26;utm_offer=ARTICLE_PAGE\">module</a>, you want to catch errors quickly before you apply any changes to production infrastructure. In this post, I’ll discuss some testing strategies for HashiCorp Terraform configuration and modules so that you can <code>terraform apply</code> with greater confidence. You’ll learn how infrastructure tests fit into your organization’s development practices, the differences in testing modules versus configuration, and approaches to manage the cost of testing.</p>\n<p>I included a few testing examples with <a href=\"https://learn.hashicorp.com/collections/terraform/policy?utm_source=WEBSITE&#x26;utm_medium=WEB_BLOG&#x26;utm_offer=ARTICLE_PAGE\">HashiCorp Sentinel</a>. No matter which tool you use, you can generalize the approaches outlined in this post to your overall infrastructure testing strategy. In addition to the testing tools and approaches in this post, you can find other perspectives and examples in the references at the conclusion.</p>\n<p>Ideally, your infrastructure testing strategy should align with the test pyramid, which groups tests by type, scope, and granularity. The higher up the pyramid you go, the fewer tests you should have for that level of the pyramid. Higher-level tests in the pyramid take more time and cost to create or configure resources.</p><img src=https://www.datocms-assets.com/2885/1614617558-terraformtestingpyramid.png alt=Test pyramid for infrastructure testing><p>In reality, your tests may not perfectly align with the pyramid shape. The pyramid offers a common language to describe what area a test can cover to verify configuration and infrastructure resources. I’ll start at the bottom of the pyramid with unit tests and work my way up the pyramid to end-to-end tests. Manual testing involves spot-checking infrastructure for functionality and has a high cost in time and effort.</p>\n<h2><a class=\"__permalink-h\" href=\"#unit-tests\" aria-label=\"unit tests permalink\">»</a><a class=\"__target-h\" id=\"unit-tests\" aria-hidden></a>Unit Tests</h2>\n<p>At the bottom of the pyramid, unit tests verify individual resources and configurations for expected values. They should answer the question, “Does my configuration or plan contain the correct metadata?” Traditionally, unit tests should run independently, without external resources or API calls.</p>\n<p>You can use <code>terraform fmt -check</code> and <code>terraform validate</code> as rudimentary unit tests. For additional test coverage, you can use any programming language or testing tool to parse the Terraform configuration in HCL or JSON and check for statically defined parameters, such as provider attributes with defaults or hard-coded values. However, none of these tests verify correct variable interpolation, list iteration, or other configuration logic. As a result, I usually write additional unit tests to parse the plan representation instead of the Terraform configuration.</p>\n<p>Configuration parsing, <code>terraform fmt -check</code>, and <code>terraform validate</code> do not require active infrastructure resources or authentication to an infrastructure provider. Unit tests for the plan representation require Terraform to authenticate to your infrastructure provider and make comparisons. These types of tests overlap with security testing done as part of <a href=\"https://www.hashicorp.com/blog/why-policy-as-code\">policy as code</a> because you check attributes in Terraform configuration for the correct values.</p>\n<p>For example, your Terraform configuration parses the IP address from an AWS instance’s <a href=\"https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#private_dns\">DNS name</a> and passes it to a target group for a load balancer. At a glance, you don’t know if it correctly replaces the hyphens and retrieves the IP address information.</p><pre><code>locals {\n ip_addresses = toset([\n   for service, service_data in var.services :\n   replace(replace(split(\".\", service_data.node)[0], \"ip-\", \"\"), \"-\", \".\") if service_data.kind == var.service_kind\n ])\n}</code></pre><p>You ran <code>terraform plan</code> to manually check the IP address and continue to add more configuration to the module over time. As a result, it takes time to scroll through the planned changes to check your IP address. To solve this problem, write two unit tests with HashiCorp Sentinel to check parameters in the configuration’s plan and automate the IP address verification. One test checks that the target group does not use the default node address, and the other verifies that the <code>target_id</code> matches a valid IP address.</p><pre><code>aws_lb_target_group_attachment_does_not_use_node_address = rule {\n   all aws_lb_target_group_attachments as target_group_attachment {\n       target_group_attachment.values.target_id not in\n           consul_terraform_sync_service_node_addresses\n   }\n}\n \naws_lb_target_group_attachment_has_ip_address = rule {\n   all aws_lb_target_group_attachments as target_group_attachment {\n       target_group_attachment.values.target_id matches\n           \"^\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$\"\n   }\n}</code></pre><p>If you do not use HashiCorp Sentinel, you can use your programming language or configuration testing tool of choice to parse the plan representation in JSON and verify your Terraform logic. Additionally, unit tests can validate:</p>\n<ul>\n<li>Number of resources or attributes generated by <a href=\"https://learn.hashicorp.com/collections/terraform/0-13?utm_source=WEBSITE&#x26;utm_medium=WEB_BLOG&#x26;utm_offer=ARTICLE_PAGE\"><code>for_each</code> or <code>count</code></a></li>\n<li>Values generated by <a href=\"https://www.terraform.io/docs/language/expressions/for.html\"><code>for</code> expressions</a></li>\n<li>Values generated by <a href=\"https://www.terraform.io/docs/language/functions/index.html\">built-in functions</a></li>\n<li>Dependencies between modules</li>\n<li>Values associated with interpolated values</li>\n<li>Expected variables or outputs marked as sensitive</li>\n</ul>\n<p>Overall, unit tests run very quickly and provide rapid feedback. They also communicate the expected values of configuration across your team and organization. Since they run independently of infrastructure resources, unit tests have a virtually zero cost to run frequently.</p>\n<h2><a class=\"__permalink-h\" href=\"#contract-tests\" aria-label=\"contract tests permalink\">»</a><a class=\"__target-h\" id=\"contract-tests\" aria-hidden></a>Contract Tests</h2>\n<p>At the next level from the bottom of the pyramid, contract tests check that a configuration using a Terraform module passes properly formatted inputs. Contract tests answer the question, “Does the expected input to the module match what I think I should pass to it?” Contract tests ensure that the contract between a Terraform configuration’s expected inputs to a module and the module’s actual inputs has not been broken. You can use the same testing framework as your unit tests to check that a Terraform configuration passes the right inputs to a module.</p>\n<p>Instead of using a separate testing framework for contract tests, use a <a href=\"https://www.terraform.io/docs/language/values/variables.html#custom-validation-rules\">custom validation rule</a>. For example, use a custom validation rule to ensure that an AWS load balancer’s listener rule receives a valid integer range for its priority.</p><pre><code>variable \"listener_rule_priority\" {\n type        = number\n default     = 1\n description = \"Priority of listener rule between 1 to 50000\"\n validation {\n   condition     = var.listener_rule_priority > 0 && var.listener_rule_priority < 50000\n   error_message = \"The priority of listener_rule must be between 1 to 50000.\"\n }\n}</code></pre><p>In addition to custom validation rules, you can use Terraform’s rich language syntax to validate variables with an <a href=\"https://www.terraform.io/docs/language/expressions/type-constraints.html#structural-types\">object structure</a> and check that the module receives the expected input. In the AWS load balancer case, add a map representing service objects and their expected attributes and type.</p><pre><code>variable \"services\" {\n description = \"Consul services monitored by Consul-Terraform-Sync\"\n type = map(\n   object({\n     id        = string\n     name      = string\n     address   = string\n     port      = number\n     kind      = string\n     meta      = map(string)\n     tags      = list(string)\n     namespace = string\n     status    = string\n \n     node                  = string\n     node_id               = string\n     node_address          = string\n     node_datacenter       = string\n     node_tagged_addresses = map(string)\n     node_meta             = map(string)\n   })\n )\n}</code></pre><blockquote>\n<p>Note that <a href=\"https://www.consul.io/docs/nia\">Consul Terraform Sync</a> generates the services object outlined in the example.</p>\n</blockquote>\n<p>Contract tests quickly catch misconfigurations to modules before applying them to live infrastructure resources. You can use them to check for correct identifier formats, naming standards, attribute types, and value constraints such as character limits or password requirements.</p>\n<p>Unit and contract tests may require extra time and effort to build, but they allow you to catch configuration errors <em>before</em> running <code>terraform apply</code>. For larger, more complex configurations with many resources, you should not manually check individual parameters. Instead, unit and contract tests quickly automate the verification of important configurations and set a foundation for collaboration across teams and organizations. Lower-level tests communicate system knowledge and expectations to teams that need to maintain and update Terraform configuration.</p>\n<h2><a class=\"__permalink-h\" href=\"#integration-tests\" aria-label=\"integration tests permalink\">»</a><a class=\"__target-h\" id=\"integration-tests\" aria-hidden></a>Integration Tests</h2>\n<p>With lower-level tests, you do not need to create external resources to run them. The top half of the pyramid includes tests that require active infrastructure resources to run properly. Integration tests check that a configuration using a Terraform module passes properly formatted inputs. They answer the question, “Does this module or configuration create the resources successfully?” A <code>terraform apply</code> offers limited integration testing because it creates and configures resources while managing dependencies. You should write additional tests to check for configuration parameters on the active resource.</p>\n<p>Should you verify every parameter that Terraform configures on a resource? You could, but it may not be the best use of your time and effort! Terraform providers include <a href=\"https://www.terraform.io/docs/extend/testing/acceptance-tests/index.html\">acceptance tests</a> that resources properly create, update, and delete with the right configuration values. Instead, use integration tests to verify that Terraform outputs include the correct values or number of resources. They also test infrastructure configuration that can only be verified after a <code>terraform apply</code>, such as invalid configurations, nonconformant passwords, or results of <code>for_each</code> iteration.</p>\n<p>Depending on your integration testing framework, you may need to write scripts or automation to <code>terraform apply</code> for test resources, run the tests, and <code>terraform destroy</code> the resources. Some frameworks, such as <a href=\"https://terratest.gruntwork.io/\">Terratest</a> or <a href=\"https://github.com/newcontext-oss/kitchen-terraform\">kitchen-terraform</a>, orchestrate this sequence for you. When choosing a framework, consider the existing integrations and languages within your organization. Integration tests help you determine whether or not to update your module version and ensure they run without errors. Since you have to set up and tear down the resources, you will find that integration tests can take 15 minutes or more to complete depending on the resource! As a result, implement as much unit and contract testing as possible to fail quickly on wrong configurations instead of waiting for resources to create and delete.</p>\n<h2><a class=\"__permalink-h\" href=\"#end-to-end-tests\" aria-label=\"end to end tests permalink\">»</a><a class=\"__target-h\" id=\"end-to-end-tests\" aria-hidden></a>End-to-End Tests</h2>\n<p>After you apply your Terraform changes to production, you need to know whether or not you’ve affected end-user functionality.  They answer the question, “Can someone use the infrastructure system successfully?” For example, application developers should still be able to deploy to HashiCorp Nomad after you upgrade the version. Operations team members should still be able to examine system metrics in their monitoring tools. End-to-end tests can verify that changes did not break expected functionality. To check that you’ve upgraded Nomad properly, you can deploy a sample application, test the endpoint, and delete it from the cluster. To check that the monitoring tool has system metrics, you can check if it contains data from your system in the last five minutes.</p>\n<p>You can write end-to-end tests in any programming language or framework. Frameworks like Terratest and kitchen-terraform can also be used for end-to-end tests. You can add an API call in kitchen-terraform to check an endpoint after creating infrastructure. I have also used both frameworks to provision virtual machines on AWS VPC networks and verify their connectivity as end-to-end tests for network configuration. End-to-end tests usually depend on an entire system, including networks, compute clusters, load balancers, and more. As a result, these tests usually run against long-lived development or production environments.</p>\n<h2><a class=\"__permalink-h\" href=\"#testing-terraform-modules\" aria-label=\"testing terraform modules permalink\">»</a><a class=\"__target-h\" id=\"testing-terraform-modules\" aria-hidden></a>Testing Terraform Modules</h2>\n<p>When you test Terraform modules, you want enough verification to ensure a new, stable release of the module for use across your organization. To ensure sufficient test coverage, write unit, contract, and integration tests for modules. A module delivery pipeline starts with a <code>terraform plan</code> and then runs unit tests (and if applicable, contract tests) to verify the expected Terraform resources and configurations. Then, run <code>terraform apply</code> and the integration tests to check that the module can still run without errors. After running integration tests, destroy the resources and release a new module version.</p><img src=https://www.datocms-assets.com/2885/1614620259-terraformtestingmodules.png alt=Pipeline for Terraform module testing><p>For a full example of testing a module in Terraform Cloud, refer to a <a href=\"https://github.com/joatmon08/terraform-aws-listener-rule\">module built for Consul Terraform Sync</a>. The module uses a dedicated Terraform Cloud workspace with an attached Sentinel policy of its unit tests. The workspace uses a CLI-driven workflow since its integration tests have external dependencies. I manage the module’s release through <a href=\"https://github.com/joatmon08/terraform-aws-listener-rule/blob/main/.github/workflows/terraform.yml\">a GitHub Actions workflow</a>.</p>\n<p>The workflow runs <a href=\"https://github.com/joatmon08/terraform-aws-listener-rule/tree/main/test/unit\">unit tests</a> written in Sentinel against a Terraform Cloud workspace. The module contains contract tests in the form of <a href=\"https://github.com/joatmon08/terraform-aws-listener-rule/blob/main/variables.tf\">variable validation</a>, which will verify valid inputs for any configurations that depend on the module.</p><img src=https://www.datocms-assets.com/2885/1614620367-terraformtestingtfc.png alt=Passing unit tests with Sentinel policy applied to workspace><p>Upon merging the changes, my GitHub Actions workflow runs <a href=\"https://github.com/joatmon08/terraform-aws-listener-rule/tree/main/test/integration\">integration tests</a> written in Terratest. They create a load balancer, listener rule, and target group to verify that the module configures additional listener rules and target groups. After the integration tests pass, I can tag and release a new version of the module.</p><img src=https://www.datocms-assets.com/2885/1614620509-terraformtestingintegration.png alt=Passing integration tests to create and delete module resources><blockquote>\n<p>Note: We have ongoing research for <code>terraform test</code>, which supports module acceptance testing. Check out the <a href=\"https://github.com/hashicorp/terraform/pull/27873/files\">prototype</a>.</p>\n</blockquote>\n<p>When testing modules, consider the cost and test coverage of module tests. Conduct module tests in a different project or account so that you can independently track the cost of your module testing and ensure module resources do not overwrite environments. On occasion, you can omit integration tests because of their high financial and time cost. Spinning up databases and clusters can take half an hour or more. When you’re constantly pushing changes, you might even create multiple test instances! To manage the cost, run integration tests after merging feature branches and select the minimum number of resources you need to test the module. If possible, avoid creating entire systems. Module testing applies mostly to immutable resources because of its create and delete sequence. The tests cannot accurately represent the end state of brownfield (existing) resources because they do not test updates. As a result, it provides confidence in the module’s successful usage but not necessarily in applying module updates to live infrastructure environments.</p>\n<h2><a class=\"__permalink-h\" href=\"#testing-terraform-configuration\" aria-label=\"testing terraform configuration permalink\">»</a><a class=\"__target-h\" id=\"testing-terraform-configuration\" aria-hidden></a>Testing Terraform Configuration</h2>\n<p>Compared to modules, Terraform configuration applied to environments should include end-to-end tests to check for end-user functionality of infrastructure resources. Write unit, integration, and end-to-end tests for configuration of active environments. The unit tests do not need to cover the configuration in modules. Instead, focus on unit testing any configuration not associated with modules. Integration tests can check that changes successfully run in a long-lived development environment, and end-to-end tests verify the environment’s initial functionality. If you use feature branching, merge your changes and apply them to a production environment. In production, run end-to-end tests against the system to confirm system availability.</p><img src=https://www.datocms-assets.com/2885/1614620711-terraformtestingconfiguration.png alt=Pipeline for Terraform configuration testing><p>Failed changes to active environments will affect critical business systems. In its ideal form, a long-running development environment that accurately mimics production can help you catch potential problems. From a practical standpoint, you may not always have a development environment that fully replicates a production environment because of cost concerns and the difficulty of replicating user traffic. As a result, you usually run a scaled-down version of production to save cost. The difference between development and production will affect the outcome of your tests, so be aware of which tests may be more important to flagging errors or disruptive to run. Even if configuration tests have less accuracy in development, they can still catch a number of errors and help you practice applying and rolling back changes before production.</p>\n<h2><a class=\"__permalink-h\" href=\"#conclusion\" aria-label=\"conclusion permalink\">»</a><a class=\"__target-h\" id=\"conclusion\" aria-hidden></a>Conclusion</h2>\n<p>Depending on your system’s cost and complexity, you can apply a variety of testing strategies to Terraform modules and configuration. I explained the different types of tests and how you can apply them to catching errors in Terraform configuration before production, and how to incorporate them into pipelines. Your Terraform testing strategy does not need to be a perfect test pyramid. At the very least, automate some tests to reduce the time you need to manually verify changes and check for errors before they reach production.</p>\n<p>For a more comprehensive list of Terraform testing tools, check out <a href=\"https://github.com/joatmon08/tdd-infrastructure\">this repository with a list of infrastructure testing tools</a>. In addition to existing community tools, we’d love your feedback on <a href=\"https://github.com/hashicorp/terraform/pull/27873/files\">our prototype</a> for <code>terraform test</code>, which offers module acceptance testing.</p>\n<p>Additional resources on practices and patterns for testing Terraform include:</p>\n<ul>\n<li><a href=\"https://www.hashicorp.com/resources/test-driven-development-tdd-for-infrastructure\">Test-Driven Development for Infrastructure</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/moving-security-and-sanity-left-by-testing-terraform-with-inspec\">Moving Security and Sanity Left by Testing Terraform with InSpec</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/terraform-code-reviews-supercharged-with-conftest\">Terraform Code Reviews: Supercharged with Conftest</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/testing-infrastructure-as-code-on-localhost\">Testing Infrastructure as Code on Localhost</a></li>\n<li><a href=\"https://www.slideshare.net/TomStraub5/developing-terraform-modules-at-scale-hashitalks-2021\">Developing Terraform Modules at Scale</a></li>\n<li><a href=\"https://www.hashicorp.com/resources/testing-your-hcl-modules-in-terraform\">Testing your HCL Modules</a></li>\n</ul>\n<p>To learn about using Sentinel on Terraform Cloud, <a href=\"https://learn.hashicorp.com/tutorials/terraform/sentinel-testing?utm_source=WEBSITE&#x26;utm_medium=WEB_BLOG&#x26;utm_offer=ARTICLE_PAGE\">review our tutorial</a> on Learn.</p>\n<p><em>Questions about this post? Add them to the <a href=\"https://discuss.hashicorp.com/t/blog-testing-hashicorp-terraform/21412\">community forum</a>!</em></p>","author":"Rosemary Wang","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"0dc93e4cb21121e8955f020b84856926064e957ce3beae4bba5d01928a7b68f0","category":"Tech"}