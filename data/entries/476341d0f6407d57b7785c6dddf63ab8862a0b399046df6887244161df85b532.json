{"title":"How To Build A Node.js API For Ethereum Blockchain","link":"https://smashingmagazine.com/2021/01/nodejs-api-ethereum-blockchain/","date":1611073800000,"content":"<p>Blockchain technology has been on the rise in the past ten years, and has brought a good number of products and platforms to life such as <a href=\"https://www.chainalysis.com/\">Chainalysis</a> (finance tech), <a href=\"https://www.burstiq.com/technology/\">Burstiq</a> (health-tech), <a href=\"http://www.iotevolutionworld.com/iot/articles/441809-filament-launches-new-blockcha-development-kit-iot-developers.htm\">Filament</a> (IoT), <a href=\"https://opus.audio/\">Opus</a> (music streaming) and <a href=\"https://ocular.biz/cybersecurity/\">Ocular</a> (cybersecurity).</p>\n<p>From these examples, we can see that blockchain cuts across many products and use cases — making it very essential and useful. In fintech (finance tech), it’s used as decentralized ledgers for security and transparency in places like Chain, Chainalysis, and is also useful in health tech for the security of sensitive health data in Burstiq and Robomed — not to forget media tech such as Opus and Audius that also use blockchain for royalties transparency and thus get full royalties.</p>\n<p>Ocular uses security that comes with blockchain for identity management for biometric systems, while Filament uses blockchain ledgers for real-time encrypted communication. This goes to show how essential blockchain has become to us by making our lives better. But what <em>exactly</em> is a blockchain?</p>\n<p>A blockchain is a <strong>database</strong> that is shared across a network of computers. Once a record has been added to the chain, it is quite difficult to change. To ensure that all the copies of the database are the same, the network makes constant checks.</p>\n<p>So why do we <em>need</em> blockchain? Blockchain is a <strong>safe way to record activities</strong> and keep data fresh while maintaining a record of its history compared to the traditional records or databases where hacks, errors, and downtimes are very possible. The data can’t be corrupted by anyone or accidentally deleted, and you benefit from both a historical trail of data and an instantly up-to-date record that can’t be erased or become inaccessible due to downtime of a server.</p>\n<p>Because the whole blockchain is duplicated across many computers, any user can view the entire blockchain. Transactions or records are processed not by one central administrator, but by a network of users who work to verify the data and achieve a consensus.</p>\n<p>Applications that use blockchain are called <strong>dApps</strong> (Decentralised Applications). Looking around today, we’ll mostly find decentralized apps in fintech, but blockchain goes beyond decentralized finance. We have health platforms, music streaming/sharing platforms, e-commerce platforms, cybersecurity platforms, and  IOTs moving towards decentralized applications (dApps) as cited above.</p>\n<p>So, when would it make sense to consider using blockchain for our applications, rather than a standard database or record?</p>\n<h3>Common Applications Of Blockchain</h3>\n<ul>\n<li><strong>Managing And Securing Digital Relationships</strong><br />Anytime you want to keep a long-term, transparent record of assets (for example, to record property or apartment rights), blockchain could be the ideal solution. Ethereum ‘Smart contracts’, in particular, are great for facilitating digital relationships. With a smart contract, automated payments can be released when parties in a transaction agree that their conditions have been met.</li>\n<li><strong>Eliminating Middlemen/Gatekeepers</strong><br />For example, most providers currently have to interact with guests via a centralized aggregator platform, like Airbnb or Uber (that, in turn, takes a cut on each transaction). Blockchain could change all that.<br />For example, TUI is so convinced of the power of blockchain that it is <a href=\"https://www.forbes.com/sites/bernardmarr/2018/12/07/the-amazing-ways-tui-uses-blockchain-to-revolutionize-the-travel-industry/\">pioneering ways to connect hoteliers and customers directly</a>. That way, they can transact via blockchain in an easy, safe and consistent way, rather than via a central booking platform.</li>\n<li><strong>Record Secure Transactions Between Partners To Ensure Trust</strong><br />A traditional database may be good for recording simple transactions between two parties, but when things get more complicated, blockchain can help reduce bottlenecks and simplify relationships. What’s more, the added security of a decentralized system makes blockchain ideal for transactions in general.<br />An example is the University Of Melbourne that <a href=\"https://about.unimelb.edu.au/newsroom/news/2017/october/university-of-melbourne-to-issue-recipient-owned-blockchain-records\">started storing its records in blockchain</a>. The most promising use case for blockchain in higher education is to transform the “record-keeping” of degrees, certificates, and diplomas. This saves a lot of cost from dedicated servers for storage or records.</li>\n<li><strong>Keeping Records Of Past Actions For Applications Where Data Is In Constant Flux</strong><br />Blockchain is a better, safer way to record the activity and keep data fresh while maintaining a record of its history. The data can’t be corrupted by anyone or accidentally deleted, and you benefit from both a historical trail of data, plus an instantly up-to-date record. An example of a good use case is blockchain in e-commerce, both blockchain and e-commerce involve transactions.<br />Blockchain makes these transactions safer and faster while e-commerce activities rely on them. Blockchain technology enables users to share and <a href=\"https://cointelegraph.com/news/bringing-blockchain-technology-to-e-commerce-current-trends\">securely store digital assets</a> both automatically and manually. This technology has the capacity to handle user activities such as payment processing, product searches, product purchases, and customer care. It also reduces the expenses spent on inventory management and payment processing.</li>\n<li><strong>Decentralisation Makes It Possible To Be Used Anywhere</strong><br />Unlike before where we have to restrict ourselves to a particular region due to various reasons like currency exchange policies, limitations of payment gateways makes access to financial resources of many countries not in your region or continent hard. With the rise and power of blockchain’s decentralization or peer-to-peer system, this becomes easier to work with other countries.<br />For example, an e-commerce store in Europe can have consumers in Africa and not require a middleman to process their payment requests. Furthermore, these technologies are opening doors for online retailers to make use of the consumer markets in faraway countries with bitcoin, i.e. a cryptocurrency.</li>\n<li><strong>Blockhain Is Technology-Neutral</strong><br />Blockchain works with all and any technology stack being used by a developer. You don’t have to learn Node as a Python dev to use blockchain or learn Golang. This makes blockchain very easy to use.<br />We can actually use it directly with our front-end apps in Vue/React with the blockchain acting as our sole database for simple uncomplicated tasks and use cases like uploading data or getting hashes for displaying records for our users, or building frontend games like casino games and betting games (in which a high amount of trust is needed). Also, with the power of web3, we can store data in the chain directly.</li>\n</ul>\n<p>Now, we have seen quite a number of the advantages of using blockchain, but when should we not bother using a blockchain at all?</p>\n<h3>Disadvantages Of Blockchain</h3>\n<ul>\n<li><strong>Reduced Speed For Digital Transaction</strong><br />Blockchains require huge amounts of computing power, which tends to reduce the speed of digital transactions, though there are workarounds it is advisable to use centralized databases when in need of high-speed transactions in milliseconds.</li>\n<li><strong>Data Immutability</strong><br />Data immutability has always been one of the biggest disadvantages of the blockchain. It is clear that multiple systems benefit from it including supply chain, financial systems, and so on. However, it suffers from the fact that once data is written, it cannot be removed. Every person on the earth has the right to privacy. However, if the same person utilizes a digital platform that runs on blockchain technology, then he will be unable to remove its trace from the system when he doesn’t want it there. In simple words, there is no way that he can remove his trace — leaving privacy rights into pieces.</li>\n<li><strong>Requires Expertise Knowledge</strong><br />Implementing and managing a blockchain project is hard. It requires thorough knowledge to go through the whole process. This is why it is hard to come across blockchain specialists or experts because it takes a lot of time and effort to train a blockchain expert. Hence this article is a good place to start and a good guide if you have already started.</li>\n<li><strong>Interoperability</strong><br />Multiple blockchain networks working hard to solve the distributed ledger problem uniquely makes it hard to relate them or integrate them with each other. This makes communication between different chains hard.</li>\n<li><strong>Legacy Applications Integration</strong><br />Many businesses and applications still use legacy systems and architecture; adopting blockchain technology requires a complete overhaul of these systems which I must say is not feasible for many of them.</li>\n</ul>\n<p>Blockchain is still evolving and maturing all the time so don’t be surprised if these cons mentioned today become transformed to a pro later on. Bitcoin which is a cryptocurrency is one popular example of a blockchain, a popular blockchain that has been on the rise aside from bitcoin cryptocurrency is Ethereum blockchain. Bitcoin focuses on cryptocurrencies while Ethereum focuses more on smart contracts which have been the major driving force for the new tech platforms.</p>\n<p><strong>Recommended reading</strong>: <em><a href=\"https://www.investopedia.com/articles/investing/031416/bitcoin-vs-ethereum-driven-different-purposes.asp\">Bitcoin vs. Ethereum: What’s the Difference?</a></em></p>\n\n<h3>Let’s Start Building Our API</h3>\n<p>With a solid understanding of blockchain, now let's look at how to build an Ethereum blockchain and integrate it into a standard API in Node.js. The ultimate goal is to get a good understanding of how dApps and Blockchain platforms are being built.</p>\n<p>Most dApps have similar architecture and structure. Basically, we have a user that interacts with the dApp frontend — either web or mobile — which then interacts with the backend APIs. The backend, then, on request interacts with the smart contract(s) or blockchain through public nodes; these either run Node.js applications or the backend uses blockchain by directly running the Node.js software. There are still so many things in between these processes from choosing to build a fully decentralized application or semi-decentralized application to choosing what should be decentralized and how to safely store private keys.</p>\n<p><strong>Recommended reading</strong>: <em><a href=\"https://www.freecodecamp.org/news/how-to-design-a-secure-backend-for-your-decentralized-application-9541b5d8bddb/\">Decentralized Applications Architecture: Back End, Security and Design Patterns</a></em></p>\n\n<h3>Things We Should Know First</h3>\n<p>For this tutorial, we’re going to try to build the backend of a <strong>decentralized music store app</strong> that uses the power of Ethereum blockchain for storing music and sharing it for downloads or streaming.</p>\n<p>The basic structure of the application we’re trying to build has three parts:</p>\n<ol>\n<li><strong>Authentication</strong>, which is done by email; of course we need to add an encrypted password to the app.</li>\n<li><strong>Storage of data</strong>, with the music data is first stored in <a href=\"https://ipfs.io/\">ipfs</a> and the storage address is stored in the blockchain for retrieval.</li>\n<li><strong>Retrieval</strong>, with any authenticated user being able to access the stored data on our platform and use it.</li>\n</ol>\n<p>We will be building this with Node.js, but you can also build with Python or any other programming language. We’ll also see how to store media data in <a href=\"https://ipfs.io/\">IPFS</a>, get the address and write functions to store this address in — and retrieve this address from a blockchain with the Solidity programming language.</p>\n<p>Here are some tools that we should have at our disposal for building or working with Ethereum and Node.js.</p>\n<ul>\n<li><strong>Node.js</strong><br />The first requirement is a Node application. We are trying to build a Node.js app, so we need a compiler. Please make sure you have <a href=\"https://nodejs.org\">Node.js</a> installed — and please download the latest long term support binary (<em>LTS</em>).</li>\n<li><strong>Truffle Suite</strong><br />Truffle is a contract development and testing environment, as well as an asset pipeline for Ethereum blockchain. It provides an environment for compiling, pipelining, and running scripts. Once you’re talking about developing blockchain, Truffle is a popular stop to go to. Check out about Truffle Suite on <a href=\"https://www.trufflesuite.com/\">Truffle Suite: Sweet Tools for Smart Contracts</a>.</li>\n<li><strong>Ganache CLI</strong><br />Another tool that works well in hand with Truffle is Ganache-CLI. It's built and maintained by the Truffle Suite team. After building and compiling, you need an emulator to develop and run blockchain apps, and then deploy smart contracts to be used. Ganache makes it easier for you to deploy a contract in an emulator without using actual money for transaction cost, recyclable accounts, and much more. Read more on Ganache CLI at <a href=\"https://docs.nethereum.com/en/latest/ethereum-and-clients/ganache-cli/\">Ganache CLI</a> and <a href=\"https://www.trufflesuite.com/ganache\">Ganache</a>.</li>\n<li><strong>Remix</strong><br />Remix is like an alternative to Ganache, but also comes with a GUI to help navigate deploying and testing of Ethereum smart contracts. You can learn more about it on <a href=\"https://remix-project.org/\">Remix — Ethereum IDE &amp; community</a>. All you have to do is to visit <a href=\"https://remix.ethereum.org\">https://remix.ethereum.org</a> and use the GUI to write and deploy smart contracts.</li>\n<li><strong>Web3</strong><br />Web3 is a collection of libraries that allows you to interact with an Ethereum node. These could be local or remote nodes of the contract through HTTP, IPC or Web Sockets. <a href=\"https://www.dappuniversity.com/articles/web3-js-intro\">Intro to Web3.js · Ethereum Blockchain Developer Crash Course</a> is a good place to learn a bit about Web3.</li>\n<li><strong>IPFS</strong><br />A core protocol that is being used in building dApps. The <em>InterPlanetary File System</em> (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. <a href=\"https://ipfs.io/\">IPFS Powers the Distributed Web</a> explains more on IPFS and how it’s usually used.</li>\n</ul>\n<h3>Creating A Backend API From Scratch</h3>\n<p>So first we have to create a backend to be used, and we’re using Node.js. When we want to create a new Node.js API, the first thing we’re going to do is initialize an npm package. As you probably know, <a href=\"https://www.npmjs.com/\">npm</a> stands for <em>Node Package Manager</em>, and it comes prepackaged with the Node.js binary. So we create a new folder and call it <em>“blockchain-music”</em>. We open the terminal in that folder directory, and then run the following command:</p>\n<pre><code>$ npm init -y &amp;&amp; touch server.js routes.js\n</code></pre>\n\n<p>This starts up the project with a <em>package.json</em> file and answers <em>yes</em> to all prompts. Then we also create a <em>server.js</em> file and a <em>routes.js</em> file for writing the <code>routes</code> functions in the API.</p>\n<p>After all these, you will have to install packages that we need to make our build easy and straightforward. This process is a continuous one, i.e. you can install a package any time during the development of your project.</p>\n<p>Let’s install the most important ones we need right now:</p>\n<ul>\n<li><a href=\"https://expressjs.com/en/starter/installing.html\">Express.js</a></li>\n<li><a href=\"https://github.com/trufflesuite/truffle/tree/master/packages/contract#readme\">@truffle/contract</a></li>\n<li><a href=\"https://www.trufflesuite.com/docs/truffle/getting-started/installation\">Truffle.js</a></li>\n<li><a href=\"https://web3js.readthedocs.io/en/v1.3.0/getting-started.html#adding-web3-js\">web3.js</a></li>\n<li><a href=\"https://github.com/motdotla/dotenv#readme\">dotenv</a></li>\n<li><a href=\"https://github.com/UmbraEngineering/short-id#readme\"><code>short-id</code></a></li>\n<li><a href=\"https://docs.mongodb.com/guides/server/install/\">MongoDB</a></li>\n<li><a href=\"https://nodemon.io/\">nodemon</a></li>\n</ul>\n<p>You’ll also have to install Truffle.js <em>globally</em>, so you can use it everywhere in your local environment. If you want to install all of them at once, run the following code in your Terminal:</p>\n<pre><code>$ npm install nodemon truffle-contract dotenv mongodb shortid express web3 --save &amp;&amp; npm install truffle -g\n</code></pre>\n\n<p>The <code>--save</code> flag is to save the package's name in the <em>package.json</em> file. The <code>-g</code> flag is to store this particular package globally, so that we can use it in any project we are going to work on.</p>\n<p>We then create an <em>.env</em> file where we can store our MongoDB database secret URI for use. We do so by running <em>touch.env</em> in the Terminal. If you don’t have a database account with MongoDB yet, start with the <a href=\"https://www.mongodb.com/\">MongoDB page</a> first.</p>\n<p>The <em>dotenv</em> package exports our stored variable to the Node.js process environment. Please make sure that you don’t push the <em>.env</em> file when pushing to public repositories to avoid leaking your passwords and private data.</p>\n<p>Next, we have to add scripts for build and development phases of our project in our <em>package.json</em> file. Currently our <em>package.json</em> looks like this:</p>\n<pre><code>{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"server.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"socket.io\": \"^2.3.0\",\n    \"truffle-contract\": \"^4.0.31\",\n    \"web3\": \"^1.3.0\"\n  }\n}\n</code></pre>\n\n<p>We’re then going to add a start script to the <em>package.json</em> file to use the nodemon server so that whenever we make change it restarts the server itself, and a build script that uses the node server directly, it could look like this:</p>\n<pre><code>{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"server.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n    \"start\": \"nodemon server.js\",\n    \"build\": \"node server.js\"\n\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"socket.io\": \"^2.3.0\",\n    \"truffle-contract\": \"^4.0.31\",\n    \"web3\": \"^1.3.0\"\n  }\n}\n</code></pre>\n\n<p>Next, we have to initialize Truffle for use in our smart contract by using the Truffle package we installed globally earlier. In the same folder of our projects, we run the following command below in our terminal:</p>\n<pre><code>$ truffle init\n</code></pre>\n\n<p>Then we can start writing our code in our <em>server.js</em> file. Again, we’re trying to build a simple decentralized music store app, where customers can upload music for every other user to access and listen to.</p>\n<p>Our <em>server.js</em> should be clean for easy coupling and decoupling of components, so routes and other functionalities will be put in other files like the <em>routes.js</em>. Our example <em>server.js</em> could be:</p>\n<div>\n <pre><code>require('dotenv').config();\nconst express= require('express')\nconst app =express()\nconst routes = require('./routes')\nconst Web3 = require('web3');\nconst mongodb = require('mongodb').MongoClient\nconst contract = require('truffle-contract');\napp.use(express.json())\n\nmongodb.connect(process.env.DB,{ useUnifiedTopology: true },(err,client)=&gt;{\n    const db =client.db('Cluster0')\n    //home\n    routes(app,db)\n    app.listen(process.env.PORT || 8082, () =&gt; {\n        console.log('listening on port 8082');\n     })\n})\n</code></pre>\n</div>\n\n<p>Basically, above we import the libraries that we need with <code>require</code>, then add a middleware that allows the use of JSON in our API using <code>app.use</code>, then connect to our MongoDB database and get the database access, and then we specify which database cluster we’re trying to access (for this tutorial it is <em>“Cluster0”</em>). After this, we call the function and import it from the <em>routes file</em>. Finally, we listen for any attempted connections on port <code>8082</code>.</p>\n<p>This <em>server.js</em> file is just a barebone to get the application started. Notice that we imported <em>routes.js</em>. This file will hold the route endpoints for our API. We also imported the packages we needed to use in the <em>server.js</em> file and initialized them.</p>\n<p>We’re going to create <strong>five endpoints</strong> for user consumption:</p>\n<ol>\n    <li>Registration endpoint for registering users just via email. Ideally, we'd do so with an email and password, but as we just want to identify each user, we’re not going to venture into password security and hashing for the sake of the brevity of this tutorial.<br />\n\n<pre><code>POST /register\nRequirements: email\n</code></pre>\n</li>\n<li>Login endpoint for users by email.<br />\n\n<pre><code>POST /login\nRequirements: email\n</code></pre>\n</li>\n<li>Upload endpoint for users — the API that gets the data of the music file. The frontend will convert the MP3/WAV files to an audio buffer and send that buffer to the API.<br />\n\n<pre><code>POST /upload\nRequirements: name, title of music, music file buffer or URL stored\n</code></pre>\n</li>\n<li>Access endpoint that will provide the music buffer data to any registered user that requests it, and records who accessed it.<br />\n\n<pre><code>GET /access/{email}/{id}\nRequirements: email, id\n</code></pre>\n</li>\n<li>We also want to provide access to the entire music library and return the results to a registered user.<br />\n\n<pre><code>GET /access/{email}\nRequirements: email\n</code></pre>\n</li>\n</ol>\n\n<p>Then we write our route functions in our <em>routes.js</em> file. We utilize the database storage and retrieval features, and then make sure we export the route function at the end of the file to make it possible to be imported in another file or folder.</p>\n<div>\n <pre><code>const shortid = require('short-id')\nfunction routes(app, db){\n    app.post('/register', (req,res)=&gt;{\n        let email = req.body.email\n        let idd = shortid.generate()\n        if(email){\n            db.findOne({email}, (err, doc)=&gt;{\n                if(doc){\n                    res.status(400).json({\"status\":\"Failed\", \"reason\":\"Already registered\"})\n                }else{\n                    db.insertOne({email})\n                    res.json({\"status\":\"success\",\"id\":idd})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.post('/login', (req,res)=&gt;{\n        let email = req.body.email\n        if(email){\n            db.findOne({email}, (err, doc)=&gt;{\n                if(doc){\n                    res.json({\"status\":\"success\",\"id\":doc.id})\n                }else{\n                    res.status(400).json({\"status\":\"Failed\", \"reason\":\"Not recognised\"})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.post('/upload', (req,res)=&gt;{\n        let buffer = req.body.buffer\n        let name = req.body.name\n        let title = req.body.title\n        if(buffer &amp;&amp; title){\n\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.get('/access/:email/:id', (req,res)=&gt;{\n        if(req.params.id &amp;&amp; req.params.email){\n\n\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n}\nmodule.exports = routes\n</code></pre>\n</div>\n\n<p>Inside this <code>route</code> function, we have many other functions called within both the <code>app</code> and <code>db</code> parameters. These are the API endpoint functions that enable users to specify an endpoint in the URL. Ultimately we choose one of these functions to be executed and provide results as response to incoming requests.</p>\n<p>We have four major endpoint functions:</p>\n<ol>\n<li><code>get</code>: for reading record operations</li>\n<li><code>post</code>: for creating record operations</li>\n<li><code>put</code>: for updating record operations</li>\n<li><code>delete</code>: for deleting record operations</li>\n</ol>\n<p>In this <code>routes</code> function, we used the <code>get</code> and <code>post</code> operations. We use <code>post</code> for registration, login, and upload operations, and <code>get</code> for accessing the data operations. For a little bit more explanation on that, you can check out Jamie Corkhill’s article on “<a href=\"https://www.smashingmagazine.com/2019/02/node-api-http-es6-javascript/\">How To Get Started With Node: An Introduction To APIs, HTTP And ES6+ JavaScript</a>”.</p>\n<p>In the code above, we can also see some database operations like in the <em>register</em> route. We stored the email of a new user with <code>db.createa</code> and checked for the email in the login function with <code>db.findOne</code>. Now, before we can do all of it, we need to name a collection or table with the <code>db.collection</code> method. That's exactly what we'll be covering next.</p>\n<p><strong>Note</strong>: <em>To learn more about the database operations in MongoDB, check the <a href=\"https://docs.mongodb.com/manual/reference/method/\">mongo Shell Methods</a> documentation.</em></p>\n<h3>Building A Simple Blockchain Smart Contract With Solidity</h3>\n<p>Now we’re going to write a Blockchain contract in Solidity (that's the language that smart contracts are written in) to simply store our data and retrieve it when we need it. The data we want to store is the music file data, meaning that we have to upload the music to IPFS, then store the address of the buffer in a blockchain.</p>\n<p>First, we create a new file in the contract folder and name it <em>Inbox.sol</em>. To write a smart contract, it's useful to have a good understanding of Solidity, but it’s not difficult as it’s similar to JavaScript.</p>\n<p><strong>Note</strong>: <em>If you’re interested in learning more about Solidity, I’ve added a few resources at the bottom of the article to get you started.</em></p>\n<div>\n <pre><code>pragma solidity ^0.5.0;\n\n\ncontract Inbox{\n    //Structure\n    mapping (string=&gt;string) public ipfsInbox;\n    //Events\n    event ipfsSent(string _ipfsHash, string _address);\n    event inboxResponse(string response);\n    //Modifiers\n    modifier notFull (string memory _string) {\n    bytes memory stringTest = bytes(_string);\n    require(stringTest.length==0);\n    _;\n    }\n    // An empty constructor that creates an instance of the conteact\n    constructor() public{}\n    //takes in receiver's address and IPFS hash. Places the IPFSadress in the receiver's inbox\n    function sendIPFS(string memory _address, string memory _ipfsHash) notFull(ipfsInbox[_address]) public{\n        ipfsInbox[_address] = _ipfsHash;\n        emit ipfsSent(_ipfsHash, _address);\n    }\n    //retrieves hash\n    function getHash(string memory _address) public view returns(string memory) {\n        string memory ipfs_hash=ipfsInbox[_address];\n         //emit inboxResponse(ipfs_hash);\n        return ipfs_hash;\n    }\n}\n</code></pre>\n</div>\n\n<p>In our contract, we have two main functions: the <code>sendIPFS</code> and the <code>getHash</code> functions. Before we talk about the functions, we can see that we had to define a contract first called <code>Inbox</code>. Inside this class, we have structures used in the <code>ipfsInbox</code> object (first events, then modifiers).</p>\n<p>After defining the structures and events, we have to initialize the contract by calling the <code>constructor</code> function. Then we defined three functions. (The <code>checkInbox</code> function was used in the test for testing results.)</p>\n<p>The <code>sendIPFS</code> is where the user inputs the identifier and hash address after which it is stored on the blockchain. The <code>getHash</code> function retrieves the hash address when it is given the identifier. Again, the logic behind this is that we ultimately want to store the music in IPFS. To test how it works, you can hop on to a <a href=\"https://remix.ethereum.org\">Remix IDE</a>, copy, paste, and test your contract, as well as debug any errors and run again (hopefully it won't be needed!).</p>\n<p>After testing that our code works correctly in the remix, let’s move on to compiling it locally with the Truffle suite. But first, we need to make some changes to our files and set up our emulator using <code>ganache-cli</code>:</p>\n<p>First, let’s install <code>ganache-cli</code>. In the same directory, run the following command in your terminal:</p>\n<pre><code>$ npm install ganache-cli -g\n</code></pre>\n\n<p>Then let's open another Terminal and run another command in the same folder:</p>\n<pre><code>$ ganache-cli\n</code></pre>\n\n<p>This starts up the emulator for our blockchain contract to connect and work. Minimize the Terminal and continue with the other Terminal you’ve been using.</p>\n<p>Now go to the <em>truffle.js</em> file if you’re using a Linux/Mac OS or <em>truffle-config.js</em> in Windows, and modify this file to look like this:</p>\n<pre><code>const path = require(\"path\");\nmodule.exports = {\n  // to customize your Truffle configuration!\n  contracts_build_directory: path.join(__dirname, \"/build\"),\n  networks: {\n    development: {\n      host: \"127.0.0.1\",\n      port: 8545,\n      network_id: \"*\" //Match any network id\n    }\n  }\n};\n</code></pre>\n\n<p>Basically what we did is adding the path of the build folder where the smart contract is converted to JSON files. Then we also specified the network that Truffle should use for migration.</p>\n<p>Then, also in the <em>migrations</em> folder, create a new file named <em>2_migrate_inbox.js</em> and add the following code inside the files:</p>\n<pre><code>var IPFSInbox = artifacts.require(\"./Inbox.sol\");\nmodule.exports = function(deployer) {\n    deployer.deploy(IPFSInbox);\n};\n</code></pre>\n\n<p>We did so to get the contract file and deploy it automatically to a JSON, using the <code>deployer</code> function during the Truffle migration.</p>\n<p>After the above changes we run:</p>\n<pre><code>$ truffle compile\n</code></pre>\n\n<p>We should see some messages at the end which show successful compilation, such as:</p>\n<pre><code>&gt; Compiled successfully using:\n    - solc: 0.5.16+commit.9c3226ce.Emscripten.clang\n</code></pre>\n\n<p>Next, we migrate our contract by running:</p>\n<pre><code>$ truffle migrate\n</code></pre>\n\n<p>Once we have successfully migrated our contracts, we should have something like this at the end:</p>\n<pre><code>Summary\n=======\n&gt; Total deployments:   1\n&gt; Final cost:          0.00973432 ETH\n</code></pre>\n\n<p>And we’re almost done! We have built our API with Node.js, and also set up and built our smart contract.</p>\n<p>We should also write tests for our contract to test the behaviour of our contract and ensure it is the desired behaviour. The tests are usually written and placed in the <code>test</code> folder. An example test written in a file named <em>InboxTest.js</em> created in the test folder is:</p>\n<div>\n <pre><code>const IPFSInbox = artifacts.require(\"./Inbox.sol\")\ncontract(\"IPFSInbox\", accounts =&gt;{\n    it(\"emit event when you send a ipfs address\", async()=&gt;{\n        //ait for the contract\n        const ipfsInbox = await IPFSInbox.deployed()\n\n        //set a variable to false and get event listener\n        eventEmitted = false\n        //var event = ()\n        await ipfsInbox.ipfsSent((err,res)=&gt;{\n            eventEmitted=true\n        })\n        //call the contract function  which sends the ipfs address\n        await ipfsInbox.sendIPFS(accounts[1], \"sampleAddress\", {from: accounts[0]})\n        assert.equal(eventEmitted, true, \"sending an IPFS request does not emit an event\")\n    })\n})\n</code></pre>\n</div>\n\n<p>So we run our test by running the following:</p>\n<pre><code>$ truffle test\n</code></pre>\n\n<p>It tests our contract with the files in the <em>test</em> folder and shows the number of passed and failed tests. For this tutorial, we should get:</p>\n<div>\n <pre><code>$ truffle test\nUsing network 'development'.\nCompiling your contracts...\n===========================\n&gt; Compiling .\\contracts\\Inbox.sol\n&gt; Artifacts written to C:\\Users\\Ademola\\AppData\\Local\\Temp\\test--2508-n0vZ513BXz4N\n&gt; Compiled successfully using:\n   — solc: 0.5.16+commit.9c3226ce.Emscripten.clang\n\n  Contract: IPFSInbox\n    √ emit event when you send an ipfs address (373ms)\n\n  1 passing (612ms)\n</code></pre>\n</div>\n\n<h3>Integrating The Smart Contract To The Backend API Using Web3</h3>\n<p>Most times when you see tutorials, you see decentralized apps built to integrate the frontend directly to the blockchain. But there are times when the integration to the backend is needed as well, for example when using third-party backend APIs and services, or when using blockchain to build a CMS.</p>\n<p>The use of Web3 is very important to this cause, as it helps us access remote or local Ethereum nodes and use them in our applications. Before we go on, we’ll discuss the local and remote Ethereum nodes. The local nodes are the nodes deployed on our system with emulators like <code>ganache-cli</code> but a remote node is one that is deployed on online faucets/platforms like <em>ropsten</em> or <em>rinkeby</em>. To dive in deeper, you can follow a tutorial on how to deploy on ropsten <a href=\"https://medium.com/coinmonks/5-minute-guide-to-deploying-smart-contracts-with-truffle-and-ropsten-b3e30d5ee1e\">5-minute guide to deploying smart contracts with Truffle and Ropsten</a> or you could use truffle wallet provider and deploy via <a href=\"https://www.trufflesuite.com/blog/an-easier-way-to-deploy-your-smart-contracts\">An Easier Way to Deploy Your Smart Contracts</a>.</p>\n<p>We are using <code>ganache-cli</code> in this tutorial, but if we were deploying on ropsten, we should have copied or stored our contract address somewhere like in our .env file, then move on to update the <em>server.js</em> file, import web3, import the migrated contract and set up a Web3 instance.</p>\n<div>\n <pre><code>require('dotenv').config();\nconst express= require('express')\nconst app =express()\nconst routes = require('./routes')\nconst Web3 = require('web3');\nconst mongodb = require('mongodb').MongoClient\nconst contract = require('truffle-contract');\nconst artifacts = require('./build/Inbox.json');\napp.use(express.json())\nif (typeof web3 !== 'undefined') {\n    var web3 = new Web3(web3.currentProvider)\n  } else {\n    var web3 = new Web3(new Web3.providers.HttpProvider('<a href=\"http://localhost:8545')\">http://localhost:8545')</a>)\n}\nconst LMS = contract(artifacts)\nLMS.setProvider(web3.currentProvider)\nmongodb.connect(process.env.DB,{ useUnifiedTopology: true }, async(err,client)=&gt;{\n    const db =client.db('Cluster0')\n    const accounts = await web3.eth.getAccounts();\n    const lms = await LMS.deployed();\n    //const lms = LMS.at(contract_address) for remote nodes deployed on ropsten or rinkeby\n    routes(app,db, lms, accounts)\n    app.listen(process.env.PORT || 8082, () =&gt; {\n       console.log('listening on port '+ (process.env.PORT || 8082));\n     })\n})\n</code></pre>\n</div>\n\n<p>In the <em>server.js</em> file, we check if the web3 instance is initialized already. If not, we initialize it on the network port which we defined earlier (<code>8545</code>). Then we build a contract based on the migrated JSON file and <code>truffle-contract</code> package, and set the contract provider to the Web3 instance provider which must have been initialized by now.</p>\n<p>We then get accounts by <code>web3.eth.getAccounts</code>. For the development stage, we call the deployed function in our contract class that asks <code>ganache-cli</code> — which is still running — to give us a contract address to use. But if we’ve already deployed our contract to a remote node, we call a function inputting the address as an argument. The sample function is commented below the defined <code>lms</code> variable in our code above. Then we call the <code>routes</code> function inputting the app instance, database instance, contract instance (<code>lms</code>), and accounts data as arguments. Finally, we listen for requests on port <code>8082</code>.</p>\n<p>Also, by now, we should have installed the MongoDB package, because we are using it in our API as our database. Once we have that, we move onto the routes page where we use the methods defined in the contract to accomplish tasks like saving and retrieving the music data.</p>\n<p>In the end, our routes.js should look like this:</p>\n<div>\n <pre><code>const shortid = require('short-id')\nconst IPFS =require('ipfs-api');\nconst ipfs = IPFS({ host: 'ipfs.infura.io',\n    port: 5001,protocol: 'https' });\n\nfunction routes(app, dbe, lms, accounts){\n    let db= dbe.collection('music-users')\n    let music = dbe.collection('music-store')\n    app.post('/register', (req,res)=&gt;{\n        let email = req.body.email\n        let idd = shortid.generate()\n        if(email){\n            db.findOne({email}, (err, doc)=&gt;{\n                if(doc){\n                    res.status(400).json({\"status\":\"Failed\", \"reason\":\"Already registered\"})\n                }else{\n                    db.insertOne({email})\n                    res.json({\"status\":\"success\",\"id\":idd})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n\n    app.post('/login', (req,res)=&gt;{\n        let email = req.body.email\n        if(email){\n            db.findOne({email}, (err, doc)=&gt;{\n                if(doc){\n                    res.json({\"status\":\"success\",\"id\":doc.id})\n                }else{\n                    res.status(400).json({\"status\":\"Failed\", \"reason\":\"Not recognised\"})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.post('/upload', async (req,res)=&gt;{\n        let buffer = req.body.buffer\n        let name = req.body.name\n        let title = req.body.title\n        let id = shortid.generate() + shortid.generate()\n        if(buffer &amp;&amp; title){\n            let ipfsHash = await ipfs.add(buffer)\n            let hash = ipfsHash[0].hash\n            lms.sendIPFS(id, hash, {from: accounts[0]})\n            .then((_hash, _address)=&gt;{\n                music.insertOne({id,hash, title,name})\n                res.json({\"status\":\"success\", id})\n            })\n            .catch(err=&gt;{\n                res.status(500).json({\"status\":\"Failed\", \"reason\":\"Upload error occured\"})\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.get('/access/:email', (req,res)=&gt;{\n        if(req.params.email){\n            db.findOne({email: req.body.email}, (err,doc)=&gt;{\n                if(doc){\n                    let data = music.find().toArray()\n                    res.json({\"status\":\"success\", data})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n    app.get('/access/:email/:id', (req,res)=&gt;{\n      let id = req.params.id\n        if(req.params.id &amp;&amp; req.params.email){\n            db.findOne({email:req.body.email},(err,doc)=&gt;{\n                if(doc){\n                    lms.getHash(id, {from: accounts[0]})\n                    .then(async(hash)=&gt;{\n                        let data = await ipfs.files.get(hash)\n                        res.json({\"status\":\"success\", data: data.content})\n                    })\n                }else{\n                    res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n                }\n            })\n        }else{\n            res.status(400).json({\"status\":\"Failed\", \"reason\":\"wrong input\"})\n        }\n    })\n}\n\nmodule.exports = routes\n</code></pre>\n</div>\n\n<p>At the beginning of the <em>routes</em> file, we imported the <code>short-id</code> package and <code>ipfs-http-client</code> and then initialized IPFS with the HTTP client using the backend URL <code>ipfs.infura.io</code> and port <code>5001</code>. This allowed us to use the IPFS methods to upload and retrieve data from IPFS (<a href=\"https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-http-client\">check out more here</a>).</p>\n<p>In the upload route, we save the audio buffer to IPFS which is better compared to just storing it on the blockchain for anyone registered or unregistered to use. Then we saved the address of the buffer in the blockchain by generating an ID and using it as an identifier in the <code>sendIFPS</code> function. Finally, then we save all the other data associated with the music file to our database. We should not forget to update our argument in the routes function since we changed it in the <em>server.js</em> file.</p>\n<p>In the access route using <code>id</code>, we then retrieve our data by getting the <code>id</code> from the request, using the <code>id</code> to access the IPFS hash address, and then access the audio buffer using the address. But this requires authentication of a user by email which is done before anything else.</p>\n<p>Phew, <strong>we’re done</strong>! Right now we have an API that can receive requests from users, access a database, and communicate to a node that has the software running on them. We shouldn’t forget that we have to export our function with <code>module.exports</code> though!</p>\n<p>As we have noticed, our app is a <strong>decentralized app</strong>. However, it's not fully decentralized as we only stored our address data on the blockchain and every other piece of data was stored securely in a centralized database which is the basis for <em>semi-dApps</em>. So the consumption of data can be done directly via request or using a frontend application in JavaScript to send fetch requests.</p>\n<p>Our music store backend app can now safely store music data and provide access to anyone who needs to access it, provided it is a registered user. Using blockchain for music sharing makes it cheaper to store music data while focusing on connecting artists directly with users, and perhaps it could help them generate revenue that way. This wouldn't require a middleman that uses royalty; instead, all of the revenue would go to the artist as users request their music to either download or stream. A good example of a music streaming application that uses blockchain just like this is Opus <a href=\"https://opus.audio/\">OPUS: Decentralized music sharing platform</a>. However, there are also a few others like Musicoin, Audius, and Resonate.</p>\n<h3>What Next?</h3>\n<p>The final thing after coding is to start our server by running <code>npm run start</code> or <code>npm run build</code> and test our backend endpoints on either the browser or with Postman. After running and testing our API we could add more features to our backend and blockchain smart contract. If you'd like to get more guidance on that, please check the further reading section for more articles.</p>\n<p>It's worth mentioning that it is critical to write unit and integration tests for our API to ensure correct and desirable behaviors. Once we have all of that done, we can deploy our application on the cloud for public use. This can be done on its own with or without adding a frontend (microservices) on Heroku, GCP, or AWS for public use. <em>Happy coding!</em></p>\n<p><strong>Note</strong>: <em>You can always <a href=\"https://github.com/agbanusi/Music-share-platform-through-Blockchain\">check my repo for reference</a>. Also, please note that the .env file containing the MongoDB database URI is included for security reasons.</em></p>\n<h4>Further Reading And Related Resources</h4>\n<ul>\n<li>“<a href=\"https://www.dappuniversity.com/articles/ethereum-dapp-react-tutorial\">How to Build Ethereum Dapp with React.js: Complete Step-By-Step Guide</a>,” Gregory McCubbin</li>\n<li>“<a href=\"https://blog.goodaudience.com/ethereum-ipfs-react-dapp-tutorial-pt-1-a9dfd5079491\">Ethereum + IPFS + React DApp Tutorial Pt. 1</a>,” Alexander Ma</li>\n<li>“<a href=\"https://goethereumbook.org/en/\">Ethereum Development with Go</a>,” Miguel Mota</li>\n<li>“<a href=\"https://itnext.io/create-your-first-ethereum-dapp-with-web3-and-vue-js-c7221af1ed82\">Create your first Ethereum dAPP with Web3 and Vue.JS (Part 1)</a>,” Nico Vergauwen</li>\n<li>“<a href=\"https://dev.to/gcrsaldanha/deploy-a-smart-contract-on-ethereum-with-python-truffle-and-web3py-5on\">Deploy a Smart Contract on Ethereum with Python, Truffle and web3py</a>,” Gabriel Saldanha</li>\n<li>“<a href=\"https://www.bernardmarr.com/default.asp?contentID=1786\">Why Use Blockchain Technology?</a>,” Bernard Marr</li>\n<li>“<a href=\"https://www.devteam.space/blog/how-to-build-your-own-blockchain-using-node-js/\">How To Build Your Own Blockchain Using Node.js</a>,” DevTeam.Space</li>\n<li>“<a href=\"https://www.dappuniversity.com/articles/how-to-build-a-blockchain-app\">How To Build A Blockchain App With Ethereum, Web3.js &amp; Solidity Smart Contracts</a>,” Gregory McCubbin</li>\n<li>“<a href=\"https://www.smashingmagazine.com/2020/02/cryptocurrency-blockchain-node-js/\">How To Build A Simple Cryptocurrency Blockchain In Node.js</a>,” Alfrick Opidi</li>\n<li>“<a href=\"https://www.eteam.io/blog/blockchain-and-ecommerce\">How Blockchain Technology Is Going To Revolutionize Ecommerce</a>,” Sergii Shanin</li>\n<li>“<a href=\"https://www.gartner.com/smarterwithgartner/4-ways-blockchain-will-transform-higher-education/\">4 Ways Blockchain Will Transform Higher Education — Smarter With Gartner</a>,” Susan Moore</li>\n<li>“<a href=\"https://blockgeeks.com/guides/solidity/\">How To Learn Solidity: The Ultimate Ethereum Coding Tutorial</a>,” Ryan Molecke</li>\n<li>“<a href=\"https://coursetro.com/courses/20/Developing-Ethereum-Smart-Contracts-for-Beginners\">Developing Ethereum Smart Contracts For Beginners</a>,” Coursetro</li>\n<li>“<a href=\"https://ethereum.org/en/learn/\">Learn about Ethereum</a>,” Ethereum official site</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"476341d0f6407d57b7785c6dddf63ab8862a0b399046df6887244161df85b532","category":"Tech"}