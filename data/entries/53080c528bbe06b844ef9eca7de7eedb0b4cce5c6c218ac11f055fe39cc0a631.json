{"title":"Monitoring as Code with Terraform Cloud and Checkly","link":"https://www.hashicorp.com/blog/monitoring-as-code-with-terraform-cloud-and-checkly","date":1619712000000,"content":"<p><em>This guest post was written by Hannes Lenke, co-founder and CEO at <a href=\"https://www.checklyhq.com/\">Checkly</a>, the active monitoring platform for developers.</em></p>\n<p>HashiCorp Terraform Cloud enables you to seamlessly provision infrastructure as code, consolidating configurations in source control and bringing transparency and replayability to a previously manual workflow. The same approach can be used to define the way our APIs and web apps are monitored.</p>\n<p>In this blog post, you will learn how to use Terraform together with Checkly to provision your monitoring setup as code.</p>\n<h2><a href=\"#manual-provisioning-is-a-bottleneck\">»</a><a></a>Manual Provisioning is a Bottleneck</h2>\n<p>But before we dive into how to use Terraform and Checkly together, it’s important to understand the issues created by manual provisioning of monitoring checks.</p>\n<p>The story of the world’s fourth-largest retailer, Germany’s Schwarz Group, which operates the <a href=\"https://www.lidl.com/\">Lidl</a> and <a href=\"https://www.kaufland.com/\">Kaufland</a> grocery store and hypermarket chains, mirrors that of many Checkly customers. At Schwarz Group, several teams relied on manual procedures to manage their monitoring checks across many websites and connected backends, even when Terraform was already being used to manage infrastructure. This clash of approaches presented multiple challenges.</p>\n<h3><a href=\"#handling-checks-at-scale-produces-large-overheads\">»</a><a></a>Handling Checks at Scale Produces Large Overheads</h3>\n<p>The need to provision monitoring checks for multiple large APIs and websites meant internal users had to spend large amounts of time going through repetitive manual flows. With changes being rolled out to the target applications on a daily basis, the cost was significant.</p>\n<h3><a href=\"#low-transparency-makes-cross-team-collaboration-harder\">»</a><a></a>Low Transparency Makes Cross-Team Collaboration Harder</h3>\n<p>Manual flows meant users had to create tickets in order to have new monitoring resources provisioned for them, or request permission in advance to apply the changes themselves. In turn, the central IT team needed to work through different UIs and flows based on the service provider, and the resulting monitoring configurations then lived on separate platforms.</p>\n<p>This made it difficult to maintain consistency across the entire infrastructure while avoiding duplication of effort across teams. It also complicated the task of auditing changes, making it difficult to review wrongly configured monitoring checks, thereby lengthening an important feedback loop.</p>\n<h3><a href=\"#non-agile-workflow-slows-delivery\">»</a><a></a>Non-Agile Workflow Slows Delivery</h3>\n<p>Eventually, the speed of checks-provisioning could not match the pace at which the target applications were evolving. This was the result of a mismatch of approaches:  the CI/CD workflow through which the websites and APIs were iterated upon on one side vs. the fully manual approach on the other. In response to these issues, Schwarz Group’s central services team went looking for an approach that mirrored the existing infrastructure-as-code (IaC) workflow.</p>\n<h2><a href=\"#monitoring-as-code\">»</a><a></a>Monitoring as Code</h2>\n<p>Applying lessons learned from IaC, monitoring as code (MaC) brings check definitions closer to the source code of the application by having them written as code. A declarative approach means that the user does not need to specify <em>how</em> the provisioning happens, or which specific actions and calls need to be made, but rather what the final results should look like.</p>\n<p>This method allows check definitions to live in source control, which in turn boosts cross-team visibility, as sharing access to a repository is often simpler and cheaper than sharing seats on different monitoring-service providers. Additionally, having a history detailing every change increases transparency and makes it easier to roll back changes in case of incidents.</p>\n<p>With software such as Terraform taking over the provisioning of monitoring checks, hundreds or thousands of checks can be created or edited in a matter of seconds. This is a game-changer for development, operations, and DevOps teams, allowing them to reallocate time spent on manual configuration towards improving the coverage and robustness of their monitoring setup.</p>\n<p>According to Andreas Lehr, Team Lead at Schwarz Group IT, \"Checkly integrated with Terraform enables us to quickly create, modify, and deploy API and browser checks for a broad and diverse audience of internal customers. The codified workflow ensures full transparency, thanks to built-in auditing and documentation!\"</p>\n<p>To summarize, MaC is revolutionizing the way monitoring is configured by providing:</p>\n<ol>\n<li>Better scalability through faster, more efficient provisioning</li>\n<li>Increased transparency and easier rollbacks via source control</li>\n<li>Unification of previously fragmented processes in a CI/CD workflow</li>\n</ol>\n<p>Just like the Schwarz Group, any Terraform user can reap the benefits of monitoring as code. In the next section of this post, we will guide you through configuring a MaC setup with Terraform Cloud and Checkly.</p>\n<h2><a href=\"#the-hashicorp-terraform-verified-provider-for-checkly\">»</a><a></a>The HashiCorp Terraform Verified Provider for Checkly</h2>\n<p>The <a href=\"https://registry.terraform.io/providers/checkly/checkly/latest\">HashiCorp Terraform Verified Provider for Checkly </a>allows users to configure API and synthetic monitoring checks as part of their existing infrastructure codebase. These checks then run on a schedule or on-demand to monitor single functionalities or end-to-end user scenarios over time, alerting the responsible contacts as soon as any misbehavior is detected.</p><img src=\"https://www.datocms-assets.com/2885/1619632566-hashicorp-terraform-checkly-horizontal.png\" /><h2><a href=\"#monitoring-apis-as-code\">»</a><a></a>Monitoring APIs as Code</h2>\n<p>Here’s how it works: A Checkly API check makes an HTTP request to an API endpoint and examines the response, ensuring it is both correct and quick enough, according to parameters specified by the user. If these conditions are not met, the user is alerted through channels such as OpsGenie, PagerDuty, Slack, and SMS.</p>\n<p>As an example, let’s create an API check against a demo website. The goal is to ensure the users of the webshop can request a list of available books. The first step is to add the <a href=\"https://registry.terraform.io/providers/checkly/checkly/latest\">Checkly Terraform provider</a>, which we will use to define every aspect of the check, to our Terraform file. In this tutorial, we will do all our work in the <code>main.tf</code> file:</p><pre><code>variable \"checkly_api_key\" {}\n\nterraform {\n  required_providers {\n    checkly = {\n      source = \"checkly/checkly\"\n      version = \"0.8.1\"\n    }\n  }\n}\n\nprovider \"checkly\" {\n  api_key = var.checkly_api_key\n}\n</code></pre><p>We also need to add a resource for the API check. Let's keep things simple and specify a few key parameters, including the name, schedule, locations, and assertions:</p><pre><code>resource \"checkly_check\" \"webstore-list-books\" {\n  name                      = \"list-books\"\n  type                      = \"API\"\n  activated                 = true\n  should_fail               = false\n  frequency                 = 1\n  double_check              = true\n  ssl_check                 = true\n  use_global_alert_settings = true\n  degraded_response_time    = 5000\n  max_response_time         = 10000\n\n  locations = [\n    \"eu-central-1\",\n    \"us-west-1\"\n  ]\n\n  request {\n    url              = \"https://danube-webshop.herokuapp.com/api/books\"\n    follow_redirects = true\n    assertion {\n      source     = \"STATUS_CODE\"\n      comparison = \"EQUALS\"\n      target     = \"200\"\n    }\n    assertion {\n      source     = \"JSON_BODY\"\n      property   = \"$.length\"\n      comparison = \"EQUALS\"\n      target     = \"30\"\n    }\n  }\n}</code></pre><p>We have two assertions against the response here:</p>\n<ol>\n<li>We are asserting that the status code is 200</li>\n<li>We are checking the number of items returned as part of our response to make sure all the data we expect is being sent back.</li>\n</ol>\n<p>Terraform users can have changes in a configuration stored in GitHub automatically applied to a linked Terraform Cloud workspace as soon as they are merged into the master branch. We want every successful push to master on our Git repository to be automatically applied to our Terraform Cloud workspace. For this reason, under <code>Settings &gt; General</code>, our plan is set to <code>Auto apply</code>.</p><img src=\"https://www.datocms-assets.com/2885/1619632542-terraform-cloud-settings.png\" /><p><em>The Apply Method section of the Terraform Cloud workspace's General Settings.</em></p>\n<p>We also need to create a <a href=\"https://app.checklyhq.com/signup\">free account on Checkly</a>. Once that is done, we can fetch our Checkly API key from our Checkly Account Settings…</p><img src=\"https://www.datocms-assets.com/2885/1619639526-failing-danubewebshop.png\" /><p>...and add it as an environment variable on Terraform Cloud, under the Variables section, with the key <code>TF_VAR_checkly_api_key</code>:</p><img src=\"https://www.datocms-assets.com/2885/1619639538-env-variables-checkly.png\" /><p>We can now commit our changes. As soon as we have them merged into the master branch, the current run will appear on our Terraform Cloud dashboard:</p><img src=\"https://www.datocms-assets.com/2885/1619632547-terraform-cloud-run.png\" /><p>Once that is done, we will see our new API check appear on our Checkly dashboard:</p><img src=\"https://www.datocms-assets.com/2885/1619632555-checkly-first-check.png\" /><p>The check will now run every minute, monitoring the status of our endpoint from the locations we selected. Should it fail, it will immediately alert us on our channel(s) of choice:</p><img src=\"https://www.datocms-assets.com/2885/1619639532-checkly-channel-list.png\" /><h2><a href=\"#monitoring-e2e-scenarios\">»</a><a></a>Monitoring E2E scenarios</h2>\n<p>In order to make sure our web app is functional for end users, we need to monitor key user journeys on our frontend as well. Checkly leverages <a href=\"https://pptr.dev/\">Puppeteer</a> and <a href=\"https://playwright.dev/\">Playwright</a> to automatically go through the most important flows of your web app, just like a user would. As soon as one breaks, it will alert you, just like with API checks.</p>\n<p>Let's look at an example: we want to keep an eye on the login flow of our <a href=\"https://danube-webshop.herokuapp.com/\">online bookstore</a>, so we write or <a href=\"https://github.com/checkly/headless-recorder\">record</a> the following script using Playwright:</p><pre><code>const { chromium } = require(\"playwright\");\n\nconst browser = await chromium.launch();\n\nconst context = await browser.newContext();\n\nconst page = await context.newPage();\n\nawait page.goto(\"https://danube-webshop.herokuapp.com/\");\n\nawait page.click(\"#login\");\n\nawait page.type(\"#n-email\", \"user@email.com\");\n\nawait page.type(\"#n-password2\", \"supersecure1\");\n\nawait page.click(\"#goto-signin-btn\");\n\nawait page.waitForSelector(\"#login-message\", { visible: true });\n\nawait browser.close();</code></pre><p>Let's save the file in <code>scripts/login.js</code>, and then reference it in our <code>main.tf</code> file:</p><pre><code>resource \"checkly_check\" \"login\" {\n\n  name                      = \"Login Flow\"\n  type                      = \"BROWSER\"\n  activated                 = true\n  should_fail               = false\n  frequency                 = 10\n  double_check              = true\n  ssl_check                 = false\n  use_global_alert_settings = true\n  locations = [\n    \"us-west-1\",\n    \"eu-central-1\"\n  ]\n\n  script = file(\"${path.module}/scripts/login.js\")\n\n}</code></pre><p>Let's also commit and merge these changes to have them reflected on Checkly:</p><img src=\"https://www.datocms-assets.com/2885/1619632551-checkly-second-check.png\" /><p>Our check is now fully configured and will run every 10 minutes as specified, informing us if anything goes wrong with our login flow.</p>\n<p>We can keep going and add as many checks as we want: Checkly and Terraform Cloud scale seamlessly together, and many users manage thousands of checks.</p>\n<h2><a href=\"#conclusion\">»</a><a></a>Conclusion</h2>\n<p>Monitoring as code extends the benefits of infrastructure as code to monitoring, making complex real-world infrastructure more resilient and delivering a better end-user experience through better observability.</p>\n<p>As shown in the Schwarz Group example, MaC with Terraform Cloud and Checkly help improve reliability through an efficient and transparent workflow, which is a force multiplier for large IT organizations.</p>\n<p>That is it. No matter the size of your team or business, you now know all you need to get started and combine the power of <a href=\"https://www.terraform.io/cloud\">Terraform Cloud</a> and the <a href=\"https://registry.terraform.io/providers/checkly/checkly/latest\">Checkly Terraform provider</a>. Happy monitoring!</p>","author":"Hannes Lenke","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"53080c528bbe06b844ef9eca7de7eedb0b4cce5c6c218ac11f055fe39cc0a631","category":"Tech"}