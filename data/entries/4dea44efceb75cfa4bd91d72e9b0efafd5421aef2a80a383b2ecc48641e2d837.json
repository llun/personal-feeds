{"title":"Creating An Outside Focus And Click Handler React Component","link":"https://smashingmagazine.com/2021/03/outside-focus-click-handler-react-component/","date":1614769200000,"content":"<p>Oftentimes we need to detect when a click has happened outside of an element or when the focus has shifted outside of it. Some of the evident examples for this use case are fly-out menus, dropdowns, tooltips and popovers. Let’s start the process of making this detection functionality.</p>\n<h3>The DOM Way To Detect Outside Click</h3>\n<p>If you were asked to write code <em>to detect if a click happened inside a DOM node or outside of it</em>, what would you do? Chances are you’d use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\"><code>Node.contains</code></a> DOM API. Here’s how MDN explains it:</p>\n<blockquote><p>The <code>Node.contains()</code> method returns a <code>Boolean</code> value indicating whether a node is a descendant of a given node, i.e. the node itself, one of its direct children (<code>childNodes</code>), one of the children’s direct children, and so on.</p></blockquote>\n\n<p>Let’s quickly test it out. Let’s make an element we want to detect outside click for. I’ve conveniently given it a <code>click-text</code> class.</p>\n<pre><code>&lt;section&gt;\n  &lt;div class=\"click-text\"&gt;\n    click inside and outside me\n  &lt;/div&gt;\n&lt;/section&gt;</code></pre>\n\n<pre><code>const concernedElement = document.querySelector(\".click-text\");\n\ndocument.addEventListener(\"mousedown\", (event) =&gt; {\n  if (concernedElement.contains(event.target)) {\n    console.log(\"Clicked Inside\");\n  } else {\n    console.log(\"Clicked Outside / Elsewhere\");\n  }\n});</code></pre>\n\n<p>We did the following things:</p>\n<ol>\n<li>Selected the HTML element with the class <code>click-text</code>.</li>\n<li>Put a mouse down event listener on <code>document</code> and set an event handler callback function.</li>\n<li>In the callback function, we are checking if our concerned element — for which we have to detect outside click — contains the element (including itself) which triggered the <code>mousedown</code> event (<code>event.target</code>). </li>\n</ol>\n<p>If the element which triggered the mouse down event is either our concerned element or any element which is inside the concerned element, it means we have clicked inside our concerned element.</p>\n<p>Let’s click inside and outside of the element in the Codesandbox below, and check the console.</p>\n\n\n<h3>Wrapping DOM Hierarchy Based Detection Logic In A React Component</h3>\n<p>Great! So far we saw how to use DOM’s <code>Node.contains</code> API to detect click outside of an element. We can wrap that logic in a React component. We could name our new React component  <code>OutsideClickHandler</code>. Our <code>OutsideClickHandler</code> component will work like this:</p>\n<div>\n<pre><code>&lt;OutsideClickHandler\n  onOutsideClick={() =&gt; {\n    console.log(\"I am called whenever click happens outside of 'AnyOtherReactComponent' component\")\n  }}\n&gt;\n  &lt;AnyOtherReactComponent /&gt;\n&lt;/OutsideClickHandler&gt;</code></pre>\n</div>\n\n<p><code>OutsideClickHandler</code> takes in two props:</p>\n<ol>\n<li><p><code>children</code><br />It could be any valid React children. In the example above we are passing <code>AnyOtherReactComponent</code> component as <code>OutsideClickHandler</code>’s child.</p>\n</li>\n<li><p><code>onOutsideClick</code><br />This function will be called if a click happens anywhere outside of <code>AnyOtherReactComponent</code> component.</p>\n</li>\n</ol>\n<p>Sounds good so far? Let’s actually start building our <code>OutsideClickHandler</code> component.</p>\n<pre><code>import React from 'react';\n\nclass OutsideClickHandler extends React.Component {\n  render() {\n    return this.props.children;\n  }\n}</code></pre>\n\n<p>Just a basic React component. So far, we are not doing much with it. We’re just returning the children as they are passed to our <code>OutsideClickHandler</code> component. Let’s wrap the <code>children</code> with a div element and attach a React ref to it.</p>\n<pre><code>import React, { createRef } from 'react';\n\nclass OutsideClickHandler extends React.Component {\n  wrapperRef = createRef();\n\n  render() {    \n    return (\n      &lt;div ref={this.wrapperRef}&gt;\n        {this.props.children}\n      &lt;/div&gt;\n    )\n  }  \n}</code></pre>\n\n<p>We’ll use this <code>ref</code> to get access to the DOM node object associated with the <code>div</code> element. Using that, we’ll recreate the outside detection logic we made above.</p>\n<p>Let’s attach <code>mousedown</code> event on document inside <code>componentDidMount</code> React life cycle method, and clean up that event inside <code>componentWillUnmount</code> React lifecycle method.</p>\n<div>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount() {\n    document\n      .addEventListener('mousedown', this.handleClickOutside);\n  }\n\n  componentWillUnmount(){\n    document\n      .removeEventListener('mousedown', this.handleClickOutside);\n  }\n\n  handleClickOutside = (event) =&gt; {\n    // Here, we'll write the same outside click\n    // detection logic as we used before.\n  }\n}</code></pre>\n</div>\n\n<p>Now, let’s write the detection code inside <code>handleClickOutside</code> handler function.</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount() {\n    document\n      .addEventListener('mousedown', this.handleClickOutside);\n  }\n\n  componentWillUnmount(){\n    document\n      .removeEventListener('mousedown', this.handleClickOutside);\n  }\n\n  handleClickOutside = (event) =&gt; {\n    if (\n      this.wrapperRef.current &amp;&amp;\n      !this.wrapperRef.current.contains(event.target)\n    ) {\n      this.props.onOutsideClick();\n    }\n  }\n}</code></pre>\n\n<p>The logic inside <code>handleClickOutside</code> method says the following: </p>\n<blockquote>\n<p>If the DOM node that was clicked (<code>event.target</code>) was neither our container div (<code>this.wrapperRef.current</code>) nor was it any node inside of it (<code>!this.wrapperRef.current.contains(event.target)</code>), we call the <code>onOutsideClick</code> prop.</p>\n</blockquote>\n<p>This should work in the same way as the outside click detection had worked before. Let’s try clicking outside of the grey text element in the codesandbox below, and observe the console:</p>\n\n\n\n\n<h3>The Problem With DOM Hierarchy Based Outside Click Detection Logic</h3>\n<p>But there’s one problem. Our React component doesn’t work if any of its children are rendered in a React portal.</p>\n<p>But what are React portals?</p>\n<blockquote><p>“Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.”<br /><br />—  <a href=\"https://reactjs.org/docs/portals.html)\">React docs for portals</a></p></blockquote>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/62a69c53-9538-45eb-b4d3-6d10b859317d/1-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>In the image above, you can see that though <code>Tooltip</code> React component is a child of <code>Container</code> React component, if we inspect the DOM we find that Tooltip DOM node actually resides in a completely separate DOM structure i.e. it’s not inside the Container DOM node.</p>\n<p>The problem is that in our outside detection logic so far, we are assuming that the children of <code>OutsideClickHandler</code> will be its direct descendants in the DOM tree. Which is not the case for React portals. If children of our component render in a React portal — which is to say they render in a separate DOM node which is outside the hierarchy of our <code>container div</code> in which our <code>OutsideClickHandler</code> component renders its children — then the <code>Node.contains</code> logic fails.</p>\n<p>How would it fail though? If you’d try to click on the children of our <code>OutsideClickHandler</code> component — which renders in a separate DOM node using React portals — our component will register an outside click, which it shouldn’t. See for yourself:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/29410830-efab-4e81-96bd-c718cf34ef13/6-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/abe4349b-5655-428e-9a5a-6650bd93de16/6-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>Using <code>Node.contains</code> to detect outside click of React component gives wrong result for children rendered in a React portal. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/29410830-efab-4e81-96bd-c718cf34ef13/6-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Try it out:</p>\n\n\n<p>Even though the popover that opens on clicking the button, is a child of <strong>OutsideClickHandler</strong> component, it fails to detect that it isn’t outside of it, and closes it down when it’s clicked.</p>\n<h3>Using Class Instance Property And Event Delegation To Detect Outside Click</h3>\n<p>So what could be the solution? We surely can’t rely on DOM to tell us if the click is happening outside anywhere. We’ll have to do something with JavaScript by rewriting out <strong>OutsideClickHandler</strong> implementation.</p>\n<p>Let’s start with a blank slate. So at this moment <strong>OutsideClickHandler</strong> is an empty React class.</p>\n<p>The crux of correctly detecting outside click is:</p>\n<ol>\n<li>To not rely on DOM structure.</li>\n<li>To store the ‘clicked’ state somewhere in the JavaScript code.</li>\n</ol>\n<p>For this event delegation will come to our aid. Let’s take an example of the same button and popover example we saw above in the GIF above.</p>\n<p>We have two children of our <strong>OutsideClickHandler</strong> function. A button and a popover — which gets rendered in a portal outside of the DOM hierarchy of <strong>OutsideClickHandler</strong>, on button click, like so: </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a1a55a0e-2033-4e26-9019-dad3d5340071/2-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>When either of our children are clicked we set a variable <code>clickCaptured</code> to <code>true</code>. If anything outside of them is clicked, the value of <code>clickCaptured</code> will remain <code>false</code>.</p>\n<p>We will store <code>clickCaptured</code>’s value in:</p>\n<ol>\n<li>A class instance property, if you are using a class react component.</li>\n<li>A ref, if you are using a functional React component.</li>\n</ol>\n<p>We aren’t using React state to store <code>clickCaptured</code>’s value because we aren’t rendering anything based off of this <code>clickCaptured</code> data. The purpose of <code>clickCaptured</code> is ephemeral and ends as soon as we’ve detected if the click has happened inside or outside.</p>\n<p>Let’s seee in the image below the logic for setting <code>clickCaptured</code>:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/879063d5-ffb0-4b50-88ea-5f5196d62fad/3-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>Whenever a click happens anywhere, it bubbles up in React by default. It’ll reach to the <code>document</code> eventually.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/35d75325-af9e-4160-a667-f4857839dbeb/4-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>When the click reaches <code>document</code>, there are two things that might have happened:</p>\n<ol>\n<li><code>clickCaptured</code> will be true, if children where clicked.</li>\n<li><code>clickCaptured</code> will be false, if anywhere outside of them was clicked.</li>\n</ol>\n<p>In the document’s event listener we will do two things now:</p>\n<ol>\n<li>If <code>clickCaptured</code> is true, we fire an outside click handler that the user of <strong>OutsideClickHandler</strong> might have given us through a prop.</li>\n<li>We reset <code>clickCaptured</code> to <strong>false</strong>, so that we are ready for another click detection.</li>\n</ol>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8157d7f6-976d-43f0-9197-40f1bf28fddb/5-creating-outside-focus-click-handler-react-component.png\" /></p>\n<p>Let’s translate this into code.</p>\n<pre><code>import React from 'react'\n\nclass OutsideClickHandler extends React.Component {\n  clickCaptured = false;\n\n  render() {\n    if ( typeof this.props.children === 'function' ) {\n      return this.props.children(this.getProps())\n    }\n\n    return this.renderComponent()\n  }\n}</code></pre>\n\n<p>We have the following things:</p>\n<ol>\n<li>set initial value of <code>clickCaptured</code> instance property to <code>false</code>.</li>\n<li>In the <code>render</code> method, we check if <code>children</code> prop is a function. If it is, we call it and pass it all the props we want to give it by calling <code>getProps</code> class method. We haven’t implemented <code>getProps</code> just yet.</li>\n<li>If the <code>children</code> prop is not a function, we call <code>renderComponent</code> method. Let’s implement this method now.</li>\n</ol>\n<pre><code>class OutsideClickHandler extends React.Component {\n  renderComponent() {\n    return React.createElement(\n      this.props.component || 'span',\n      this.getProps(),\n      this.props.children\n    )\n  }\n}</code></pre>\n\n<p>Since we aren’t using JSX, we are directly using React’s <a href=\"https://reactjs.org/docs/react-api.html#createelement\"><strong>createElement</strong></a> API to wrap our children in either <code>this.props.component</code> or a <code>span</code>. <code>this.props.component</code> can be a React component or any of the HTML element’s tag name like ‘div’, ‘section’, etc. We pass all the props that we want to pass to our newly created element by calling <code>getProps</code> class method as the second argument.</p>\n<p>Let’s write the <code>getProps</code> method now:</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  getProps() {\n    return {\n      onMouseDown: this.innerClick,\n      onTouchStart: this.innerClick\n    };\n  }\n}</code></pre>\n\n<p>Our newly created React element, will have the following props passed down to it: <code>onMouseDown</code> and <code>onTouchStart</code> for touch devices. Both of their values is the <code>innerClick</code> class method.</p>\n<pre><code>class OutsideClickHandler extends React.Component {\n  innerClick = () =&gt; {\n    this.clickCaptured = true;\n  }\n}</code></pre>\n\n<p>If our new React component or anything inside of it — which could be a React portal — is clicked, we set the <code>clickCaptured</code> class instance property to true. Now, let’s add the <code>mousedown</code> and <code>touchstart</code> events to the document, so that we can capture the event that is bubbling up from below.</p>\n<div>\n<pre><code>class OutsideClickHandler extends React.Component {\n  componentDidMount(){\n    document.addEventListener('mousedown', this.documentClick);\n    document.addEventListener('touchstart', this.documentClick);\n  }\n\n  componentWillUnmount(){\n    document.removeEventListener('mousedown', this.documentClick);\n    document.removeEventListener('touchstart', this.documentClick);\n  }\n\n  documentClick = (event) =&gt; {\n    if (!this.clickCaptured &amp;&amp; this.props.onClickOutside) {\n      this.props.onClickOutside(event);\n    }\n    this.clickCaptured = false;\n  };\n}</code></pre>\n</div>\n\n<p>In the document <strong>mousedown</strong> and <strong>touchstart</strong> event handlers, we are checking if <code>clickCaptured</code> is falsy. </p>\n<ol>\n<li><code>clickCaptured</code> would only be <code>true</code> if children of our React component would have been clicked.</li>\n<li>If anything else would have been clicked <code>clickCaptured</code> would be <code>false</code>, and we’d know that outside click has happened.</li>\n</ol>\n<p>If <code>clickCaptured</code> is falsy, we’ll call the <strong>onClickOutside</strong> method passed down in a prop to our <strong>OutsideClickHandler</strong> component.</p>\n<p>That’s it! Let’s confirm that if we click inside the popover it doesn’t get closed now, as it was before:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ead1f85-65b9-4af4-836b-de052243a628/9-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1e4786e0-bc77-47da-99c2-af8e9e482586/9-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>Using event delegation logic correctly detects outside click, even if children are rendered in a React portal. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ead1f85-65b9-4af4-836b-de052243a628/9-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Let’s try it out:</p>\n\n\n<p>Wonderful!</p>\n<h3>Outside Focus Detection</h3>\n<p>Now let’s take a step further. Let’s also add functionality to detect when focus has shifted outside of a React component. It’s going to be very similar implementation as we’ve done with click detection. Let’s write the code.</p>\n<div>\n <pre><code>class OutsideClickHandler extends React.Component {\n  focusCaptured = false\n\n  innerFocus = () =&gt; {\n    this.focusCaptured = true;\n  }\n\ncomponentDidMount(){\n    document.addEventListener('mousedown', this.documentClick);\n    document.addEventListener('touchstart', this.documentClick);\n    document.addEventListener('focusin', this.documentFocus);\n  }\n\ncomponentWillUnmount(){\n    document.removeEventListener('mousedown', this.documentClick);\n    document.removeEventListener('touchstart', this.documentClick);\n    document.removeEventListener('focusin', this.documentFocus);\n  }\n\ndocumentFocus = (event) =&gt; {\n    if (!this.focusCaptured &amp;&amp; this.props.onFocusOutside) {\n      this.props.onFocusOutside(event);\n    }\n    this.focusCaptured = false;\n  };\n\ngetProps() { return { onMouseDown: this.innerClick, onTouchStart: this.innerClick, onFocus: this.innerFocus }; }\n</code></pre>\n</div>\n\n<p>Everything’s added mostly in the same fashion, except for one thing. You might have noticed that though we are adding an <code>onFocus</code> react event handler on our children, we are setting a <code>focusin</code> event listener to our document. Why not a <code>focus</code> event you say? Because,  🥁🥁🥁, <a href=\"https://github.com/facebook/react/pull/19186\">Starting from v17, React now maps</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onFocus</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">React event to</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusin</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">native event internally.</a></p>\n<p>In case you are using v16 or before, instead of adding a <code>focusin</code> event handler to the document, you’ll have to add a <code>focus</code> event in capture phase instead. So that’ll be:</p>\n<pre><code>document.addEventListener('focus', this.documentFocus, true);</code></pre>\n\n<p>Why in capture phase you might ask? Because as weird as it is, <a href=\"https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\">focus event doesn’t bubble up</a>.</p>\n<p>Since I’m using v17 in all my examples, I’m going to go ahead use the former. Let’s see what we have here:</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e2459bd8-4760-4322-b16a-6125eff3866f/8-creating-outside-focus-click-handler-react-component.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2932a3bf-a2ff-497e-adbe-145021e646f8/8-creating-outside-focus-click-handler-react-component-800w.gif\" /></a>React Foco component correctly detecting outside click and focus by using event delegation detection logic. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e2459bd8-4760-4322-b16a-6125eff3866f/8-creating-outside-focus-click-handler-react-component.gif\">Large preview</a>)\n\n<p>Let’s try it out ourselves, try clicking inside and outside of the pink background. Also use tab and shift + tab keys ( in chrome, firefox, edge ) or Opt/Alt + Tab and Opt/Alt + Shift  + Tab ( in Safari ) to toggle focussing between inner and outer button and see how focus status changes.</p>\n\n\n<h3>Conclusion</h3>\n<p>In this article, we learned that the most straightforward way to detect a click outside of a DOM node in JavaScript is by using <code>Node.contains</code> DOM API. I explained the importance of knowing why using the same method to detect clicks outside of a React component doesn’t work when the React component has children which render in a React portal. Also, now you know how to use a class instance property alongside an event delegation to correctly detect whether a click happened outside of a React component, as well as how to extend the same detection technique to outside focus detection of a React component with the <code>focusin</code> event caveat.</p>\n<h4>Related Resources</h4>\n<ol>\n<li><a href=\"https://github.com/nanot1m/react-foco\">React Foco Github Repository</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\">mdn documentation for</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\"><code>Node.contains</code></a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\">DOM api</a></li>\n<li><a href=\"https://reactjs.org/docs/portals.html\">React docs for portals</a></li>\n<li><a href=\"https://reactjs.org/docs/react-api.html#createelement\">React</a> <a href=\"https://reactjs.org/docs/react-api.html#createelement\"><code>createElement</code></a> <a href=\"https://reactjs.org/docs/react-api.html#createelement\">API</a></li>\n<li><a href=\"https://github.com/facebook/react/pull/19186\">React Github codebase Pull Request for mapping</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onFocus</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">and</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>onBlur</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">methods to internally use</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusin</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">and</a> <a href=\"https://github.com/facebook/react/pull/19186\"><code>focusout</code></a> <a href=\"https://github.com/facebook/react/pull/19186\">native events.</a></li>\n<li><a href=\"https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\">Delegating Focus and Blur events</a></li>\n</ol>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"4dea44efceb75cfa4bd91d72e9b0efafd5421aef2a80a383b2ecc48641e2d837","category":"Tech"}