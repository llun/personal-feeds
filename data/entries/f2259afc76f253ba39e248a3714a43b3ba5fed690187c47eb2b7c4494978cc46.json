{"title":"Building A Video Streaming App With Nuxt.js, Node And Express","link":"https://smashingmagazine.com/2021/04/building-video-streaming-app-nuxtjs-node-express/","date":1618322400000,"content":"<p>Videos work with streams. This means that instead of sending the entire video at once, a video is sent as a set of smaller chunks that make up the full video. This explains why videos buffer when watching a video on slow broadband because it only plays the chunks it has received and tries to load more.</p>\n<p>This article is for developers who are willing to learn a new technology by building an actual project: a video streaming app with <a href=\"https://nodejs.org/en/\">Node.js</a> as the backend and <a href=\"https://nuxtjs.org/\">Nuxt.js</a> as the client. </p>\n<ul>\n<li><strong>Node.js</strong> is a runtime used for building fast and scalable applications. We will use it to handle fetching and streaming videos, generating thumbnails for videos, and serving captions and subtitles for videos.</li>\n<li><strong>Nuxt.js</strong> is a Vue.js framework that helps us build server-rendered Vue.js applications easily. We will consume our API for the videos and this application will have two views: a listing of available videos and a player view for each video.</li>\n</ul>\n<h3>Prerequisities</h3>\n<ul>\n<li>An understanding of HTML, CSS, JavaScript, Node/Express, and Vue.</li>\n<li>A text editor (e.g. VS Code).</li>\n<li>A web browser (e.g. Chrome, Firefox).</li>\n<li><a href=\"https://www.ffmpeg.org/download.html\">FFmpeg</a> installed on your workstation.</li>\n<li><a href=\"https://nodejs.org/en/download/\">Node.js</a>. <a href=\"https://github.com/nvm-sh/nvm\">nvm</a>.</li>\n<li>You can <a href=\"https://github.com/smashingmagazine/Nuxt-Node-video-streaming\">get the source code on GitHub</a>.</li>\n</ul>\n<h3>Setting Up Our Application</h3>\n<p>In this application, we will build the routes to make requests from the frontend:</p>\n<ul>\n<li><code>videos</code> route to get a list of videos and their data.</li>\n<li>a route to fetch only one video from our list of videos.</li>\n<li><code>streaming</code> route to stream the videos.</li>\n<li><code>captions</code> route to add captions to the videos we are streaming.</li>\n</ul>\n<p>After our routes have been created, we’ll scaffold our <code>Nuxt</code> frontend, where we’ll create the <code>Home</code> and dynamic <code>player</code> page. Then we request our <code>videos</code> route to fill the home page with the video data, another request to stream the videos on our <code>player</code> page, and finally a request to serve the caption files to be used by the videos.</p>\n<p>To set up our application, we create our project directory,</p>\n<pre><code>mkdir streaming-app</code></pre>\n\n\n\n<h3>Setting Up Our Server</h3>\n<p>In our <code>streaming-app</code> directory, we create a folder named <code>backend</code>.</p>\n<pre><code>cd streaming-app\nmkdir backend</code></pre>\n\n<p>In our backend folder, we initialize a <code>package.json</code> file to store information about our server project.</p>\n<pre><code>cd backend\nnpm init -y</code></pre>\n\n<p>we need to install the following packages to build our app.</p>\n<ul>\n<li><code>nodemon</code> automatically restarts our server when we make changes.</li>\n<li><code>express</code> gives us a nice interface to handle routes.</li>\n<li><code>cors</code> will allow us to make cross-origin requests since our client and server will be running on different ports.</li>\n</ul>\n<p>In our backend directory, we create a folder <code>assets</code> to hold our videos for streaming.</p>\n<pre><code> mkdir assets</code></pre>\n\n<p>Copy a <code>.mp4</code> file into the assets folder, and name it <code>video1</code>. You can use  <code>.mp4</code> short sample videos that can be found on <a href=\"https://github.com/Dunebook/Nuxt-Node-video-streaming/tree/main/backend/assets\">Github Repo</a>.</p>\n<p>Create an <code>app.js</code> file and add the necessary packages for our app.</p>\n<pre><code>const express = require('express');\nconst fs = require('fs');\nconst cors = require('cors');\nconst path = require('path');\nconst app = express();\napp.use(cors())</code></pre>\n\n<p>The <code>fs</code> module is used to read and write into files easily on our server, while the <code>path</code> module provides a way of working with directories and file paths.</p>\n<p>Now we create a <code>./video</code> route. When requested, it will send a video file back to the client.</p>\n<pre><code>// add after 'const app = express();'\n\napp.get('/video', (req, res) =&gt; {\n    res.sendFile('assets/video1.mp4', { root: __dirname });\n});</code></pre>\n\n<p>This route serves the <code>video1.mp4</code> video file when requested. We then listen to our server at port <code>3000</code>.</p>\n<pre><code>// add to end of app.js file\n\napp.listen(5000, () =&gt; {\n    console.log('Listening on port 5000!')\n});</code></pre>\n\n<p>A script is added in the <code>package.json</code> file to start our server using nodemon.</p>\n<pre><code>\n\"scripts\": {\n    \"start\": \"nodemon app.js\"\n  },</code></pre>\n\n<p>Then on your terminal run:</p>\n<pre><code>npm run start</code></pre>\n\n<p>If you see the message <code>Listening on port 3000!</code> in the terminal, then the server is working correctly. Navigate to <a href=\"http://localhost:5000/video\">http://localhost:5000/video</a> in your browser and you should see the video playing.</p>\n<h3>Requests To Be Handled By The Frontend</h3>\n<p>Below are the requests that we will make to the backend from our frontend that we need the server to handle.</p>\n<ul>\n<li><code>/videos</code><br />Returns an array of video mockup data that will be used to populate the list of videos on the <code>Home</code> page in our frontend.</li>\n<li><code>/video/:id/data</code><br />Returns metadata for a single video. Used by the <code>Player</code> page in our frontend.</li>\n<li><code>/video/:id</code><br />Streams a video with a given ID. Used by the <code>Player</code> page.</li>\n</ul>\n<p>Let’s create the routes.</p>\n<h3>Return Mockup Data For List Of Videos</h3>\n<p>For this demo application, we’ll create an <strong>array of objects</strong> that will hold the metadata and send that to the frontend when requested. In a real application, you would probably be reading the data from a database, which would then be used to generate an array like this. For simplicity's sake, we won’t be doing that in this tutorial.</p>\n<p>In our backend folder create a file <code>mockdata.js</code> and populate it with metadata for our list of videos.</p>\n<div>\n<pre><code>const allVideos = [\n    {\n        id: \"tom and jerry\",\n        poster: '<a href=\"https://image.tmdb.org/t/p/w500/fev8UFNFFYsD5q7AcYS8LyTzqwl.jpg'\">https://image.tmdb.org/t/p/w500/fev8UFNFFYsD5q7AcYS8LyTzqwl.jpg'</a>,\n        duration: '3 mins',\n        name: 'Tom &amp; Jerry'\n    },\n    {\n        id: \"soul\",\n        poster: '<a href=\"https://image.tmdb.org/t/p/w500/kf456ZqeC45XTvo6W9pW5clYKfQ.jpg'\">https://image.tmdb.org/t/p/w500/kf456ZqeC45XTvo6W9pW5clYKfQ.jpg'</a>,\n        duration: '4 mins',\n        name: 'Soul'\n    },\n    {\n        id: \"outside the wire\",\n        poster: '<a href=\"https://image.tmdb.org/t/p/w500/lOSdUkGQmbAl5JQ3QoHqBZUbZhC.jpg'\">https://image.tmdb.org/t/p/w500/lOSdUkGQmbAl5JQ3QoHqBZUbZhC.jpg'</a>,\n        duration: '2 mins',\n        name: 'Outside the wire'\n    },\n];\nmodule.exports = allVideos</code></pre>\n</div>\n\n<p>We can see from above, each object contains information about the video. Notice the <code>poster</code> attribute which contains the link to a poster image of the video. </p>\n<p>Let’s create a <code>videos</code> route since all our request to be made by the frontend is prepended with <code>/videos</code>.</p>\n<p>To do this, let’s create a <code>routes</code> folder and add a <code>Video.js</code> file for our <code>/videos</code> route. In this file, we’ll require <code>express</code> and use the express router to create our route.</p>\n<pre><code>const express = require('express')\nconst router = express.Router()</code></pre>\n\n<p>When we go to the <code>/videos</code> route, we want to get our list of videos, so let’s require the <code>mockData.js</code> file into our <code>Video.js</code> file and make our request.</p>\n<pre><code>const express = require('express')\nconst router = express.Router()\nconst videos = require('../mockData')\n// get list of videos\nrouter.get('/', (req,res)=&gt;{\n    res.json(videos)\n})\nmodule.exports = router;</code></pre>\n\n<p>The <code>/videos</code> route is now declared, save the file and it should automatically restart the server. Once it’s started, navigate to <a href=\"http://localhost:3000/videos\">http://localhost:3000/videos</a> and our array is returned in JSON format.</p>\n<h3>Return Data For A Single Video</h3>\n<p>We want to be able to make a request for a particular video in our list of videos. We can fetch a particular video data in our array by using the <code>id</code> we gave it. Let’s make a request, still in our <code>Video.js</code> file.</p>\n<pre><code>\n// make request for a particular video\nrouter.get('/:id/data', (req,res)=&gt; {\n    const id = parseInt(req.params.id, 10)\n    res.json(videos[id])\n})</code></pre>\n\n<p>The code above gets the <code>id</code> from the route parameters and converts it to an integer. Then we send the object that matches the <code>id</code> from the <code>videos</code> array back to the client.</p>\n<h3>Streaming The Videos</h3>\n<p>In our <code>app.js</code> file, we created a <code>/video</code> route that serves a video to the client. We want this endpoint to send smaller chunks of the video, instead of serving an entire video file on request.</p>\n<p>We want to be able to <em>dynamically</em> serve one of the three videos that are in the <code>allVideos</code> array, and stream the videos in chunks, so:</p>\n<p>Delete the <code>/video</code> route from <code>app.js</code>.</p>\n<p>We need three videos, so copy the example videos from the tutorial’s <a href=\"https://github.com/smashingmagazine/Nuxt-Node-video-streaming/tree/main/backend/assets\">source code</a> into the <code>assets/</code> directory of your <code>server</code> project. Make sure the filenames for the videos are corresponding to the <code>id</code> in the <code>videos</code> array:</p>\n<p>Back in our <code>Video.js</code> file, create the route for streaming videos.</p>\n<div>\n<pre><code>router.get('/video/:id', (req, res) =&gt; {\n    const videoPath = <code>assets/${req.params.id}.mp4</code>;\n    const videoStat = fs.statSync(videoPath);\n    const fileSize = videoStat.size;\n    const videoRange = req.headers.range;\n    if (videoRange) {\n        const parts = videoRange.replace(/bytes=/, \"\").split(\"-\");\n        const start = parseInt(parts[0], 10);\n        const end = parts[1]\n            ? parseInt(parts[1], 10)\n            : fileSize-1;\n        const chunksize = (end-start) + 1;\n        const file = fs.createReadStream(videoPath, {start, end});\n        const head = {\n            'Content-Range': <code>bytes ${start}-${end}/${fileSize}</code>,\n            'Accept-Ranges': 'bytes',\n            'Content-Length': chunksize,\n            'Content-Type': 'video/mp4',\n        };\n        res.writeHead(206, head);\n        file.pipe(res);\n    } else {\n        const head = {\n            'Content-Length': fileSize,\n            'Content-Type': 'video/mp4',\n        };\n        res.writeHead(200, head);\n        fs.createReadStream(videoPath).pipe(res);\n    }\n});</code></pre>\n</div>\n\n<p>If we navigate to <a href=\"http://localhost:5000/videos/video/outside-the-wire\">http://localhost:5000/videos/video/outside-the-wire</a> in our browser, we can see the video streaming.</p>\n<h3>How The Streaming Video Route Works</h3>\n<p>There is a fair bit of code written in our stream video route, so let’s look at it line by line.</p>\n<pre><code> const videoPath = `assets/${req.params.id}.mp4`;\n const videoStat = fs.statSync(videoPath);\n const fileSize = videoStat.size;\n const videoRange = req.headers.range;</code></pre>\n\n<p>First, from our request, we get the <code>id</code> from the route using <code>req.params.id</code> and use it to generate the <code>videoPath</code> to the video. We then read the <code>fileSize</code> using the file system <code>fs</code> we imported. For videos, a user’s browser will send a <code>range</code> parameter in the request. This lets the server know which chunk of the video to send back to the client.</p>\n<p>Some browsers send a <em>range</em> in the initial request, but others don’t. For those that don’t, or if for any other reason the browser doesn’t send a range, we handle that in the <code>else</code> block. This code gets the file size and send the first few chunks of the video:</p>\n<pre><code>else {\n    const head = {\n        'Content-Length': fileSize,\n        'Content-Type': 'video/mp4',\n    };\n    res.writeHead(200, head);\n    fs.createReadStream(path).pipe(res);\n}</code></pre>\n\n<p>We will handle subsequent requests including the range in an <code>if</code> block.</p>\n<div>\n<pre><code>if (videoRange) {\n        const parts = videoRange.replace(/bytes=/, \"\").split(\"-\");\n        const start = parseInt(parts[0], 10);\n        const end = parts[1]\n            ? parseInt(parts[1], 10)\n            : fileSize-1;\n        const chunksize = (end-start) + 1;\n        const file = fs.createReadStream(videoPath, {start, end});\n        const head = {\n            'Content-Range': <code>bytes ${start}-${end}/${fileSize}</code>,\n            'Accept-Ranges': 'bytes',\n            'Content-Length': chunksize,\n            'Content-Type': 'video/mp4',\n        };\n        res.writeHead(206, head);\n        file.pipe(res);\n    }</code></pre>\n</div>\n\n<p>This code above creates a read stream using the <code>start</code> and <code>end</code> values of the range. Set the <code>Content-Length</code> of the response headers to the chunk size that is calculated from the <code>start</code> and <code>end</code> values. We also use <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\">HTTP code 206</a>, signifying that the response contains partial content. This means the browser will keep making requests until it has fetched all chunks of the video.</p>\n<h3>What Happens On Unstable Connections</h3>\n<p>If the user is on a slow connection, the network stream will signal it by requesting that the I/O source pauses until the client is ready for more data. This is known as <em>back-pressure</em>. We can take this example one step further and see how easy it is to extend the stream. We can easily add compression, too!</p>\n<div>\n<pre><code>const start = parseInt(parts[0], 10);\n        const end = parts[1]\n            ? parseInt(parts[1], 10)\n            : fileSize-1;\n        const chunksize = (end-start) + 1;\n        const file = fs.createReadStream(videoPath, {start, end});</code></pre>\n</div>\n\n<p>We can see above that a <code>ReadStream</code> is created and serves the video chunk by chunk.</p>\n<div>\n<pre><code>const head = {\n            'Content-Range': <code>bytes ${start}-${end}/${fileSize}</code>,\n            'Accept-Ranges': 'bytes',\n            'Content-Length': chunksize,\n            'Content-Type': 'video/mp4',\n        };\nres.writeHead(206, head);\n        file.pipe(res);</code></pre>\n</div>\n\n<p>The request header contains the <code>Content-Range</code>, which is the start and end changing to get the next chunk of video to stream to the frontend, the <code>content-length</code> is the chunk of video sent. We also specify the type of content we are streaming which is <code>mp4</code>. The writehead of 206 is set to respond with only newly made streams.</p>\n<h3>Creating A Caption File For Our Videos</h3>\n<p>This is what a <code>.vtt</code> caption file looks like.</p>\n<pre><code>WEBVTT\n\n00:00:00.200 --&gt; 00:00:01.000\nCreating a tutorial can be very\n\n00:00:01.500 --&gt; 00:00:04.300\nfun to do.</code></pre>\n\n<p>Captions files contain text for what is said in a video. It also contains time codes for when each line of text should be displayed. We want our videos to have captions, and we won’t be creating our own caption file for this tutorial, so you can head over to the captions folder in the <code>assets</code> directory in <a href=\"https://github.com/Dunebook/Nuxt-Node-video-streaming/tree/main/backend/assets/captions\">the repo</a> and download the captions.</p>\n<p>Let’s create a new route that will handle the caption request:</p>\n<div>\n<pre><code>router.get('/video/:id/caption', (req, res) =&gt; res.sendFile(<code>assets/captions/${req.params.id}.vtt</code>, { root: __dirname }));</code></pre>\n</div>\n\n\n\n<h3>Building Our Frontend</h3>\n<p>To get started on the visual part of our system, we would have to build out our frontend scaffold.</p>\n<p><strong>Note</strong>: <em>You need vue-cli to create our app. If you don’t have it installed on your computer, you can run <code>npm install -g @vue/cli</code> to install it.</em></p>\n<h3>Installation</h3>\n<p>At the root of our project, let's create our front-end folder:</p>\n<pre><code>mkdir frontend\ncd frontend</code></pre>\n\n<p>and in it, we initialize our <code>package.json</code> file, copy and paste the following in it:</p>\n<pre><code>{\n  \"name\": \"my-app\",\n  \"scripts\": {\n    \"dev\": \"nuxt\",\n    \"build\": \"nuxt build\",\n    \"generate\": \"nuxt generate\",\n    \"start\": \"nuxt start\"\n  }\n}</code></pre>\n\n<p>then install <code>nuxt</code>:</p>\n<pre><code>npm add nuxt</code></pre>\n\n<p>and execute the following command to run Nuxt.js app:</p>\n<pre><code>npm run dev</code></pre>\n\n<h3>Our Nuxt File Structure</h3>\n<p>Now that we have Nuxt installed, we can begin laying out our frontend.</p>\n<p>First, we need to create a <code>layouts</code> folder at the root of our app. This folder defines the layout of the app, no matter the page we navigate to. Things like our navigation bar and footer are found here. In the frontend folder, we create <code>default.vue</code> for our default layout when we start our frontend app.</p>\n<pre><code>mkdir layouts\ncd layouts\ntouch default.vue</code></pre>\n\n<p>Then a <code>components</code> folder to create all our components. We will be needing only two components, <code>NavBar</code> and <code>video</code> component. So in our root folder of frontend we:</p>\n<pre><code>mkdir components\ncd components\ntouch NavBar.vue\ntouch Video.vue</code></pre>\n\n<p>Finally, a pages folder where all our pages like <code>home</code> and <code>about</code> can be created. The two pages we need in this app, are the <code>home</code> page displaying all our videos and video information and a dynamic player page that routes to the video we click on.</p>\n<pre><code>mkdir pages\ncd pages\ntouch index.vue\nmkdir player\ncd player\ntouch _name.vue</code></pre>\n\n<p>Our frontend directory now looks like this:</p>\n<pre><code>|-frontend\n  |-components\n    |-NavBar.vue\n    |-Video.vue\n  |-layouts\n    |-default.vue\n  |-pages\n    |-index.vue\n    |-player\n      |-_name.vue\n  |-package.json\n  |-yarn.lock</code></pre> \n\n<h3>Navbar Component</h3>\n<p>Our <code>NavBar.vue</code> looks like this:</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=\"navbar\"&gt;\n        &lt;h1&gt;Streaming App&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n.navbar {\n    display: flex;\n    background-color: #161616;\n    justify-content: center;\n    align-items: center;\n}\nh1{\n    color:#a33327;\n}\n&lt;/style&gt;</code></pre>\n\n<p>The <code>NavBar</code> has a <code>h1</code> tag that displays <strong>Streaming App</strong>, with some little styling.</p>\n<p>Let’s import the <code>NavBar</code> into our <code>default.vue</code> layout. </p>\n<pre><code>// default.vue\n&lt;template&gt;\n &lt;div&gt;\n   &lt;NavBar /&gt;\n   &lt;nuxt /&gt;\n &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport NavBar from \"@/components/NavBar.vue\"\nexport default {\n    components: {\n        NavBar,\n    }\n}\n&lt;/script&gt;</code></pre>\n\n<p>The <code>default.vue</code> layout now contains our <code>NavBar</code> component and the <code>&lt;nuxt /&gt;</code> tag after it signifies where any page we create will be displayed.</p>\n<p>In our <code>index.vue</code> (which is our homepage), let’s make a request to <code>http://localhost:5000/videos</code> to get all the videos from our server. Passing the data as a prop to our <code>video.vue</code> component we will create later. But for now, we have already imported it.</p>\n<pre><code>&lt;template&gt;\n&lt;div&gt;\n  &lt;Video :videoList=\"videos\"/&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport Video from \"@/components/Video.vue\"\nexport default {\n  components: {\n    Video\n  },\nhead: {\n    title: \"Home\"\n  },\n    data() {\n      return {\n        videos: []\n      }\n    },\n    async fetch() {\n      this.videos = await fetch(\n        'http://localhost:5000/videos'\n      ).then(res =&gt; res.json())\n    }\n}\n&lt;/script&gt;</code></pre>\n\n<h3>Video Component</h3>\n<p>Below, we first declare our prop. Since the video data is now available in the component, using Vue’s <code>v-for</code> we iterate on all the data received and for each one, we display the information. We can use the <code>v-for</code> directive to loop through the data and display it as a list. Some basic styling has also been added.</p>\n<pre><code>&lt;template&gt;\n&lt;div&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;div\n    v-for=\"(video, id) in videoList\"\n    :key=\"id\"\n    class=\"vid-con\"\n  &gt;\n    &lt;NuxtLink :to=\"`/player/${video.id}`\"&gt;\n    &lt;div\n      :style=\"{\n        backgroundImage: `url(${video.poster})`\n      }\"\n      class=\"vid\"\n    &gt;&lt;/div&gt;\n    &lt;div class=\"movie-info\"&gt;\n      &lt;div class=\"details\"&gt;\n      &lt;h2&gt;{{video.name}}&lt;/h2&gt;\n      &lt;p&gt;{{video.duration}}&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/NuxtLink&gt;\n  &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n    props:['videoList'],\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin-top: 2rem;\n}\n.vid-con {\n  display: flex;\n  flex-direction: column;\n  flex-shrink: 0;\n  justify-content: center;\n  width: 50%;\n  max-width: 16rem;\n  margin: auto 2em;\n\n}\n.vid {\n  height: 15rem;\n  width: 100%;\n  background-position: center;\n  background-size: cover;\n}\n.movie-info {\n  background: black;\n  color: white;\n  width: 100%;\n}\n.details {\n  padding: 16px 20px;\n}\n&lt;/style&gt;</code></pre>\n\n<p>We also notice that the <code>NuxtLink</code> has a dynamic route, that is routing to the <code>/player/video.id</code>. </p>\n<p>The functionality we want is when a user clicks on any of the videos, it starts streaming. To achieve this, we make use of the dynamic nature of the <code>_name.vue</code> route.</p>\n<p>In it, we create a video player and set the source to our endpoint for streaming the video, but we dynamically append which video to play to our endpoint with the help of  <code>this.$route.params.name</code> that captures which parameter the link received.</p>\n<div>\n<pre><code>&lt;template&gt;\n    &lt;div class=\"player\"&gt;\n        &lt;video controls muted autoPlay&gt;\n            &lt;source :src=\"<code>http://localhost:5000/videos/video/${vidName}</code>\" type=\"video/mp4\"&gt;\n        &lt;/video&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n data() {\n      return {\n        vidName: ''\n      }\n    },\nmounted(){\n    this.vidName = this.$route.params.name\n}\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.player {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-top: 2em;\n}\n&lt;/style&gt;</code></pre>\n</div>\n\n<p>When we click on any of the video we get:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d2b6e82b-9aa5-4c25-8f03-56c8bac69b74/01-nuxtjs-video-preview.jpg\" /></p>\n<h3>Adding Our Caption File</h3>\n<p>To add our track file, we make sure all the <code>.vtt</code> files in the <em>captions</em> folder have the same name as our <code>id</code>. Update our video element with the track, making a request for the captions.</p>\n<div>\n<pre><code>&lt;template&gt;\n    &lt;div class=\"player\"&gt;\n        &lt;video controls muted autoPlay crossOrigin=\"anonymous\"&gt;\n            &lt;source :src=\"<code>http://localhost:5000/videos/video/${vidName}</code>\" type=\"video/mp4\"&gt;\n            &lt;track label=\"English\" kind=\"captions\" srcLang=\"en\" :src=\"<code>http://localhost:5000/videos/video/${vidName}/caption</code>\" default&gt;\n        &lt;/video&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n</div>\n\n<p>We’ve added <code>crossOrigin=\"anonymous\"</code> to the video element; otherwise, the request for captions will fail. Now refresh and you’ll see captions have been added successfully.</p>\n<h3>What To Keep In Mind When Building Resilient Video Streaming.</h3>\n<p>When building streaming applications like Twitch, Hulu or Netflix, there are a number of things that are put into consideration:</p>\n<ul>\n<li><strong>Video data processing pipeline</strong><br />This can be a technical challenge as high-performing servers are needed to serve millions of videos to users. High latency or downtime should be avoided at all costs.</li>\n<li><strong>Caching</strong><br />Caching mechanisms should be used when building this type of application example Cassandra, Amazon S3, AWS SimpleDB.</li>\n<li><strong>Users’ geography</strong><br />Considering the geography of your users should be thought about for distribution.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>In this tutorial, we have seen how to create a server in Node.js that streams videos, generates captions for those videos, and serves metadata of the videos. We’ve also seen how to use Nuxt.js on the frontend to consume the endpoints and the data generated by the server.</p>\n<p>Unlike other frameworks, building an application with Nuxt.js and Express.js is quite easy and fast. The cool part about Nuxt.js is the way it manages your routes and makes you structure your apps better.</p>\n<ul>\n<li>You can get more information about Nuxt.js <a href=\"https://nuxtjs.org/guide\">here</a>.</li>\n<li>You can get the <a href=\"https://github.com/smashingmagazine/Nuxt-Node-video-streaming/\">source code on Github</a>.</li>\n</ul>\n<h4>Resources</h4>\n<ul>\n<li>“<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video\">Adding Captions And Subtitles To HTML5 Video</a>,” MDN Web Docs</li>\n<li>“<a href=\"http://web.archive.org/web/20160117160743/http://screenfont.ca/learn/\">Understanding Captions And Subtitles</a>,” Screenfont.ca</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"f2259afc76f253ba39e248a3714a43b3ba5fed690187c47eb2b7c4494978cc46","category":"Tech"}