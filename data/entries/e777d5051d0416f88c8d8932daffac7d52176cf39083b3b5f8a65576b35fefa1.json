{"title":"วิธีแก้ไขปัญหา ความช้าใน request แรกของระบบที่พัฒนาด้วย .Net","link":"https://www.somkiat.cc/dotnet-slow-in-first-request/","date":1619528858000,"content":"<p><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/04/dotnet-5-150x150.jpeg\" /></p>\n<figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/04/dotnet-5.jpeg\" /></figure>\n\n\n\n<p><strong>ปัญหาที่เจอ</strong><br />ในระบบ Web หรือ API ที่พัฒนาด้วย .Net + C# นั้น<br />พบว่าเมื่อเราทำการ start server ขึ้นมาแล้ว <br />request แรกที่เข้ามาจะช้ามาก ๆ <br />เมื่อเทียบกับ request ต่อ ๆ มา<br />จะแก้ไขอย่างไรดี ?</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>ตัวอย่างของปัญหา ซึ่งความเร็วต่างกันมาก ๆ </strong></p>\n\n\n\n<p>เป็น code ที่ถูกสร้างมาจาก default project<br />เพื่อทำการ reproduce ปัญหา ดังนี้</p>\n\n\n\n[gist id=\"647689dbc084b1d0e328554521008a10\" file=\"1.txt\"]\n\n\n\n<p><strong>วิธีการแก้ไขปัญหามีอะไรบ้าง ?</strong></p>\n\n\n\n<p>ลองคิดกันดูครับ ก่อนดูในบรรทัดต่อไป ...</p>\n\n\n\n<p><strong>จากที่คิดคือ ถ้าง่ายสุด ๆ ก็ทำการยิง request แรกก่อนเลย</strong></p>\n\n\n\n<p>ซึ่งเป็นการยิงจากระบบของเราเองในขั้นตอนสุดท้าย<br />หลังจากการ deployก่อนที่จะเปิดให้ใช้งาน<br />ผมคิดว่า น่าจะเป็น workaround มากกว่านะ<br />แต่ก็ง่ายที่สุดแล้ว !!</p>\n\n\n\n<p><strong>การทำก็ง่าย ๆ คือ สร้าง endpoint ขึ้นมา</strong></p>\n\n\n\n<p>เพื่อใช้สำหรับตรวจสอบความพร้อมของ Web หรือ API<br />หรือจะเรียกว่า Health Check แบบ readiness นั่นเอง<br />จากนั้นถ้าใช้พวก Docker หรือ Kubernetes ก็สามารถนำไปใส่ได้</p>\n\n\n\n<ul><li>Docker ใช้  <a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\">Health check</a></li><li>Kubernetes ใช้งาน <a href=\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\" target=\"_blank\">ReadinessProbe</a></li></ul>\n\n\n\n<p>แน่นอนว่า จะทำการส่ง request ไปยัง endpoint ก่อนเลย<br />เท่านี้ก็จบแล้ว</p>\n\n\n\n<p><strong><em>แต่ถ้าไม่ได้ใช้ Docker หรือ Kubernetes ละ ทำอย่างไร ?</em></strong></p>\n\n\n\n<p><strong>ลองทำการ warmup หรือเรียก endpoint ที่กำหนดไว้เองเลย</strong></p>\n\n\n\n<p>โดยทำการสร้าง class ที่ implements <strong>IHostedService</strong> มา<br />จากนั้นทำการเรียก endpoint หลังจากที่ server ทำการ start เรียบร้อยแล้ว<br />ด้วยการใช้งาน HTTPClient นั่นเอง<br />ซึ่งวิธีการนี้ก็ง่ายดี <br />แต่ต้องเข้าในลำดับของการ start server นิดหน่อย</p>\n\n\n\n<p><strong>มาดู code ง่าย ๆ กัน</strong><br />สร้าง Warmup service สำหรับส่ง request ไปยัง Endpoint URL ที่ต้องการ</p>\n\n\n\n[gist id=\"647689dbc084b1d0e328554521008a10\" file=\"WarmupServices.cs\"]\n\n\n\n<p><strong>ทำการ start service หลังจากที่ server start เสร็จแล้ว</strong></p>\n\n\n\n[gist id=\"647689dbc084b1d0e328554521008a10\" file=\"Program.cs\"]\n\n\n\n<p><strong>ผลการทดสอบเป็นดังนี้</strong></p>\n\n\n\n[gist id=\"647689dbc084b1d0e328554521008a10\" file=\"2.txt\"]\n\n\n\n<p><strong>รวม ๆ แล้วคือการกระตุ้นการทำงานของ request แรกนั่นเอง</strong></p>\n\n\n\n<p>ก็น่าจะช่วยให้แก้ไขปัญหาที่พบเจอได้เช่นกัน<br />ตามจริงเราสามารถ initial service ต่าง ๆ <br />ทั้ง singleton และ non-singleton ได้อีกนะ<br />หรือถ้ายิง Endpoint ที่ต้องการหรือทั้งหมดก็ได้<br />แต่คิดว่า น่าจะซับซ้อนเกินไปหน่อย</p>\n\n\n\n<p>อาจจะเขียน script สำหรับการ start service อีกก็ได้<br />ซึ่งทั้งหมดนี้ น่าจะเป็นเพียง workaround เท่านั้น</p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"e777d5051d0416f88c8d8932daffac7d52176cf39083b3b5f8a65576b35fefa1","category":"Thai"}