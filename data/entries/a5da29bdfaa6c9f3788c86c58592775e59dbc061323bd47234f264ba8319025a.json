{"title":"Building A Rich Text Editor (WYSIWYG) From Scratch","link":"https://smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/","date":1621596600000,"content":"<p>In recent years, the field of Content Creation and Representation on Digital platforms has seen a massive disruption. The widespread success of products like Quip, Google Docs and Dropbox Paper has shown how companies are racing to build the best experience for content creators in the enterprise domain and trying to find innovative ways of breaking the traditional moulds of how content is shared and consumed. Taking advantage of the massive outreach of social media platforms, there is a new wave of independent content creators using platforms like Medium to create content and share it with their audience. </p>\n<p>As so many people from different professions and backgrounds try to create content on these products, it’s important that these products provide a performant and seamless experience of content creation and have teams of designers and engineers who develop some level of domain expertise over time in this space. With this article, we try to not only lay the foundation of building an editor but also give the readers a glimpse into how little nuggets of functionalities when brought together can create a great user experience for a content creator.</p>\n<h3>Understanding The Document Structure</h3>\n<p>Before we dive into building the editor, let’s look at how a document is structured for a Rich Text Editor and what are the different types of data structures involved.</p>\n<h4>Document Nodes</h4>\n<p>Document nodes are used to represent the contents of the document. The common types of nodes that a rich-text document could contain are paragraphs, headings, images, videos, code-blocks and pull-quotes. Some of these may contain other nodes as children inside them (e.g. Paragraph nodes contain text nodes inside them). Nodes also hold any properties specific to the object they represent that are needed to render those nodes inside the editor. (e.g. Image nodes contain an image <code>src</code> property, Code-blocks may contain a <code>language</code> property and so on). </p>\n<p>There are largely two types of nodes that represent how they should be rendered -</p>\n<ul>\n<li><strong>Block Nodes</strong> (analogous to HTML concept of Block-level elements) that are each rendered on a new line and occupy the available width. Block nodes could contain other block nodes or inline nodes inside them. An observation here is that the top-level nodes of a document would always be block nodes.</li>\n<li><strong>Inline Nodes</strong> (analogous to HTML concept of Inline elements) that start rendering on the same line as the previous node. There are some differences in how inline elements are represented in different editing libraries. SlateJS allows for inline elements to be nodes themselves. DraftJS, another popular Rich Text Editing library, lets you use the concept of Entities to render inline elements. Links and Inline Images are examples of Inline nodes.</li>\n<li>Void Nodes — SlateJS also allows this third category of nodes that we will use later in this article to render media. </li>\n</ul>\n<p>If you want to learn more about these categories, SlateJS’s documentation on <a href=\"https://docs.slatejs.org/concepts/02-nodes\">Nodes</a> is a good place to start. </p>\n<h4>Attributes</h4>\n<p>Similar to HTML’s concept of attributes, attributes in a Rich Text Document are used to represent non-content properties of a node or it’s children. For instance, a text node can have character-style attributes that tell us whether the text is bold/italic/underlined and so on. Although this article represents headings as nodes themselves, another way to represent them could be that nodes have paragraph-styles (<code>paragraph</code> &amp; <code>h1-h6</code>) as attributes on them. </p>\n<p>Below image gives an example of how a document’s structure (in JSON) is described at a more granular level using nodes and attributes highlighting some of the elements in the structure to the left.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bde879ad-0e29-4631-92b0-198cf8730af0/document-structure.png\" /></p>\n<p>Some of the things worth calling out here with the structure are:</p>\n<ul>\n<li>Text nodes are represented as <code>{text: 'text content'}</code></li>\n<li>Properties of the nodes are stored directly on the node (e.g. <code>url</code> for links and <code>caption</code> for images)</li>\n<li>SlateJS-specific representation of text attributes breaks the text nodes to be their own nodes if the character style changes. Hence, the text ‘<strong>Duis aute irure dolor</strong>’ is a text node of it’s own with <code>bold: true</code> set on it. Same is the case with the italic, underline and code style text in this document. </li>\n</ul>\n<h4>Locations And Selection</h4>\n<p>When building a rich text editor, it is crucial to have an understanding of how the most granular part of a document (say a character) can be represented with some sort of coordinates. This helps us navigate the document structure at runtime to understand where in the document hierarchy we are. Most importantly, location objects give us a way to represent user selection which is quite extensively used to tailor the user experience of the editor in real time. We will use selection to build our toolbar later in this article. Examples of these could be:</p>\n<ul>\n<li>Is the user’s cursor currently inside a link, maybe we should show them a menu to edit/remove the link?</li>\n<li>Has the user selected an image? Maybe we give them a menu to resize the image.</li>\n<li>If the user selects certain text and hits the DELETE button, we determine what user’s selected text was and remove that from the document.</li>\n</ul>\n<p>SlateJS’s document on <a href=\"https://docs.slatejs.org/concepts/03-locations\">Location</a> explains these data structures extensively but we go through them here quickly as we use these terms at different instances in the article and show an example in the diagram that follows.</p>\n<ul>\n<li><strong>Path</strong><br />Represented by an array of numbers, a path is the way to get to a node in the document. For instance, a path <code>[2,3]</code> represents the 3rd child node of the 2nd node in the document.</li>\n<li><strong>Point</strong><br />More granular location of content represented by path + offset. For instance, a point of <code>{path: [2,3], offset: 14}</code> represents the 14th character of the 3rd child node inside the 2nd node of the document.</li>\n<li><strong>Range</strong><br />A pair of points (called <code>anchor</code> and <code>focus</code>) that represent a range of text inside the document. This concept comes from Web’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Selection\">Selection API</a> where <code>anchor</code> is where user’s selection began and <code>focus</code> is where it ended. A collapsed range/selection denotes where anchor and focus points are the same (think of a blinking cursor in a text input for instance).</li>\n</ul>\n<p>As an example let’s say that the user’s selection in our above document example is <code>ipsum</code>: </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3ccf8c84-b447-4b34-a3b4-8ef4959e2125/locations.png\" /></p>\n<p>The user’s selection can be represented as: </p>\n<div>\n <pre><code>{\n  anchor: {path: [2,0], offset: 5}, /<em>0th text node inside the paragraph node which itself is index 2 in the document</em>/\n  focus: {path: [2,0], offset: 11}, // space + 'ipsum'\n}`\n</code></pre>\n</div>\n\n<h3>Setting Up The Editor</h3>\n<p>In this section, we are going to set up the application and get a basic rich-text editor going with SlateJS. The boilerplate application would be <code><a href=\"https://reactjs.org/docs/create-a-new-react-app.html\"><code>create-react-app</code></a></code> with SlateJS dependencies added to it. We are building the UI of the application using components from  <code><a href=\"https://react-bootstrap.github.io/\"><code>react-bootstrap</code></a></code>. Let’s get started!</p>\n<p>Create a folder called <code>wysiwyg-editor</code> and run the below command from inside the directory to set up the react app. We then run a <code>yarn start</code> command that should spin up the local web server (port defaulting to 3000) and show you a React welcome screen.</p>\n<pre><code>npx create-react-app .\nyarn start\n</code></pre>\n\n<p>We then move on to add the SlateJS dependencies to the application.</p>\n<pre><code>yarn add slate slate-react\n</code></pre>\n\n<p><code>slate</code> is SlateJS's core package and <code>slate-react</code> includes the set of React components we will use to render Slate editors. SlateJS exposes some more <a href=\"https://github.com/ianstormtaylor/slate#packages\">packages</a> organized by functionality one might consider adding to their editor.</p>\n<p>We first create a <code>utils</code> folder that holds any utility modules we create in this application. We start with creating an <code>ExampleDocument.js</code> that returns a basic document structure that contains a paragraph with some text. This module looks like below:</p>\n<pre><code>const ExampleDocument = [\n  {\n    type: \"paragraph\",\n    children: [\n      { text: \"Hello World! This is my paragraph inside a sample document.\" },\n    ],\n  },\n];\n\nexport default ExampleDocument;\n</code></pre>\n\n<p>We now add a folder called <code>components</code> that will hold all our React components and do the following:</p>\n<ul>\n<li>Add our first React component <code>Editor.js</code> to it. It only returns a <code>div</code> for now.</li>\n<li>Update the <code>App.js</code> component to hold the document in its state which is initialized to our <code>ExampleDocument</code> above. </li>\n<li>Render the Editor inside the app and pass the document state and an <code>onChange</code> handler down to the Editor so our document state is updated as the user updates it. </li>\n<li>We use React bootstrap’s Nav components to add a navigation bar to the application as well.</li>\n</ul>\n<p><code>App.js</code> component now looks like below:</p>\n<pre><code>import Editor from './components/Editor';\n\nfunction App() {\n  const [document, updateDocument] = useState(ExampleDocument);\n\n  return (\n    &lt;&gt;\n      &lt;Navbar bg=\"dark\" variant=\"dark\"&gt;\n        &lt;Navbar.Brand href=\"#\"&gt;\n          &lt;img\n            alt=\"\"\n            src=\"/app-icon.png\"\n            width=\"30\"\n            height=\"30\"\n            className=\"d-inline-block align-top\"\n          /&gt;{\" \"}\n          WYSIWYG Editor\n        &lt;/Navbar.Brand&gt;\n      &lt;/Navbar&gt;\n      &lt;div className=\"App\"&gt;\n        &lt;Editor document={document} onChange={updateDocument} /&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n</code></pre>\n\n<p>Inside the Editor component, we then instantiate the SlateJS editor and hold it inside a <code>useMemo</code> so that the object doesn’t change in between re-renders. </p>\n<pre><code>// dependencies imported as below.\nimport { withReact } from \"slate-react\";\nimport { createEditor } from \"slate\";\n\nconst editor = useMemo(() =&gt; withReact(createEditor()), []);\n</code></pre>\n\n<p><code>createEditor</code> gives us the SlateJS <code>editor</code> instance which we use extensively through the application to access selections, run data transformations and so on. <a href=\"https://github.com/ianstormtaylor/slate/blob/master/packages/slate-react/src/plugin/with-react.ts\">withReact</a> is a SlateJS plugin that adds React and DOM behaviors to the editor object. <a href=\"https://docs.slatejs.org/concepts/07-plugins\">SlateJS Plugins</a> are Javascript functions that receive the <code>editor</code> object and attach some configuration to it. This allows web developers to add configurations to their SlateJS editor instance in a composable way. </p>\n<p>We now import and render <code>&lt;Slate /&gt;</code> and <code>&lt;Editable /&gt;</code> components from SlateJS with the document prop we get from App.js. <code><a href=\"https://github.com/ianstormtaylor/slate/blob/master/packages/slate-react/src/components/slate.tsx\">Slate</a></code> exposes a bunch of React contexts we use to access in the application code. <code><a href=\"https://github.com/ianstormtaylor/slate/blob/master/packages/slate-react/src/components/editable.tsx\">Editable</a></code> is the component that renders the document hierarchy for editing. Overall, the <code><code>Editor.js</code></code> module at this stage looks like below:</p>\n<pre><code>import { Editable, Slate, withReact } from \"slate-react\";\n\nimport { createEditor } from \"slate\";\nimport { useMemo } from \"react\";\n\nexport default function Editor({ document, onChange }) {\n  const editor = useMemo(() =&gt; withReact(createEditor()), []);\n  return (\n    &lt;Slate editor={editor} value={document} onChange={onChange}&gt;\n      &lt;Editable /&gt;\n    &lt;/Slate&gt;\n  );\n}\n</code></pre>\n\n<p>At this point, we have necessary React components added and the editor populated with an example document. Our Editor should be now set up allowing us to type in and change the content in real time — as in the screencast below.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/444bb608-7f60-40fb-8ed3-d583e9a535b2/paragraph-nodes.png\" /></p>\n<h4>Character Styles</h4>\n<p>Similar to <code>renderElement</code>, SlateJS gives out a function prop called renderLeaf that can be used to customize rendering of the text nodes (<code>Leaf</code> referring to text nodes which are the leaves/lowest level nodes of the document tree). Following the example of <code>renderElement</code>, we write an implementation for <code>renderLeaf</code>.</p>\n<pre><code>export default function useEditorConfig(editor) {\n  return { renderElement, renderLeaf };\n}\n\n// ...\nfunction renderLeaf({ attributes, children, leaf }) {\n  let el = &lt;&gt;{children}&lt;/&gt;;\n\n  if (leaf.bold) {\n    el = &lt;strong&gt;{el}&lt;/strong&gt;;\n  }\n\n  if (leaf.code) {\n    el = &lt;code&gt;{el}&lt;/code&gt;;\n  }\n\n  if (leaf.italic) {\n    el = &lt;em&gt;{el}&lt;/em&gt;;\n  }\n\n  if (leaf.underline) {\n    el = &lt;u&gt;{el}&lt;/u&gt;;\n  }\n\n  return &lt;span {...attributes}&gt;{el}&lt;/span&gt;;\n}\n</code></pre>\n\n<p>An important observation of the above implementation is that it allows us to respect HTML semantics for character styles. Since renderLeaf gives us access to the text node <code>leaf</code> itself, we can customize the function to implement a more customized rendering. For instance, you might have a way to let users choose a <code>highlightColor</code> for text and check that leaf property here to attach the respective styles.</p>\n<p>We now update the Editor component to use the above, the <code>ExampleDocument</code> to have a few text nodes in the paragraph with combinations of these styles and verify that they are rendered as expected in the Editor with the semantic tags we used.</p>\n<pre><code># src/components/Editor.js\n\nconst { renderElement, renderLeaf } = useEditorConfig(editor);\n\nreturn (\n    ...\n    &lt;Editable renderElement={renderElement} renderLeaf={renderLeaf} /&gt;\n);\n</code></pre>\n\n<pre><code># src/utils/ExampleDocument.js\n\n{\n    type: \"paragraph\",\n    children: [\n      { text: \"Hello World! This is my paragraph inside a sample document.\" },\n      { text: \"Bold text.\", bold: true, code: true },\n      { text: \"Italic text.\", italic: true },\n      { text: \"Bold and underlined text.\", bold: true, underline: true },\n      { text: \"variableFoo\", code: true },\n    ],\n  },\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/617fbdb7-4365-4501-8761-3f6aa1c485bd/character-styles.png\" /></p>\n<h3>Adding A Toolbar</h3>\n<p>Let’s begin by adding a new component <code>Toolbar.js</code> to which we add a few buttons for character styles and a dropdown for paragraph styles and we wire these up later in the section. </p>\n<div>\n <pre><code>const PARAGRAPH_STYLES = [\"h1\", \"h2\", \"h3\", \"h4\", \"paragraph\", \"multiple\"];\nconst CHARACTER_STYLES = [\"bold\", \"italic\", \"underline\", \"code\"];\n\nexport default function Toolbar({ selection, previousSelection }) {\n  return (\n    &lt;div className=\"toolbar\"&gt;\n      {/* Dropdown for paragraph styles */}\n      &lt;DropdownButton\n        className={\"block-style-dropdown\"}\n        disabled={false}\n        id=\"block-style\"\n        title={getLabelForBlockStyle(\"paragraph\")}\n      &gt;\n        {PARAGRAPH_STYLES.map((blockType) =&gt; (\n          &lt;Dropdown.Item eventKey={blockType} key={blockType}&gt;\n            {getLabelForBlockStyle(blockType)}\n          &lt;/Dropdown.Item&gt;\n        ))}\n      &lt;/DropdownButton&gt;\n      {/* Buttons for character styles */}\n      {CHARACTER_STYLES.map((style) =&gt; (\n        &lt;ToolBarButton\n          key={style}\n          icon={&lt;i className={`bi ${getIconForButton(style)}`} /&gt;}\n          isActive={false}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nfunction ToolBarButton(props) {\n  const { icon, isActive, ...otherProps } = props;\n  return (\n    &lt;Button\n      variant=\"outline-primary\"\n      className=\"toolbar-btn\"\n      active={isActive}\n      {...otherProps}\n    &gt;\n      {icon}\n    &lt;/Button&gt;\n  );\n}\n</code></pre>\n</div>\n\n<p>We abstract away the buttons to the <code>ToolbarButton</code> component that is a wrapper around the React Bootstrap Button component. We then render the toolbar above the <code>Editable</code> inside <code>Editor</code> component and verify that the toolbar shows up in the application.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5bd671be-6551-4f13-976e-6ea3ab97c0f6/setup-toolbar.png\" /></p>\n<p>Here are the three key functionalities we need the toolbar to support:</p>\n<ol>\n<li>When the user’s cursor is in a certain spot in the document and they click one of the character style buttons, we need to toggle the style for the text they may type next.</li>\n<li>When the user selects a range of text and click one of the character style buttons, we need to toggle the style for that specific section.</li>\n<li>When the user selects a range of text, we want to update the paragraph-style dropdown to reflect the paragraph-type of the selection. If they do select a different value from the selection, we want to update the paragraph style of the entire selection to be what they selected.</li>\n</ol>\n<p>Let’s look at how these functionalities work on the Editor before we start implementing them.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/17e8910c-1b2f-4ff7-82fe-9d1886e6ad79/render-links.png\" /></p>\n<h4>Adding A Link Button To The Toolbar</h4>\n<p>Let’s add a Link Button to the toolbar that enables the user to do the following:</p>\n<ul>\n<li>Selecting some text and clicking on the button converts that text into a link </li>\n<li>Having a blinking cursor (collapsed selection) and clicking the button inserts a new link there</li>\n<li>If the user’s selection is inside a link, clicking on the button should toggle the link — meaning convert the link back to text.</li>\n</ul>\n<p>To build these functionalities, we need a way in the toolbar to know if the user’s selection is inside a link node. We add a util function that traverses the levels in upward direction from the user’s selection to find a link node if there is one, using <a href=\"https://github.com/ianstormtaylor/slate/blob/master/packages/slate/src/interfaces/editor.ts#L70\"><code>Editor.above</code></a> helper function from SlateJS.</p>\n<pre><code># src/utils/EditorUtils.js\n\nexport function isLinkNodeAtSelection(editor, selection) {\n  if (selection == null) {\n    return false;\n  }\n\n  return (\n    Editor.above(editor, {\n      at: selection,\n      match: (n) =&gt; n.type === \"link\",\n    }) != null\n  );\n}\n</code></pre>\n\n\n<p>Now, let’s add a button to the toolbar that is in active state if the user's selection is inside a link node.</p>\n<pre><code># src/components/Toolbar.js\n\nreturn (\n    &lt;div className=\"toolbar\"&gt;\n      ...\n      {/* Link Button */}\n      &lt;ToolBarButton\n        isActive={isLinkNodeAtSelection(editor, editor.selection)}\n        label={&lt;i className={`bi ${getIconForButton(\"link\")}`} /&gt;}\n      /&gt;\n    &lt;/div&gt;\n  );\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8698a35c-74a3-46d5-994d-b590e622d06b/link-wrap-nodes.png\" /></p>\n<p>If we had to do this by ourselves, we’d have to figure out the range of selection and create three new nodes (text, link, text) that replace the original text node. SlateJS has a helper function called <a href=\"https://github.com/ianstormtaylor/slate/blob/e4936c3f32711a646ecdb51d4a75462975861660/packages/slate/src/transforms/node.ts#L858\"><code>Transforms.wrapNodes</code></a> that does exactly this — wrap nodes at a location into a new container node. We also have a helper available for the reverse of this process — <code>Transforms.unwrapNodes</code> which we use to remove links from selected text and merge that text back into the text nodes around it. With that, <code>toggleLinkAtSelection</code> has the below implementation to insert a new link at an expanded selection.</p>\n<pre><code># src/utils/EditorUtils.js\n\nexport function toggleLinkAtSelection(editor) {\n  if (!isLinkNodeAtSelection(editor, editor.selection)) {\n    const isSelectionCollapsed =\n      Range.isCollapsed(editor.selection);\n    if (isSelectionCollapsed) {\n      Transforms.insertNodes(\n        editor,\n        {\n          type: \"link\",\n          url: '#',\n          children: [{ text: 'link' }],\n        },\n        { at: editor.selection }\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: \"link\", url: '#', children: [{ text: '' }] },\n        { split: true, at: editor.selection }\n      );\n    }\n  } else {\n    Transforms.unwrapNodes(editor, {\n      match: (n) =&gt; Element.isElement(n) &amp;&amp; n.type === \"link\",\n    });\n  }\n}\n</code></pre>\n\n<p>If the selection is collapsed, we insert a new node there with <code><a href=\"https://github.com/ianstormtaylor/slate/blob/e4936c3f32711a646ecdb51d4a75462975861660/packages/slate/src/transforms/node.ts#L17\"><code>Transform.insertNodes</code></a></code> that inserts the node at the given location in the document. We wire this function up with the toolbar button and should now have a way to add/remove links from the document with the help of the link button.</p>\n<pre><code># src/components/Toolbar.js\n      &lt;ToolBarButton\n        ...\n        isActive={isLinkNodeAtSelection(editor, editor.selection)}       \n        onMouseDown={() =&gt; toggleLinkAtSelection(editor)}\n      /&gt;\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8c2f588a-71d9-43a2-8236-5fa99f375a48/link-detection-step-1.png\" /></p>\n<p>If the text ’ABCDE’ was the first text node of the first paragraph in the document, our point values would be — </p>\n<pre><code>cursorPoint = { path: [0,0], offset: 5}\nstartPointOfLastCharacter = { path: [0,0], offset: 4}\n</code></pre>\n\n<p>If the last character was a space, we know where it started — <code>startPointOfLastCharacter.</code>Let’s move to step-2 where we move backwards character-by-character until either we find another space or the start of the text node itself. </p>\n<pre><code>...\n\n  if (lastCharacter !== \" \") {\n    return;\n  }\n\n  let end = startPointOfLastCharacter;\n  start = Editor.before(editor, end, {\n    unit: \"character\",\n  });\n\n  const startOfTextNode = Editor.point(editor, currentNodePath, {\n    edge: \"start\",\n  });\n\n  while (\n    Editor.string(editor, Editor.range(editor, start, end)) !== \" \" &amp;&amp;\n    !Point.isBefore(start, startOfTextNode)\n  ) {\n    end = start;\n    start = Editor.before(editor, end, { unit: \"character\" });\n  }\n\n  const lastWordRange = Editor.range(editor, end, startPointOfLastCharacter);\n  const lastWord = Editor.string(editor, lastWordRange);\n</code></pre>\n\n\n<p>Here is a diagram that shows where these different points point to once we find the last word entered to be <code>ABCDE</code>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e7729144-0b85-46b4-9018-46a20325881e/link-detection-step-2.png\" /></p>\n<p>Note that <code>start</code> and <code>end</code> are the points before and after the space there. Similarly, <code>startPointOfLastCharacter</code> and <code>cursorPoint</code> are the points before and after the space user just inserted. Hence <code>[end,startPointOfLastCharacter]</code> gives us the last word inserted.</p>\n<p>We log the value of <code>lastWord</code> to the console and verify the values as we type.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/eafd088d-0fb2-4a28-a063-84f0fa186b71/image-rendering.png\" /></p>\n<p>Now let’s focus on caption-editing. The way we want this to be a seamless experience for the user is that when they click on the caption, we show a text input where they can edit the caption. If they click outside the input or hit the RETURN key, we treat that as a confirmation to apply the caption. We then update the caption on the image node and switch the caption back to read mode. Let’s see it in action so we have an idea of what we’re building.</p>\n<p>Let’s update our Image component to have a state for caption’s read-edit modes. We update the local caption state as the user updates it and when they click out (<code>onBlur</code>) or hit RETURN (<code>onKeyDown</code>), we apply the caption to the node and switch to read mode again.</p>\n<pre><code>const Image = ({ attributes, children, element }) =&gt; {\n  const [isEditingCaption, setEditingCaption] = useState(false);\n  const [caption, setCaption] = useState(element.caption);\n  ...\n\n  const applyCaptionChange = useCallback(\n    (captionInput) =&gt; {\n      const imageNodeEntry = Editor.above(editor, {\n        match: (n) =&gt; n.type === \"image\",\n      });\n      if (imageNodeEntry == null) {\n        return;\n      }\n\n      if (captionInput != null) {\n        setCaption(captionInput);\n      }\n\n      Transforms.setNodes(\n        editor,\n        { caption: captionInput },\n        { at: imageNodeEntry[1] }\n      );\n    },\n    [editor, setCaption]\n  );\n\n  const onCaptionChange = useCallback(\n    (event) =&gt; {\n      setCaption(event.target.value);\n    },\n    [editor.selection, setCaption]\n  );\n\n  const onKeyDown = useCallback(\n    (event) =&gt; {\n      if (!isHotkey(\"enter\", event)) {\n        return;\n      }\n\n      applyCaptionChange(event.target.value);\n      setEditingCaption(false);\n    },\n    [applyCaptionChange, setEditingCaption]\n  );\n\n  const onToggleCaptionEditMode = useCallback(\n    (event) =&gt; {\n      const wasEditing = isEditingCaption;\n      setEditingCaption(!isEditingCaption);\n      wasEditing &amp;&amp; applyCaptionChange(caption);\n    },\n    [editor.selection, isEditingCaption, applyCaptionChange, caption]\n  );\n\n  return (\n        ...\n        {isEditingCaption ? (\n          &lt;Form.Control\n            autoFocus={true}\n            className={\"image-caption-input\"}\n            size=\"sm\"\n            type=\"text\"\n            defaultValue={element.caption}\n            onKeyDown={onKeyDown}\n            onChange={onCaptionChange}\n            onBlur={onToggleCaptionEditMode}\n          /&gt;\n        ) : (\n          &lt;div\n            className={\"image-caption-read-mode\"}\n            onClick={onToggleCaptionEditMode}\n          &gt;\n            {caption}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n      ...\n</code></pre>\n\n<p>With that, the caption editing functionality is complete. We now move to adding a way for users to upload images to the editor. Let’s add a toolbar button that lets users select and upload an image.</p>\n<pre><code># src/components/Toolbar.js\n\nconst onImageSelected = useImageUploadHandler(editor, previousSelection);\n\nreturn (\n    &lt;div className=\"toolbar\"&gt;\n    ....\n   &lt;ToolBarButton\n        isActive={false}\n        as={\"label\"}\n        htmlFor=\"image-upload\"\n        label={\n          &lt;&gt;\n            &lt;i className={`bi ${getIconForButton(\"image\")}`} /&gt;\n            &lt;input\n              type=\"file\"\n              id=\"image-upload\"\n              className=\"image-upload-input\"\n              accept=\"image/png, image/jpeg\"\n              onChange={onImageSelected}\n            /&gt;\n          &lt;/&gt;\n        }\n      /&gt;\n    &lt;/div&gt;\n</code></pre>\n\n\n\n<p>As we work with image uploads, the code could grow quite a bit so we move the image-upload handling to a hook <code>useImageUploadHandler</code> that gives out a callback attached to the file-input element. We’ll discuss shortly about why it needs the <code>previousSelection</code> state.</p>\n<p>Before we implement <code>useImageUploadHandler</code>, we’ll set up the server to be able to upload an image to. We setup an Express server and install two other packages — <a href=\"https://www.npmjs.com/package/cors\"><code>cors</code></a> and <a href=\"https://www.npmjs.com/package/multer\"><code>multer</code></a> that handle file uploads for us. </p>\n<pre><code>yarn add express cors multer\n</code></pre>\n\n<p>We then add a <code>src/server.js</code> script that configures the Express server with cors and multer and exposes an endpoint <code>/upload</code> which we will upload the image to.</p>\n<pre><code># src/server.js\n\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, \"./public/photos/\");\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.originalname);\n  },\n});\n\nvar upload = multer({ storage: storage }).single(\"photo\");\n\napp.post(\"/upload\", function (req, res) {\n  upload(req, res, function (err) {\n    if (err instanceof multer.MulterError) {\n      return res.status(500).json(err);\n    } else if (err) {\n      return res.status(500).json(err);\n    }\n    return res.status(200).send(req.file);\n  });\n});\n\napp.use(cors());\napp.listen(port, () =&gt; console.log(`Listening on port ${port}`));\n</code></pre>\n\n<p>Now that we have the server setup, we can focus on handling the image upload. When the user uploads an image, it could be a few seconds before the image gets uploaded and we have a URL for it. However, we do what to give the user immediate feedback that the image upload is in progress so that they know the image is being inserted in the editor. Here are the steps we implement to make this behavior work -</p>\n<ol>\n<li>Once the user selects an image, we insert an image node at the user’s cursor position with a flag <code>isUploading</code> set on it so we can show the user a loading state.</li>\n<li>We send the request to the server to upload the image.</li>\n<li>Once the request is complete and we have an image URL, we set that on the image and remove the loading state.</li>\n</ol>\n<p>Let’s begin with the first step where we insert the image node. Now, the tricky part here is we run into the same issue with selection as with the link button in the toolbar. As soon as the user clicks on the Image button in the toolbar, the editor loses focus and the selection becomes <code>null</code>. If we try to insert an image, we don’t know where the user's cursor was. Tracking <code>previousSelection</code> gives us that location and we use that to insert the node.</p>\n<pre><code># src/hooks/useImageUploadHandler.js\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport default function useImageUploadHandler(editor, previousSelection) {\n  return useCallback(\n    (event) =&gt; {\n      event.preventDefault();\n      const files = event.target.files;\n      if (files.length === 0) {\n        return;\n      }\n      const file = files[0];\n      const fileName = file.name;\n      const formData = new FormData();\n      formData.append(\"photo\", file);\n\n      const id = uuidv4();\n\n      Transforms.insertNodes(\n        editor,\n        {\n          id,\n          type: \"image\",\n          caption: fileName,\n          url: null,\n          isUploading: true,\n          children: [{ text: \"\" }],\n        },\n        { at: previousSelection, select: true }\n      );\n    },\n    [editor, previousSelection]\n  );\n}\n</code></pre>\n\n<p>As we insert the new image node, we also assign it an identifier <code>id</code> using the <a href=\"https://www.npmjs.com/package/uuid\">uuid</a> package. We’ll discuss in Step (3)’s implementation why we need that. We now update the image component to use the <code>isUploading</code> flag to show a loading state.</p>\n<pre><code>{!element.isUploading &amp;&amp; element.url != null ? (\n   &lt;img src={element.url} alt={caption} className={\"image\"} /&gt;\n) : (\n   &lt;div className={\"image-upload-placeholder\"}&gt;\n        &lt;Spinner animation=\"border\" variant=\"dark\" /&gt;\n   &lt;/div&gt;\n)}\n</code></pre>\n\n<p>That completes the implementation of step 1. Let’s verify that we are able to select an image to upload, see the image node getting inserted with a loading indicator where it was inserted in the document.</p>\n<p>Moving to Step (2), we will use <a href=\"https://www.npmjs.com/package/axios\">axois</a> library to send a request to the server.</p>\n<pre><code>export default function useImageUploadHandler(editor, previousSelection) {\n  return useCallback((event) =&gt; {\n    ....\n    Transforms.insertNodes(\n     …\n     {at: previousSelection, select: true}\n    );\n\n    axios\n      .post(\"/upload\", formData, {\n        headers: {\n          \"content-type\": \"multipart/form-data\",\n        },\n      })\n      .then((response) =&gt; {\n           // update the image node.\n       })\n      .catch((error) =&gt; {\n        // Fire another Transform.setNodes to set an upload failed state on the image\n      });\n  }, [...]);\n}\n</code></pre>\n\n<p>We verify that the image upload works and the image does show up in the <code>public/photos</code> folder of the app. Now that the image upload is complete, we move to Step (3) where we want to set the URL on the image in the <code>resolve()</code> function of the axios promise. We could update the image with <code>Transforms.setNodes</code> but we have a problem — we do not have the path to the newly inserted image node. Let’s see what our options are to get to that image — </p>\n<ul>\n<li>Can’t we use <code>editor.selection</code> as the selection must be on the newly inserted image node? We cannot guarantee this since while the image was uploading, the user might have clicked somewhere else and the selection might have changed.</li>\n<li>How about using <code>previousSelection</code>  which we used to insert the image node in the first place? For the same reason we can’t use <code>editor.selection</code>, we can’t use <code>previousSelection</code> since it may have changed too.</li>\n<li>SlateJS has a <a href=\"https://docs.slatejs.org/libraries/slate-history\">History</a> module that tracks all the changes happening to the document. We could use this module to search the history and find the last inserted image node. This also isn’t completely reliable if it took longer for the image to upload and the user inserted more images in different parts of the document before the first upload completed.</li>\n<li>Currently, <code>Transform.insertNodes</code>’s API doesn’t return any information about the inserted nodes. If it could return the paths to the inserted nodes, we could use that to find the precise image node we should update. </li>\n</ul>\n<p>Since none of the above approaches work, we apply an <code>id</code> to the inserted image node (in Step (1)) and use the same <code>id</code> again to locate it when the image upload is complete. With that, our code for Step (3) looks like below — </p>\n<pre><code>axios\n        .post(\"/upload\", formData, {\n          headers: {\n            \"content-type\": \"multipart/form-data\",\n          },\n        })\n        .then((response) =&gt; {\n          const newImageEntry = Editor.nodes(editor, {\n            match: (n) =&gt; n.id === id,\n          });\n\n          if (newImageEntry == null) {\n            return;\n          }\n\n          Transforms.setNodes(\n            editor,\n            { isUploading: false, url: `/photos/${fileName}` },\n            { at: newImageEntry[1] }\n          );\n        })\n        .catch((error) =&gt; {\n          // Fire another Transform.setNodes to set an upload failure state\n          // on the image.        \n        });\n</code></pre>\n\n<p>With the implementation of all three steps complete, we are ready to test the image upload end to end.</p>\n<p>With that, we’ve wrapped up Images for our editor. Currently, we show a loading state of the same size irrespective of the image. This could be a jarring experience for the user if the loading state is replaced by a drastically smaller or bigger image when the upload completes. A good follow up to the upload experience is getting the image dimensions before the upload and showing a placeholder of that size so that transition is seamless. The hook we add above could be extended to support other media types like video or documents and render those types of nodes as well.</p>\n<h3>Conclusion</h3>\n<p>In this article, we have built a WYSIWYG Editor that has a basic set of functionalities and some micro user-experiences like link detection, in-place link editing and image caption editing that helped us go deeper with SlateJS and concepts of Rich Text Editing in general. If this problem space surrounding Rich Text Editing or Word Processing interests you, some of the cool problems to go after could be:</p>\n<ul>\n<li>Collaboration</li>\n<li>A richer text editing experience that supports text alignments, inline images, copy-paste, changing font and text colors etc.</li>\n<li>Importing from popular formats like Word documents and Markdown.</li>\n</ul>\n<p>If you want to learn more SlateJS, here are some links that might be helpful.</p>\n<ul>\n<li><a href=\"https://www.slatejs.org/examples/richtext\">SlateJS Examples</a><br />A lot of examples that go beyond the basics and build functionalities that are usually found in Editors like Search &amp; Highlight, Markdown Preview and Mentions.</li>\n<li><a href=\"https://docs.slatejs.org/api/transforms\">API Docs</a><br />Reference to a lot of helper functions exposed by SlateJS that one might want to keep handy when trying to perform complex queries/transformations on SlateJS objects.</li>\n</ul>\n<p>Lastly, SlateJS’s <a href=\"https://slate-slack.herokuapp.com/\">Slack Channel</a> is a very active community of web developers building Rich Text Editing applications using SlateJS and a great place to learn more about the library and get help if needed.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"a5da29bdfaa6c9f3788c86c58592775e59dbc061323bd47234f264ba8319025a","category":"Tech"}