{"title":"A Kubernetes User's Guide to HashiCorp Nomad","link":"https://www.hashicorp.com/blog/a-kubernetes-user-s-guide-to-hashicorp-nomad","date":1614272400000,"content":"<p>Both Kubernetes and HashiCorp Nomad are mature orchestrators used for managing the lifecycle of containerized applications. Teams and organizations choose Nomad for its core strengths of simplicity and flexibility. For users coming from a Kubernetes background, this blog series may help you find the equivalent terminology and understand the basics of Nomad.</p>\n<h2><a class=\"__permalink-h\" href=\"#what-kubernetes-and-nomad-have-in-common\" aria-label=\"what kubernetes and nomad have in common permalink\">»</a><a class=\"__target-h\" id=\"what-kubernetes-and-nomad-have-in-common\" aria-hidden></a>What Kubernetes and Nomad Have in Common</h2>\n<p>Both tools support similar core use cases that help enterprises get their containerized applications up and running. The common feature set includes:</p>\n<ul>\n<li>Automated scheduling</li>\n<li>Self-recovery or self-healing of the applications</li>\n<li>Rollout and rollback strategy</li>\n<li>Storage orchestration</li>\n</ul>\n<h2><a class=\"__permalink-h\" href=\"#how-kubernetes-and-nomad-differ\" aria-label=\"how kubernetes and nomad differ permalink\">»</a><a class=\"__target-h\" id=\"how-kubernetes-and-nomad-differ\" aria-hidden></a>How Kubernetes and Nomad Differ</h2>\n<p>Kubernetes aims to build a powerful platform with all the features included. It is designed to work as a collection of several interoperating components which together provide the full functionality. By contrast, Nomad was designed to focus solely on cluster management and scheduling. It intentionally leaves out non-core features so that it can run as a single process with zero external dependencies. It integrates with other tools like Consul for networking and Vault for secret management.</p>\n<p>Another key difference is that Nomad is more <a href=\"https://www.hashicorp.com/resources/how-does-nomad-work\">general purpose</a>. It supports virtualized, containerized, and standalone applications, such as Docker, Java, IIS on Windows, QEMU, application binary/executable, etc. You can look at the differences in greater detail <a href=\"https://www.nomadproject.io/docs/nomad-vs-kubernetes\">here</a>.</p><img src=https://www.datocms-assets.com/2885/1614188817-k8s-nomad-functionality.png alt=Comparing Nomad and K8s components><h2><a class=\"__permalink-h\" href=\"#architecture\" aria-label=\"architecture permalink\">»</a><a class=\"__target-h\" id=\"architecture\" aria-hidden></a>Architecture</h2>\n<p>Both Nomad and Kubernetes follow a Client-Server architecture. In Kubernetes, they are called “<strong>Control Plane</strong>” and “ <strong>Node</strong>”. In Nomad, they are called “<strong>Server</strong>” and “<strong>Client</strong>”. A “<strong>Region</strong>” in Nomad describes a set of Server Nodes and Client Nodes operating together to orchestrate applications. It is similar to a Kubernetes “<strong>Cluster</strong>”, and these two terms are often used interchangeably.</p>\n<p>Kubernetes requires a number of different processes to be installed on the control plane and nodes: the control plane consists of etcd, kube-apiserver, kube-scheduler, and kube-controller-manager, while the nodes run kubelet and kube-proxy. Nomad, however, is a single binary, which can be configured as either a server or client agent.</p>\n<h3><a class=\"__permalink-h\" href=\"#client-node\" aria-label=\"client node permalink\">»</a><a class=\"__target-h\" id=\"client-node\" aria-hidden></a>Client Node</h3>\n<p>Nomad’s client nodes require a single process to be installed.</p><img src=https://www.datocms-assets.com/2885/1614277182-nomad-blog-worker-client.png alt=K8s worker node and Nomad client node><ul>\n<li><strong>Client agent</strong>: An agent that fingerprints the node and provides information to the Nomad servers for scheduling. It makes sure that the task is running and manages its lifecycle. It is similar to <strong>Kubelet</strong>.</li>\n<li><strong>Task driver [Optional]</strong>: Task drivers are the runtime components. The Nomad Client agent provides built-in drivers such as Docker, Java, exec, QEMU, etc. Additionally, the task driver system is pluggable so that users can use any community plugin or create their own. In that case, the additional drivers need to be installed on the client node.</li>\n</ul>\n<h3><a class=\"__permalink-h\" href=\"#server-node\" aria-label=\"server node permalink\">»</a><a class=\"__target-h\" id=\"server-node\" aria-hidden></a>Server Node</h3>\n<p>A Nomad server node requires a single process.</p><img src=https://www.datocms-assets.com/2885/1614277208-nomad-blog-control-server.png alt=K8s control plane vs Nomad server node><ul>\n<li><strong>Nomad server agent:</strong> The server agent maintains the cluster state and performs the scheduling. It combines multiple functions into one lightweight process\n<ul>\n<li><strong>API</strong>: Nomad supports two API protocols: an RPC API used mainly for internal server-server and server-client communication and an HTTP API used by the UI, CLI, and most external tooling.</li>\n<li><strong>Controllers</strong>: Server agents are internally responsible for most of the work associated with managing a Region. For external controllers such as the Nomad Autoscaler, instead of running special services in the control plane, they are built as Nomad “Jobs” running alongside users’ applications on the Client nodes.</li>\n<li><strong>Cluster data</strong>: Instead of relying on an external state store like <strong>etcd</strong>, each Nomad server agent internally implements the <a href=\"https://www.hashicorp.com/resources/raft-consul-consensus-protocol-explained\">Raft algorithm</a> to maintain the cluster state.</li>\n</ul>\n</li>\n</ul>\n<h3><a class=\"__permalink-h\" href=\"#production-deployment\" aria-label=\"production deployment permalink\">»</a><a class=\"__target-h\" id=\"production-deployment\" aria-hidden></a>Production Deployment</h3><img src=https://www.datocms-assets.com/2885/1614188812-k8s-etcd-cluster-nomad-group.png alt=K8s external etcd cluster vs Nomad cluster><p>For a production environment, it is critical to ensure that the control plane is highly available. For Kubernetes, users run multiple instances of the control plane behind a load balancer. Decoupling etcd from the rest of the control plane components is recommended.</p>\n<p>For Nomad, the server nodes are highly available by design. We recommend running 3 or 5 server nodes per region. All servers perform some management work, such as making scheduling decisions in parallel. Servers in a region are part of a consensus group and work together autonomously to elect a single leader which has extra duties. The <strong>leader</strong> provides cluster-level coordination, manages cluster status changes, and replicates the cluster state to the followers. If the leader fails, one of the <strong>followers</strong> is automatically elected to leader without the need for operator intervention.</p>\n<h2><a class=\"__permalink-h\" href=\"#core-concepts\" aria-label=\"core concepts permalink\">»</a><a class=\"__target-h\" id=\"core-concepts\" aria-hidden></a>Core Concepts</h2>\n<h3><a class=\"__permalink-h\" href=\"#job-task-task-group-and-allocation\" aria-label=\"job task task group and allocation permalink\">»</a><a class=\"__target-h\" id=\"job-task-task-group-and-allocation\" aria-hidden></a>Job, Task, Task Group, and Allocation</h3><img src=https://www.datocms-assets.com/2885/1614277148-nomad-blog-docker.png alt=K8s pods vs Nomad Groups><p>In Kubernetes, <strong>Pods</strong> are the smallest deployable units. A Pod can contain one or more containers with shared storage and network resources. The resource for deploying pods — Deployment — is the most commonly used resource. The specification for a deployment features a pod spec and the desired number of replicas of the pod.</p>\n<p>In Nomad, users define how applications should be deployed with a declarative specification: the Nomad <strong>Job</strong>. A job represents a desired application state defined in JSON or HCL format. In a Nomad job, <strong>Tasks</strong> are the smallest units of deployment. A task could be a Docker container, a Java application, or a batch processing job. It is similar to an individual container in a Pod.</p>\n<p>A <strong>Task Group</strong> defines a set of tasks that must be run on the same client node. Tasks in the same group can be configured to share network and storage resources. Each group has a <code>count</code> parameter to indicate the desired number of instances. It is similar to how users specify pods and the number of pod replicas in ReplicaSet or via Deployment.</p>\n<p>An <strong>Allocation</strong> is an instantiation of a task group running on a client node. If there need to be 3 instances of a task group specified in the job, Nomad will create 3 allocations and place those accordingly. An allocation is similar to a pod once the pod is scheduled on a worker node.</p>\n<p>In short, a Nomad job is composed of one or multiple different task groups, and a task group is composed of one or more tasks. Once the job is submitted to a Nomad server, each task group will have a certain number of allocations to be created based on the number of instances required.</p><pre><code>job \"example\" {\n  region = \"us\"\n  datacenters = [\"us-west-1\", \"us-east-1\"]  \n  type = \"service\" # Run this job as a \"service\" type\n  constraint {\n    attribute = \"${attr.kernel.name}\"\n    value     = \"linux\"\n  }\n  group \"cache\" {\n    count = 3 # number of instances\n\n    task \"redis\" {\n      driver = \"docker\"\n\n      config {\n        image = \"redis:6.0\"\n      }\n      resources {\n        cpu    = 500 # 500 MHz\n        memory = 256 # 256MB\n      }\n    }\n  }\n}</code></pre><p>Kubernetes provides multiple ways of creating pods depending on the nature of the application: Deployment, ReplicaSet, DaemonSet, Job, CronJob, and so on. In Nomad, a single job spec allows users to define how various applications should be running. Through parameters like <code>type</code>, <code> periodic</code>, and <code>parameterized</code>, Nomad jobs allow users to specify the application type and desired scheduling paradigms. Nomad servers will invoke the appropriate scheduler to deploy applications.</p>\n<h2><a class=\"__permalink-h\" href=\"#networking\" aria-label=\"networking permalink\">»</a><a class=\"__target-h\" id=\"networking\" aria-hidden></a>Networking</h2>\n<p>Nomad and Kubernetes differ a lot in networking. In a Kubernetes cluster, there are normally three IP networks:</p>\n<ul>\n<li><strong>Node network</strong>: The physical network that your nodes are connected to</li>\n<li><strong>Pod network</strong>: In Kubernetes, each pod gets its own unique IP. The pod network is separate from the node network and many users choose to implement an overlay network to route traffic between pods and nodes.</li>\n<li><strong>Service network</strong>: A service is a Kuberentes resource that represents a group of pods, with a permanent IP address. The service network is a system of virtual IPs that are generally separate from Pod and Node networks.</li>\n</ul><img src=https://www.datocms-assets.com/2885/1614188832-nomad-k8s-networking.png alt=K8s networking vs Nomad networking><p>Because of these separate networks, external applications cannot directly communicate with applications within a Kuberentes cluster. Most users choose to deploy an <strong>ingress controller</strong> — a pod running reverse proxy like Nginx — and expose it as the single entry point to a Kubernetes cluster.</p>\n<p>Nomad’s default network is the <strong>Node network</strong>. Each task group instance uses the Node IP network and gets its own port through dynamic port assignment. Since there is no Virtual IP or an additional overlay network required, the Nomad cluster network can be part of an existing enterprise network.</p>\n<h3><a class=\"__permalink-h\" href=\"#networking-with-consul\" aria-label=\"networking with consul permalink\">»</a><a class=\"__target-h\" id=\"networking-with-consul\" aria-hidden></a>Networking with Consul</h3>\n<p>In Kubernetes, the <strong>Service</strong> and <strong>Kube-proxy</strong> are responsible for tracking the pods and routing the traffic to them. In Nomad, this function can be done by another HashiCorp product, <a href=\"https://www.consul.io/\">Consul</a>.</p>\n<p>Consul is a widely-deployed networking tool that provides a fully featured service mesh and service discovery. It allows application instances to easily register themselves in a central catalog. When applications need to communicate with each other, the central catalog can be queried using either an API or DNS interface to provide the required network location.</p>\n<p>Consul and Nomad have a lot of similarities in architecture. Consul Client agents register the application instance and are responsible for health checking, while Consul Server agents collect the information shared by the agents and keep the central catalog up-to-date.</p>\n<p>Through native integration, users can specify the job file to automatically register task groups with Consul. A task group can define one or more services identified by a unique name. When each allocation is started, Nomad registers the IP address and port for the defined services with Consul.</p><img src=https://www.datocms-assets.com/2885/1614190375-nomad-consul-setup.png alt=Nomad and Consul server node><h3><a class=\"__permalink-h\" href=\"#load-balancing-and-ingress\" aria-label=\"load balancing and ingress permalink\">»</a><a class=\"__target-h\" id=\"load-balancing-and-ingress\" aria-hidden></a>Load Balancing and Ingress</h3>\n<p>One approach to load balancing is to use Consul's built-in load balancing functionality. Consul integrates health checks with service discovery. By default, unhealthy application instances are never returned from queries to the service discovery layer. In this mode, applications running on Nomad can talk directly to Consul each time they want to find other applications. It will receive a randomized response containing a list of network locations that correspond to healthy application instances in the cluster. The DNS interface offers essentially zero-touch service discovery integration into any application.</p>\n<p>In addition to discovering applications through Consul DNS, users may choose to <a href=\"https://learn.hashicorp.com/tutorials/nomad/load-balancing?in=nomad/load-balancing\">deploy load balancers</a>. Nomad and Consul integrate with NGINX, HAProxy, Envoy, Traefik, and other popular reverse proxies. Nomad Jobs support a <code>templates</code> stanza to populate dynamic values from environment variables, service and key-value data from Consul, or secret data from <a href=\"https://www.vaultproject.io/\">HashiCorp Vault</a> into configuration files. In this load balancer deployment scenario, users can set up Nomad to handle several things:</p>\n<ul>\n<li>Automating the deployment and scaling of load balancers</li>\n<li>Leveraging the built-in templating support to dynamically update backend configuration files as applications scale up and down</li>\n<li>Specifying auto-reloading of the load balancers in Nomad jobs when the configuration files change</li>\n</ul>\n<p>One of the main use cases of a load balancer is to distribute incoming traffic from the internet to frontend applications running on Nomad that can handle those requests. This provides functionality similar to an <strong>ingress controller</strong> in Kubernetes.</p>\n<h3><a class=\"__permalink-h\" href=\"#next-steps\" aria-label=\"next steps permalink\">»</a><a class=\"__target-h\" id=\"next-steps\" aria-hidden></a>Next Steps</h3>\n<p>We hope you find these comparisons of core concepts useful. In the later posts of this series, we will look at the typical security and cryptography workflows, basic operation and troubleshooting, and more. Let us know if you are looking for a particular topic <a href=\"https://forms.gle/Vuk9rCbWgzJ2DJbx6\">here</a>.</p>\n<p>To get started with Nomad, visit the <a href=\"https://learn.hashicorp.com/nomad\">HashiCorp Learn platform</a> to get step-by-step instructions.</p>","author":"Chang Li","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"99f952e47249b852401278db5cf7f79ecc9d619d70b87bdec4e4a1b99fc9a599","category":"Tech"}