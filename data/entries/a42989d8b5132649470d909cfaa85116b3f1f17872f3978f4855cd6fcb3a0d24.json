{"title":"What’s Coming To VueX?","link":"https://smashingmagazine.com/2020/12/vuex-library/","date":1608802213000,"content":"<p><a href=\"https://vuex.vuejs.org/\">Vuex</a> is <em>the</em> solution for state management in Vue applications. The next version — Vuex 4 — is making its way through the final steps before officially releasing. This release will bring full compatibility with Vue 3, but doesn’t add new features. While Vuex has always been a powerful solution, and the first choice for many developers for state management in Vue, some developers had hoped to see more workflow issues addressed. However, even as Vuex 4 is just getting out the door, <a href=\"https://github.com/kiaking\">Kia King Ishii</a> (a Vue core team member) is <a href=\"https://youtu.be/dQ5btkDrdJ8\">talking about his plans for Vuex 5</a>, and I’m so excited by what I saw that I had to share it with you all. Note that Vuex 5 plans are <em>not</em> finalized, so some things may change before Vuex 5 is released, but if it ends up mostly similar to what you see in this article, it should be a big improvement to the developer experience.</p>\n<p>With the advent of Vue 3 and it’s <a href=\"https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api\">composition API</a>, people have been looking into hand-built simple alternatives. For example, <a href=\"https://dev.to/blacksonic/you-might-not-need-vuex-with-vue-3-52e4\"><em>You Might Not Need Vuex</em></a> demonstrates a relatively simple, yet flexible and robust pattern for using the composition API along with <code>provide/inject</code> to create shared state stores. As Gábor states in his article, though, this (and other alternatives) should only be used in smaller applications because they lack all those things that aren’t directly about the code: community support, documentation, conventions, good <a href=\"https://nuxtjs.org/\">Nuxt</a> integrations, and developer tools.</p>\n<p>That last one has always been one of the biggest issues for me. The <a href=\"https://github.com/vuejs/vue-devtools\">Vue devtools</a> browser extension has always been an amazing tool for debugging and developing Vue apps, and losing the Vuex inspector with “time travel” would be a pretty big loss for debugging any non-trivial applications.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/efd616f6-9b32-4a34-8de3-77cb86394e72/vuex-devtools.png\" /></p>\n<p>Thankfully, with Vuex 5 we’ll be able to have our cake and eat it too. It will work more like these composition API alternatives but keep all the benefits of using an official state management library. Now let’s take a look at what will be changing.</p>\n<h3>Defining A Store</h3>\n<p>Before we can do anything with a Vuex store, we need to define one. In Vuex 4, a store definition will look like this:</p>\n<pre><code>import { createStore } from 'vuex'\n\nexport const counterStore = createStore({\n  state: {\n    count: 0\n  },\n\n  getters: {\n    double (state) {\n      return state.count * 2\n    }\n  },\n\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})</code></pre>\n\n<p>Each store has four parts: <code>state</code> stores the data, <code>getters</code> give you computed state, <code>mutations</code> are used to mutate the state, and <code>actions</code> are the methods that are called from outside the store to accomplish anything related to the store. Usually, actions don’t just commit a mutation as this example shows. Instead, they are used to do asynchronous tasks because mutations <em>must</em> be synchronous or they just implement more complicated or multi-step functionality. Actions also cannot mutate the state on their own; they must use a mutator. So what does Vuex 5 look like?</p>\n<pre><code>import { defineStore } from 'vuex'\n\nexport const counterStore = defineStore({\n  name: 'counter',\n\n  state() {\n    return { count: 0 }\n  },\n\n  getters: {\n    double () {\n      return this.count * 2\n    }\n  },\n\n  actions: {\n    increment () {\n      this.count++\n    }\n  }\n})</code></pre>\n\n<p>There are a few changes to note here. First, instead of <code>createStore</code>, we use <code>defineStore</code>. This difference is negligible, but it’s there for semantic reasons, which we’ll go over later. Next, we need to provide a <code>name</code> for the store, which we didn’t need before. In the past, modules got their own name, but they weren’t provided by the module itself; they were just the property name they were assigned to by the parent store that added them. Now, there are <em>no modules</em>. Instead, each module will be a separate store and have a name. This name is used by the Vuex registry, which we’ll talk about later.</p>\n<p>After that, we need to make <code>state</code> a function that returns the initial state instead of just setting it to the initial state. This is similar to the <code>data</code> option on components. We write <code>getters</code> very similar to the way we did in Vuex 4, but instead of using the <code>state</code> as a parameter for each getter, you can just use <code>this</code> to get to the state. In the same way, <code>actions</code> don’t need to worry about a <code>context</code> object being passed in: they can just use <code>this</code> to access everything. Finally, there are no <code>mutations</code>. Instead, mutations are combined with <code>actions</code>. Kia <a href=\"https://youtu.be/dQ5btkDrdJ8?t=505\">noted</a> that too often, mutations just became simple setters, making them pointlessly verbose, so they removed them. He didn’t mention whether it was “ok” to mutate the state directly from outside the store, but we are definitely allowed and encouraged to mutate state directly from an action and the Flux pattern frowns on the direct mutation of state.</p>\n<p><strong>Note</strong>: <em>For those who prefer the composition API over the options API for creating components, you’ll be happy to learn there is also a way to create stores in a similar fashion to using the composition API.</em></p>\n<pre><code>import { ref, computed } from 'vue'\nimport { defineStore } from 'vuex'\n\nexport const counterStore = defineStore('counter', {\n  const count = ref(0)\n\n  const double = computed(() =&gt; count.value * 2)\n\n  function increment () {\n    count.value++\n  }\n\n  return { count, double, increment }  \n})</code></pre>\n\n<p>As shown above, the name gets passed in as the first argument for <code>defineStore</code>. The rest looks just like a composition function for components. This will yield exactly the same result as the previous example that used the options API.</p>\n<h3>Getting The Store Instantiated</h3>\n<p>In Vuex 4, things have changed from Vuex 3, but I’ll just look at v4 to keep things from getting out of hand. In v4, when you called <code>createStore</code>, you already instantiated it. You can then just use it in your app, either via <code>app.use</code> or directly:</p>\n<pre><code>import { createApp } from 'vue'\nimport App from './App.vue' // Your root component\nimport store from './store' // The store definition from earlier\n\nconst app = createApp(App)\n\napp.use(store)\napp.mount('#app')\n\n// Now all your components can access it via `this.$store`\n// Or you can use in composition components with `useStore()`\n\n// -----------------------------------------------\n\n// Or use directly... this is generally discouraged\nimport store from './store'\n\nstore.state.count // -&gt; 0\nstore.commit('increment')\nstore.dispatch('increment')\nstore.getters.double // -&gt; 4</code></pre>\n\n<p>This is one thing that Vuex 5 makes a bit more complicated than in v4. Each app now can get a separate instance of Vuex, which makes sure that each app can have separate instances of the same stores without sharing data between them. You can share an instance of Vuex if you want to share instances of stores between apps.</p>\n<pre><code>import { createApp } from 'vue'\nimport { createVuex } from 'vuex'\nimport App from './App.vue' // Your root component\n\nconst app = createApp(App)\nconst vuex = createVuex() // create instance of Vuex\n\napp.use(vuex) // use the instance\napp.mount('#app')</code></pre>\n\n<p>Now all of your components have access to the Vuex instance. Instead of giving your store(s) definition directly, you then import them into the components you want to use them in and use the Vuex instance to instantiate and register them:</p>\n<pre><code>import { defineComponent } from 'vue'\nimport store from './store'\n\nexport default defineComponent({\n  name: 'App',\n\n  computed: {\n    counter () {\n      return this.$vuex.store(store)\n    }\n  }\n})</code></pre>\n\n<p>Calling <code>$vuex.store</code>, instantiates and registers the store in the Vuex instance. From that point on, any time you use <code>$vuex.store</code> on that store, it’ll give you back the already instantiated store instead of instantiating it again. You can call the <code>store</code> method straight on an instance of Vuex created by <code>createVuex()</code>.</p>\n<p>Now your store is accessible on that component via <code>this.counter</code>. If you’re using the composition API for your component, you can use <code>useStore</code> instead of <code>this.$vuex.store</code>:</p>\n<pre><code>import { defineComponent } from 'vue'\nimport { useStore } from 'vuex' // import useStore\nimport store from './store'\n\nexport default defineComponent({\n  setup () {\n    const counter = useStore(store)\n\n    return { counter }\n  }\n})</code></pre>\n\n<p>There are pros and cons to importing the store directly into the component and instantiating it there. It allows you to code split and lazily loads the store only where it’s needed, but now it’s a direct dependency instead of being injected by a parent (not to mention you need to import it every time you want to use it). If you want to use dependency injection to provide it throughout the app, especially if you know it’ll be used at the root of the app where code splitting won’t help, then you can just use <code>provide</code>:</p>\n<pre><code>import { createApp } from 'vue'\nimport { createVuex } from 'vuex'\nimport App from './App.vue'\nimport store from './store'\n\nconst app = createApp(App)\nconst vuex = createVuex()\n\napp.use(vuex)\napp.provide('store', store) // provide the store to all components\napp.mount('#app')</code></pre>\n\n<p>And you can just inject it in any component where you’re going to use it:</p>\n<pre><code>import { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'App',\n  inject: ['store']\n})\n\n// Or with Composition API\n\nimport { defineComponent, inject } from 'vue'\n\nexport default defineComponent({\n  setup () {\n    const store = inject('store')\n\n    return { store }\n  }\n})</code></pre>\n\n<p>I’m not excited about this extra verbosity, but it is more explicit and more flexible, which I am a fan of. This type of code is generally written once right away at the beginning of the project and then it doesn’t bother you again, though now you’ll either need to provide each new store or import it every time you wish to use it, but importing or injecting code modules is how we generally have to work with anything else, so it’s just making Vuex work more along the lines of how people already tend to work.</p>\n<h3>Using A Store</h3>\n<p>Apart from being a fan of the flexibility and the new way of defining stores the same way as a component using the composition API, there’s one more thing that makes me more excited than everything else: how stores are used. Here’s what it looks like to use a store in Vuex 4.</p>\n<pre><code>store.state.count            // Access State\nstore.getters.double         // Access Getters\nstore.commit('increment')    // Mutate State\nstore.dispatch('increment')  // Run Actions</code></pre>\n\n<p><code>State</code>, <code>getters</code>, <code>mutations</code>, and <code>actions</code> are all handled in different ways via different properties or methods. This has the advantage of explicitness, which I praised earlier, but this explicitness doesn’t really gain us anything. And this API only gets more difficult to use when you are using namespaced modules. By comparison, Vuex 5 looks to work exactly how you would normally hope:</p>\n<pre><code>store.count        // Access State\nstore.double       // Access Getters (transparent)\nstore.increment()  // Run actions\n// No Mutators</code></pre>\n\n<p>Everything — the state, getters and actions — is available directly at the root of the store, making it simple to use with a lot less verbosity and practically removes all need for using <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> and <code>mapMutations</code> for the options API or for writing <a href=\"https://next.vuex.vuejs.org/guide/composition-api.html#accessing-state-and-getters\">extra <code>computed</code> statements or simple functions for composition API</a>. This simply makes a Vuex store look and act just like a normal store that you would build yourself, but it gets all the benefits of plugins, debugging tools, official documentation, etc.</p>\n<h3>Composing Stores</h3>\n<p>The final aspect of Vuex 5 we’ll look at today is composability. Vuex 5 doesn’t have namespaced modules that are all accessible from the single store. Each of those modules would be split into a completely separate store. That’s simple enough to deal with for components: they just import whichever stores they need and fire them up and use them. But what if one store wants to interact with another store? In v4, the namespacing convolutes the whole thing, so you need to use the namespace in your <code>commit</code> and <code>dispatch</code> calls, use <code>rootGetters</code> and <code>rootState</code> and then work your way up into the namespaces you want to access getters and state from. Here’s how it works in Vuex 5:</p>\n<div>\n<pre><code>// store/greeter.js\nimport { defineStore } from 'vuex'\n\nexport default defineStore({\n  name: 'greeter',\n  state () {\n    return { greeting: 'Hello' }\n  }\n})\n\n// store/counter.js\nimport { defineStore } from 'vuex'\nimport greeterStore from './greeter' // Import the store you want to interact with\n\nexport default defineStore({\n  name: 'counter',\n\n  // Then <code>use</code> the store\n  use () {\n    return { greeter: greeterStore }\n  },\n\n  state () {\n    return { count: 0 }\n  },\n\n  getters: {\n    greetingCount () {\n      return `${this.greeter.greeting} ${this.count}' // access it from this.greeter\n    }\n  }\n})</code></pre>\n</div>\n\n<p>With v5, we import the store we wish to use, then register it with <code>use</code> and now it’s accessible all over the store at whatever property name you gave it. Things are even simpler if you’re using the composition API variation of the store definition:</p>\n<div>\n<pre><code>// store/counter.js\nimport { ref, computed } from 'vue'\nimport { defineStore } from 'vuex'\nimport greeterStore from './greeter' // Import the store you want to interact with\n\nexport default defineStore('counter', ({use}) =&gt; { // <code>use</code> is passed in to function\n  const greeter = use(greeterStore) // use <code>use</code> and now you have full access\n  const count = 0\n\n  const greetingCount = computed(() =&gt; {\n    return  <code>${greeter.greeting} ${this.count}</code> // access it like any other variable\n  })\n\n  return { count, greetingCount }\n})</code></pre>\n</div>\n\n<p>No more namespaced modules. Each store is separate and is used separately. You can use <code>use</code> to make a store available inside another store to compose them. In both examples, <code>use</code> is basically just the same mechanism as <code>vuex.store</code> from earlier and they ensure that we instantiating the stores with the correct instance of Vuex.</p>\n<h3>TypeScript Support</h3>\n<p>For TypeScript users, one of the greatest aspects of Vuex 5 is that the simplification made it simpler to add types to everything. The layers of abstraction that older versions of Vuex had made it nearly impossible and right now, with Vuex 4, they increased our ability to use types, but there is still too much manual work to get a decent amount of type support, whereas in v5, you can put your types inline, just as you would hope and expect.</p>\n<h3>Conclusion</h3>\n<p>Vuex 5 looks to be almost exactly what I — and likely many others — hoped it would be, and I feel it can’t come soon enough. It simplifies most of Vuex, removing some of the mental overhead involved, and only gets more complicated or verbose where it adds flexibility. Leave comments below about what you think of these changes and what changes you might make instead or in addition. Or go straight to the source and <a href=\"https://github.com/vuejs/rfcs/pulls\">add an RFC</a> (Request for Comments) to the list to see what the core team thinks.</p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"a42989d8b5132649470d909cfaa85116b3f1f17872f3978f4855cd6fcb3a0d24","category":"Tech"}