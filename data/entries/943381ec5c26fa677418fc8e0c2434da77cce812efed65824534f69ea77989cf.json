{"title":"Reactivity In Vue","link":"https://smashingmagazine.com/2021/03/reactivity-in-vue/","date":1616666400000,"content":"<p>In this article, we’re going to look at reactivity in Vue, how it works, and how we can create reactive variables using newly created methods and functions.</p>\n<p>This article is targeted at developers who have a good understanding of how Vue 2.x works and are looking to get familiar with the new Vue 3.</p>\n<p>We’re going to build a simple application to better understand this topic. The code for this app can be found <a href=\"https://github.com/Timibadass/vue-reactivity\">on GitHub</a>.</p>\n<p>By default, JavaScript isn’t reactive. This means that if we create the variable <code>boy</code> and reference it in part A of our application, then proceed to modify <code>boy</code> in part B, part A will not update with the new value of <code>boy</code>.</p>\n<pre><code>let framework = 'Vue';\nlet sentence = `${framework} is awesome`;\nconsole.log(sentence)\n // logs \"Vue is awesome\"\nframework = 'React';\nconsole.log(sentence)\n//should log \"React is awesome\" if 'sentence' is reactive.</code></pre>\n\n<p>The snippet above is a perfect example of the non-reactive nature of JavaScript — hence, why the change isn’t reflected in the <code>sentence</code> variable.</p>\n<p>In Vue 2.x, <code>props</code>, <code>computed</code>, and <code>data()</code> were all reactive by default, with the exception of properties that are not present in <code>data</code> when such components are created. This means that when a component is injected into the <a href=\"https://en.wikipedia.org/wiki/Document_Object_Model\">DOM</a>, only the <a href=\"https://vuejs.org/v2/guide/instance.html#Data-and-Methods\">existing properties in the component</a>’s <a href=\"https://vuejs.org/v2/guide/instance.html#Data-and-Methods\"><code>data</code></a> object would cause the component to update if and when such properties change. Internally, Vue 3 uses the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"><code>Proxy</code> object</a> (an ECMAScript 6 feature) to ensure that these properties are reactive, but it still provides the option to use <code>Object.defineProperty</code> from <a href=\"https://vuejs.org/v2/guide/reactivity.html#How-Changes-Are-Tracked\">Vue 2</a> for Internet Explorer support (ECMAScript 5). This method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.</p>\n<p>At first glance and since most of us already know that reactivity is not new in Vue, it might seem unnecessary to make use of these properties, but the Options API has its limitations when you’re dealing with a large application with reusable functions in several parts of the application. To this end, the new <a href=\"https://v3.vuejs.org/guide/composition-api-introduction.html\">Composition API</a> was introduced to help with abstracting logic in order to make a code base easier to read and maintain. Also, we can now easily make any variable reactive regardless of its <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">data type</a> using any of the new properties and methods. When we use the <code>setup</code> option, which serves as the entry point for the Composition API, the <code>data</code> object, <code>computed</code> properties, and <code>methods</code> are inaccessible because the component instance has not yet been created when <code>setup</code> is executed. This makes it impossible to take advantage of the built-in reactivity in any of these features in <code>setup</code>. In this tutorial, we’re going to learn about all of the ways we can do this.</p>\n<h3>The Reactive Method</h3>\n<p>According to the documentation, the <code>reactive</code> method, which is the equivalent of <code>Vue.observable()</code> in Vue 2.6, can be useful when we’re trying to create an object all of whose properties are reactive (such as the <code>data</code> object in the Options API). Under the hood, the <code>data</code> object in the Options API uses this method to make all of the properties in it reactive. But we can create our own reactive object like this:</p>\n<div>\n<pre><code>import { reactive } from 'vue'\n\n// reactive state\nlet user = reactive({\n        \"id\": 1,\n        \"name\": \"Leanne Graham\",\n        \"username\": \"Bret\",\n        \"email\": \"<a href=\"mailto:Sincere@april.biz\">Sincere@april.biz</a>\",\n        \"address\": {\n            \"street\": \"Kulas Light\",\n            \"suite\": \"Apt. 556\",\n            \"city\": \"Gwenborough\",\n            \"zipcode\": \"92998-3874\",\n            \"geo\": {\n                \"lat\": \"-37.3159\",\n                \"lng\": \"81.1496\"\n            }\n        },\n        \"phone\": \"1-770-736-8031 x56442\",\n        \"website\": \"hildegard.org\",\n        \"company\": {\n            \"name\": \"Romaguera-Crona\",\n            \"catchPhrase\": \"Multi-layered client-server neural-net\",\n            \"bs\": \"harness real-time e-markets\"\n        },\n        \"cars\": {\n            \"number\": 0\n        }\n    })</code></pre>\n</div>\n\n<p>Here, we imported the <code>reactive</code> method from Vue, and then we declared our <code>user</code> variable by passing its value to this function as an argument. In doing so, we’ve made <code>user</code> reactive, and, thus, if we use <code>user</code> in our template and if either the object or a property of this object should change, then this value will get automatically updated in this template.</p>\n<h3><code>ref</code></h3>\n<p>Just as we have a method for making objects reactive, we also need one to make other standalone primitive values (strings, booleans, undefined values, numbers, etc.) and arrays reactive. During development, we would work with these other data types while also needing them to be reactive. The first approach we might think of would be to use <code>reactive</code> and pass in the value of the variable that we want to make reactive.</p>\n<pre><code>import { reactive } from 'vue'\n\nconst state = reactive({\n  users: [],\n});</code></pre>\n\n<p>Because <code>reactive</code> has deep reactive conversion, <code>user</code> as a property would also be reactive, thereby achieving our goal; hence, <code>user</code> would always update anywhere it is used in the template of such an app. But with the <code>ref</code> property, we can make any variable with any data type reactive by passing the value of that variable to <code>ref</code>. This method also works for objects, but it nests the object one level deeper than when the <code>reactive</code> method is used.</p>\n<pre><code>let property = {\n  rooms: '4 rooms',\n  garage: true,\n  swimmingPool: false\n}\nlet reactiveProperty = ref(property)\nconsole.log(reactiveProperty)\n// prints {\n// value: {rooms: \"4 rooms\", garage: true, swimmingPool: false}\n// }</code></pre>\n\n<p>Under the hood, <code>ref</code> takes this argument passed to it and converts it into an object with a key of <code>value</code>. This means, we can access our variable by calling <code>variable.value</code>, and we can also modify its value by calling it in the same way.</p>\n<pre><code>import {ref} from 'vue'\nlet age = ref(1)\n\nconsole.log(age.value)\n//prints 1\nage.value++\nconsole.log(age.value)\n//prints 2</code></pre>\n\n<p>With this, we can import <code>ref</code> into our component and create a reactive variable:</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"home\"&gt;\n    &lt;form @click.prevent=\"\"&gt;\n      &lt;table&gt;\n        &lt;tr&gt;\n          &lt;th&gt;Name&lt;/th&gt;\n          &lt;th&gt;Username&lt;/th&gt;\n          &lt;th&gt;email&lt;/th&gt;\n          &lt;th&gt;Edit Cars&lt;/th&gt;\n          &lt;th&gt;Cars&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr v-for=\"user in users\" :key=\"user.id\"&gt;\n          &lt;td&gt;{{ user.name }}&lt;/td&gt;\n          &lt;td&gt;{{ user.username }}&lt;/td&gt;\n          &lt;td&gt;{{ user.email }}&lt;/td&gt;\n          &lt;td&gt;\n            &lt;input\n              type=\"number\"\n              style=\"width: 20px;\"\n              name=\"cars\"\n              id=\"cars\"\n              v-model.number=\"user.cars.number\"\n            /&gt;\n          &lt;/td&gt;\n          &lt;td&gt;\n            &lt;cars-number :cars=\"user.cars\" /&gt;\n          &lt;/td&gt;\n        &lt;/tr&gt;\n      &lt;/table&gt;\n      &lt;p&gt;Total number of cars: {{ getTotalCars }}&lt;/p&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  // @ is an alias to /src\n  import carsNumber from \"@/components/cars-number.vue\";\n  import axios from \"axios\";\n  import { ref } from \"vue\";\n  export default {\n    name: \"Home\",\n    data() {\n      return {};\n    },\n    setup() {\n      let users = ref([]);\n      const getUsers = async () =&gt; {\n        let { data } = await axios({\n          url: \"data.json\",\n        });\n        users.value = data;\n      };\n      return {\n        users,\n        getUsers,\n      };\n    },\n    components: {\n      carsNumber,\n    },\n    created() {\n      this.getUsers();\n    },\n    computed: {\n      getTotalCars() {\n        let users = this.users;\n        let totalCars = users.reduce(function(sum, elem) {\n          return sum + elem.cars.number;\n        }, 0);\n        return totalCars;\n    },\n  };\n&lt;/script&gt;</code></pre>\n\n<p>Here, we imported <code>ref</code> in order to create a reactive <code>users</code> variable in our component. We then imported <code>axios</code> to fetch data from a JSON file in the <code>public</code> folder, and we imported our <code>carsNumber</code> component, which we’ll be creating later on. The next thing we did was create a reactive <code>users</code> variable using the <code>ref</code> method, so that <code>users</code> can update whenever the response from our JSON file changes. We also created a <code>getUser</code> function that fetches the <code>users</code> array from our JSON file using <a href=\"https://github.com/axios/axios\">axios</a>, and we assigned the value from this request to the <code>users</code> variable. Finally, we created a computed property that computes the total number of cars that our users have as we have modified it in the template section. It is important to note that when accessing <code>ref</code> properties that are returned in the template section or outside of <code>setup()</code>, they are <a href=\"https://v3.vuejs.org/guide/reactivity-fundamentals.html#ref-unwrapping\">automatically shallow unwrapped</a>. This means that <code>refs</code> that are an object would still require a <code>.value</code> in order to be accessed. Because <code>users</code> is an array, we could simply use <code>users</code> and not <code>users.value</code> in <code>getTotalCars</code>.</p>\n<p>In the template section, we displayed a table that displays each user’s information, together with a <code>&lt;cars-number /&gt;</code> component. This component accepts a <code>cars</code> prop that is displayed in each user’s row as the number of cars they have. This value updates whenever the value of <code>cars</code> changes in the user object, which is exactly how the <code>data</code> object or <code>computed</code> property would work if we were working with the Options API.</p>\n<h3><code>toRefs</code></h3>\n<p>When we use the Composition API, the <code>setup</code> function accepts two arguments: <code>props</code> and <code>context</code>. This <code>props</code> is passed from the component to <code>setup()</code>, and it makes it possible to access the props that the component has from inside this new API. This method is particularly useful because it allows for the destructuring of objects without losing its reactivity.</p>\n<pre><code>&lt;template&gt;\n  &lt;p&gt;{{ cars.number }}&lt;/p&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    props: {\n      cars: {\n        type: Object,\n        required: true,\n      },\n      gender: {\n        type: String,\n        required: true,\n      },\n    },\n    setup(props) {\n      console.log(props);\n   // prints {gender: \"female\", cars: Proxy}\n    },\n  };\n&lt;/script&gt;\n&lt;style&gt;&lt;/style&gt;</code></pre>\n\n<p>To use a value that is an object from <code>props</code> in the Composition API while ensuring it maintains its reactivity, we make use of <code>toRefs</code>. This method takes a reactive object and converts it into a plain object in which each property of the original reactive object becomes a <code>ref</code>. What this means is that the <code>cars</code> prop…</p>\n<pre><code>cars: {\n  number: 0\n}</code></pre>\n\n<p>… would now become this:</p>\n<pre><code>{\n  value: cars: {\n    number: 0\n  }</code></pre>\n\n<p>With this, we can make use of <code>cars</code> inside any part of the setup API while still maintaining its reactivity.</p>\n<pre><code> setup(props) {\n      let { cars } = toRefs(props);\n      console.log(cars.value);\n      // prints {number: 0}\n    },</code></pre>\n\n<p>We can watch this new variable using the Composition API’s <code>watch</code> and react to this change however we might want to.</p>\n<pre><code>setup(props) {\n      let { cars } = toRefs(props);\n      watch(\n        () =&gt; cars,\n        (cars, prevCars) =&gt; {\n          console.log(\"deep \", cars.value, prevCars.value);\n        },\n        { deep: true }\n      );\n    }</code></pre>\n\n\n\n<h3><code>toRef</code></h3>\n<p>Another common use case we could be faced with is passing a value that is not necessarily an object but rather one of the data types that work with <code>ref</code> (array, number, string, boolean, etc.). With <code>toRef</code>, we can create a reactive property (i.e. <code>ref</code>) from a source reactive object. Doing this would ensure that the property remains reactive and would update whenever the parent source changes.</p>\n<pre><code>const cars = reactive({\n  Toyota: 1,\n  Honda: 0\n})\n\nconst NumberOfHondas = toRef(state, 'Honda')\n\nNumberOfHondas.value++\nconsole.log(state.Honda) // 1\n\nstate.Honda++\nconsole.log(NumberOfHondas.value) // 2</code></pre>\n\n<p>Here, we created a reactive object using the <code>reactive</code> method, with the properties <code>Toyota</code> and <code>Honda</code>. We also made use of <code>toRef</code> to create a reactive variable out of <code>Honda</code>. From the example above, we can see that when we update <code>Honda</code> using either the reactive <code>cars</code> object or <code>NumberOfHondas</code>, the value gets updated in both instances.</p>\n<p>This method is similar and yet so different from the <code>toRefs</code> method that we covered above in the sense that it maintains its connection to its source and can be used for strings, arrays, and numbers. Unlike with <code>toRefs</code>, we do not need to worry about the existence of the property in its source at the time of creation, because if this property does not exist at the time that this <code>ref</code> is created and instead returns <code>null</code>, it would still be stored as a valid property, with a form of <a href=\"https://v3.vuejs.org/guide/reactivity-computed-watchers.html#watch\"><code>watcher</code></a> put in place, so that when this value changes, this <code>ref</code> created using <code>toRef</code> would also be updated.</p>\n<p>We can also use this method to create a reactive property from <code>props</code>. That would look like this:</p>\n<pre><code>&lt;template&gt;\n  &lt;p&gt;{{ cars.number }}&lt;/p&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  import { watch, toRefs, toRef } from \"vue\";\n  export default {\n    props: {\n      cars: {\n        type: Object,\n        required: true,\n      },\n      gender: {\n        type: String,\n        required: true,\n      },\n    },\n    setup(props) {\n      let { cars } = toRefs(props);\n      let gender = toRef(props, \"gender\");\n      console.log(gender.value);\n      watch(\n        () =&gt; cars,\n        (cars, prevCars) =&gt; {\n          console.log(\"deep \", cars.value, prevCars.value);\n        },\n        { deep: true }\n      );\n    },\n  };\n&lt;/script&gt;</code></pre>\n\n<p>Here, we created a <code>ref</code> that would be based on the <code>gender</code> property gotten from <code>props</code>. This comes in handy when we want to perform extra operations on the prop of a particular component.</p>\n<h3>Conclusion</h3>\n<p>In this article, we have looked at how reactivity in Vue works using some of the newly introduced methods and functions from Vue 3. We started by looking at what reactivity is and how Vue makes use of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"><code>Proxy</code> object</a> behind the scenes to achieve this. We also looked at how we can create reactive objects using <code>reactive</code> and how to create reactive properties using <code>ref</code>. Finally, we looked at how to convert reactive objects to plain objects, each of whose properties are a <a href=\"https://v3.vuejs.org/api/refs-api.html#ref\"><code>ref</code></a> pointing to the corresponding property of the original object, and we saw how to create a <a href=\"https://v3.vuejs.org/api/refs-api.html#ref\"><code>ref</code></a> for a property on a reactive source object.</p>\n<h4>Resources</h4>\n<ul>\n<li>“<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>” (object), MDN Web Docs</li>\n<li>“<a href=\"https://v3.vuejs.org/guide/reactivity-fundamentals.html#ref-unwrapping\">Reactivity Fundamentals</a>”, Vue.js</li>\n<li>“<a href=\"https://v3.vuejs.org/api/refs-api.html#refs\">Refs</a>”, Vue.js</li>\n<li>“<a href=\"https://v3.vuejs.org/guide/composition-api-introduction.html#lifecycle-hook-registration-inside-setup\">Lifecycle Hook Registration Inside <code>setup</code></a>”, Vue.js</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"943381ec5c26fa677418fc8e0c2434da77cce812efed65824534f69ea77989cf","category":"Tech"}