{"title":"Getting Started With The GetX Package In Flutter Applications","link":"https://smashingmagazine.com/2021/01/getx-package-flutter-applications/","date":1610107213000,"content":"<p>Flutter is one of the fastest ways to build truly cross-platform native applications. It provides features allowing the developer to build a truly beautiful UI experience for their users.</p>\n<p>However, most times to achieve things like navigating to screens, state management, and show alerts, a lot of boilerplates are needed. These boilerplates tend to slow down the development efficiency of developers trying to go about building features and meeting their deadlines.</p>\n<p>Take for example the boilerplate needed to navigate to a screen in a Flutter application. Let’s say you want to navigate to a screen called <code>AboutScreen</code>. you will have to write:</p>\n<pre><code>Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) =&gt; AboutScreen()),\n  );</code></pre>\n\n<p>It would be more efficient and developer-friendly to do something like:</p>\n<pre><code>Get.to(AboutScreen());</code></pre>\n\n<p>When you need to navigate back to the previous page in Flutter you will have to write:</p>\n<pre><code>Navigator.pop(context);</code></pre>\n\n<p>You will notice we are always depending on <a href=\"https://api.flutter.dev/flutter/widgets/State/context.html\">context property</a> for something as commonplace as navigating between screens. What if instead, we can do something like this:</p>\n<pre><code>Get.back();</code></pre>\n\n<p>The above examples are some of the ways where application development in Flutter can be improved to be more intuitive and efficient with less boilerplate. If you favor simplicity and being efficient in building out features and ideas, in Flutter then the Get package will interest you.</p>\n<h3>What Is GetX</h3>\n<p><a href=\"https://pub.dev/packages/get\">Get or GetX</a> is a fast, stable, extra-light framework for building Flutter applications. </p>\n<p>GetX ships out of the box with high-performance state management, intelligent dependency injection, and route management in a simplistic and practical way.</p>\n<p>GetX aims to minimize boilerplates while also providing simple and intuitive syntax for developers to use while building their applications. At the core of GetX are these 3 principles:</p>\n<ul>\n<li><strong>Performance</strong><br />GetX focuses on the performance of your application by implementing its features to consume as little resources as possible.</li>\n<li><strong>Productivity</strong><br />GetX wants developers to use its features to be productive as quickly as possible. It does so by employing easy to remember syntax and practices. For example, generally, the developer should be concerned to remove controllers from memory but GetX out of the box provides smart management that monitors controllers in your application and remove them when they are not being used by default.</li>\n<li><strong>Organization</strong><br />GetX allows the decoupling of the View, presentation logic, business logic, dependency injection, and navigation in your Flutter application. You do not need context to navigate between routes, so you are not dependent on the widget tree for navigation. You don’t need context to access your controllers/blocs through an <a href=\"https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html\"><code>inheritedWidget</code></a>, so you can completely decouple your presentation logic and business logic from your view layer. You do not need to inject your Controllers/Models/Blocs classes into your widget tree through multiproviders, for this GetX uses its own dependency injection feature, decoupling the DI from its view completely.</li>\n</ul>\n<h3>Features Of GetX</h3>\n<p>GetX comes with a couple of features you will need in your daily app development in Flutter. Let’s look at them:</p>\n<h4>State Management</h4>\n<p>One of the flagship features of GetX is its intuitive state management feature. State management in GetX can be achieved with little or no boilerplate.</p>\n<h4>Route Management</h4>\n<p>GetX provides API for navigating within the Flutter application. This API is simple and with less code needed.</p>\n<h4>Dependency Management</h4>\n<p>GetX provides a smart way to manage dependencies in your Flutter application like the view controllers. GetX will remove any controller not being used at the moment from memory. This was a task you as the developer will have to do manually but GetX does that for you automatically out of the box.</p>\n<h4>Internationalization</h4>\n<p>GetX provides i18n out of the box allowing you to write applications with various language support.</p>\n<h4>Validation</h4>\n<p>GetX provides validation methods for performing input validation in your Flutter applications. This is quite convenient as you wouldn’t need to install a separate validation package.</p>\n<h4>Storage</h4>\n<p>GetX provides a fast, extra light, and synchronous key-value in memory, which backs up data to disk at each operation. It is written entirely in Dart and easily integrates with the core GetX package.</p>\n<h3>Getting Started With GetX</h3>\n<p>Now that you have seen what GetX is and the features and benefits it provides, let’s see how to set it up in your application. We will build a demo app to see most of the features we have mentioned in action. Let’s get started.</p>\n<h4>Create A Brand New Flutter Application</h4>\n<p>We will get started by creating a brand new Flutter application through the Flutter CLI. I am assuming your machine is already set up for application development with Flutter. So we run:</p>\n<pre><code>flutter create getx_demo</code></pre>\n\n<p>This will generate the basic code needed for a Flutter application. Next, open up the project you just created in your editor of choice (We will be using VS Code for this article). We will then run the project to make sure it’s working alright (Make sure you have either a device connected or an emulator/simulator running).</p>\n<p>When the application runs, you will see the default counter application that Flutter scaffold for you when you create a new Flutter application. What we are going to do is to implement the very same counter application but with GetX to manage the state of the app (which is the count variable).</p>\n<p>We will start with clearing <code>main.dart</code> and leaving only this snippet of code:</p>\n<pre><code># main.dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        visualDensity: VisualDensity.adaptivePlatformDensity,\n      ),\n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n</code></pre>\n\n<p>By now our application would have been broken since there is no <code>MyHomePage</code> widget anymore. Let’s fix that. With GetX, we don’t need stateful widgets and also our UI can be clearly separated from our business logic. So we will create two directories inside <code>lib/</code>. These directories are:</p>\n<table>\n  <tbody>\n    <tr>\n      <td><code>views/</code></td>\n      <td>To hold the screens in our application.</td>\n    </tr>\n    <tr>\n      <td><code>controllers/</code></td>\n      <td>To hold all controllers for the screens in our application.</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Let’s create <code>MyHomePage</code> widget inside <code>views/</code>. The name of the file will be <code>my_home_page.dart</code>. After you create it, add the following code snippet to it:</p>\n<pre><code>import 'package:flutter/material.dart';\n\nclass MyHomePage extends StatelessWidget {\n  final String title;\n\n  MyHomePage({this.title});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '0',\n              style: Theme.of(context).textTheme.headline4,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: null,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n</code></pre>\n\n<p>Now we have the <code>MyHomePage</code> widget, let’s import it in <code>main.dart</code>. Add the import statement to the top of main.dart below <code>import 'package:flutter/material.dart';</code></p>\n<pre><code>import './views/my_home_page.dart';</code></pre>    \n\n<p>Now your <code>main.dart</code> file should look like this:</p>\n<pre><code>import 'package:flutter/material.dart';\nimport './views/my_home_page.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        visualDensity: VisualDensity.adaptivePlatformDensity,\n      ),\n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n</code></pre>\n\n<p>When you save your application now, all errors should have been fixed and the app will run. But you will notice when you click the button again, the counter won’t be updated. If you look at the <code>views/my_home_page.dart</code> code, you will see we are just hard coding <code>0</code> as the value of the Text widget and passing <code>null</code> to the <code>onPressed</code> handler of the button. Let’s bring in GetX to the mix to get the application functional again.</p>\n<h4>Installing GetX</h4>\n<p>Head over to the <a href=\"https://pub.dev/packages/get/install\">install page</a> for GetX on pub.dev and you will see the line of code to copy to place in your <code>pubspec.yml</code> file to install GetX. As of the time of writing this article, the current version of GetX is 3.23.1. So we will copy the line:</p>\n<pre><code>get: ^3.23.1</code></pre>\n\n<p>And then paste it under the <code>dependencies</code> section of our <code>pubspec.yml</code> file. When you save the file, get should be automatically installed for you. Or you can run manually in your terminal.</p>\n<pre><code>flutter pub get</code></pre>\n\n<p>The dependencies section of your <code>pubspec.yml</code> file should look like this:</p>\n<pre><code>dependencies:\n  flutter:\n    sdk: flutter\n  get: ^3.23.1</code></pre>\n\n<h4><code>GetxController</code></h4>\n<p>We have mentioned that GetX allows you to separate the UI of your application from the logic. It does this by providing a <code>GetxController</code> class which you can inherit to create controller classes for the views of your application. For our current app, we have one view so we will create a controller for that view. Head over to the <code>controllers/</code> directory and create a file called <code>my_home_page_controller.dart</code>. This will hold the controller for the <code>MyHomePage</code> view.</p>\n<p>After you’ve created the file, first import the GetX package by adding this to the top of the file:</p>\n<pre><code>import 'package:get/get.dart';</code></pre>\n\n<p>Then you will create a class called <code>MyHomePageController</code> inside it and extend the <code>GetxController</code> class. This is how the file should look like:</p>\n<pre><code>import 'package:get/get.dart';\n\nclass MyHomePageController extends GetxController {}\n</code></pre>\n\n<p>let’s add the count state to the class we’ve created.</p>\n<pre><code>final count = 0;</code></pre>\n\n<p>In GetX, to make a variable observable — this means that when it changes, other parts of our application depending on it will be notified. To do this we simply need to add <code>.obs</code> to the variable initialization. So for our above <code>count</code> variable, we will add <code>.obs</code> to <code>0</code>. So the above declaration will now look like this:</p>\n<pre><code>final count = 0.obs;</code></pre>\n\n<p>This is how our controller file looks like at the moment:</p>\n<pre><code>import 'package:get/get.dart';\n\nclass MyHomePageController extends GetxController {\n  final count = 0.obs;\n}\n</code></pre>\n\n<p>To wrap things up with the <code>MyHomePageController</code> we will implement the <code>increment</code> method. This is the snippet to do that:</p>\n<pre><code>increment() =&gt; count.value++;</code></pre>\n\n<p>You will notice we needed to add <code>.value</code> to the count variable to increment it. We did this because adding <code>.obs</code> to a variable makes it an observable variable and to get the value of an observable variable, you do so from the <code>value</code> property.</p>\n<p>So we are done with the controller. Now when the value of count changes, any part of our application using it will be updated automatically.</p>\n<p>We will now head over to our view and let it know about the controller we just created. We will do so by instantiating the controller class using GetX dependency management feature. This will ensure that our controller won’t be in memory when it is no longer needed.</p>\n<p>In <code>views/my_home_page.dart</code> import the Get package and also the controller you created like so:</p>\n<pre><code>import 'package:get/get.dart';\nimport '../controllers/my_home_page_controller.dart';</code></pre>\n\n<p>Then inside the <code>MyHomePage</code> class we will instantiate the <code>MyHomePageController</code>:</p>\n<div>\n<pre><code>final MyHomePageController controller = Get.put(MyHomePageController());</code></pre>\n</div>\n\n<p>Now we have an instance of the <code>MyHomePageController</code>, we can use the state variable as well as the method. So starting with the state, in GetX to mark a part of your UI to be rebuilt when a state variable changes, you will wrap that part with the <code>Obx</code> widget. GetX provides other ways of doing this, but this method is much simpler and cleaner. </p>\n<p>For our count application we want the Text widget to be updated with the current count. So we will wrap the Text widget with <code>Obx</code> widget like so:</p>\n<pre><code>Obx(() =&gt; Text('0',style: Theme.of(context).textTheme.headline4,),)</code></pre>\n\n<p>Next, we will replace the static string <code>0</code> with the count variable from the <code>MyHomePageController</code> like so:</p>\n<pre><code>Obx(() =&gt; Text('${controller.count.value}',\n,style: Theme.of(context).textTheme.headline4,),)</code></pre>\n\n<p>Lastly, we will call the increment method when the <code>floatingActionButton</code> is pressed like so:</p>\n<pre><code>floatingActionButton: FloatingActionButton(\n        onPressed: controller.increment,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),</code></pre>\n\n<p>So overall, our <code>MyHomePage</code> view file should now look like this:</p>\n<div>\n<pre><code>import 'package:flutter/material.dart';\nimport 'package:get/get.dart';\nimport '../controllers/my_home_page_controller.dart';\n\nclass MyHomePage extends StatelessWidget {\n  final String title;\n  final MyHomePageController controller = Get.put(MyHomePageController());\n  MyHomePage({this.title});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Obx(\n              () =&gt; Text(\n                '${controller.count.value}',\n                style: Theme.of(context).textTheme.headline4,\n              ),\n            )\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: controller.increment,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n</code></pre>\n</div>\n\n<p>When you save your application or you rerun it, the counter app should be working as it did when we first created the application.</p>\n<p>I believe you have seen how intuitive state management is with GetX, we didn’t have to write a lot of boilerplate and this simplicity will be more obvious as your application get complex. You will also notice our view doesn’t hold or maintain any state so it can be a stateless widget. The brain of the view in turn is now a controller class that will hold the state for the view and methods.</p>\n<h3>Navigation In GetX</h3>\n<p>We have seen state management in GetX. Let’s now look at how GetX supports Navigation within your application. To activate the Navigation feature of GetX, you only need to make one change in <code>main.dart</code> which is to turn the <code>MaterialApp</code> widget to a <code>GetMaterialApp</code> widget. Let’s do that by first importing Get in the top of <code>main.dart</code></p>\n<pre><code>import 'package:get/get.dart';</code></pre>\n\n<p>Then we make the change to <code>MaterialApp</code> so our <code>main.dart</code> file now look like this:</p>\n<pre><code>import 'package:flutter/material.dart';\nimport 'package:get/get.dart';\nimport './views/my_home_page.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return GetMaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        visualDensity: VisualDensity.adaptivePlatformDensity,\n      ),\n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n</code></pre>\n\n<p>Now our app has been set up to support GetX navigation. To test this out we will create another view in <code>views/</code> directory. We will call this on <code>about_page.dart</code> and it will contain the following code:</p>\n<div>\n<pre><code>import 'package:flutter/material.dart';\nimport 'package:get/get.dart';\nimport '../controllers/my_home_page_controller.dart';\n\nclass AboutPage extends StatelessWidget {\n  final MyHomePageController controller = Get.put(MyHomePageController());\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('About GetX'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Text(\n                'GetX is an extra-light and powerful solution for Flutter. It combines high performance state management, intelligent dependency injection, and route management in a quick and practical way.',\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n</div>\n\n<p>We will then go over to <code>MyHomePage</code> and add a button that when pressed will navigate us to the <code>AboutPage</code>. Like so. The button should be below the Obx widget. Here it is:</p>\n<pre><code> FlatButton(onPressed: () {}, child: Text('About GetX'))</code></pre>\n\n<p>We will also need to import the <code>AboutPage</code> on top of the <code>MyHomePage</code> file:</p>\n<pre><code>import './about_page.dart';</code></pre>\n\n<p>To tell GetX to navigate to the <code>AboutPage</code> all we need is one line of code which is:</p>\n<pre><code>Get.to(AboutPage());</code></pre>\n\n<p>Let’s add that to the <code>onPressed</code> callback of the <code>FlatButton</code> widget like so:</p>\n<pre><code> FlatButton(\n\n    onPressed: () {\n       Get.to(AboutPage());\n              },\n  child: Text('About GetX'))</code></pre>\n\n<p>When you save your application now, you will now be able to navigate to the <code>AboutPage</code>.</p>\n<p>You can also choose to replace the <code>MyHomePage</code> view with the <code>AboutPage</code> so the user won’t be able to navigate back to the previous page by hitting the device back button. This is useful for screens like login screens. To do this, replace the content of the <code>onPressed</code> handler with the below code:</p>\n<pre><code>  Get.off(AboutPage());</code></pre>\n\n<p>This will pop the <code>MyHomePage</code> view and replace it with <code>AboutPage</code>.</p>\n<p>Now that we can navigate to the <code>AboutPage</code>, I think it won’t be so bad to be able to go back to <code>MyHomePage</code> to do this we will add a button in <code>AboutPage</code> after the Padding widget and in it’s <code>onPressed</code> handler we will make a call to <code>Get.back()</code> to navigate back to the <code>MyHomePage</code>:</p>\n<pre><code> FlatButton(\n    onPressed: () {\n        Get.back();\n    },\n    child: Text('Go Home')\n)</code></pre>\n\n\n\n<h3>Snackbar</h3>\n<p>In Flutter conventionally to show a Snackbar, you will need to write something like this:</p>\n<pre><code>final snackBar = SnackBar(content: Text('Yay! A SnackBar!'));\n// Find the Scaffold in the widget tree and use it to show a SnackBar.\nScaffold.of(context).showSnackBar(snackBar);</code></pre>\n\n<p>You can observe we are still depending on the <code>context</code> property. Let’s see how we can achieve this in GetX. Go into the <code>MyHomePage</code> view and add another <code>FlatButton</code> widget below the last button we added. Here is the snippet for the button:</p>\n<pre><code> FlatButton(\n      onPressed: () {\n         // TODO: Implement Snackbar\n       },\n      child: Text('Show Snackbar'))</code></pre>\n\n<p>Let’s display the message ‘Yay! Awesome GetX Snackbar’. Inside the onPressed handler function add the below line of code:</p>\n<pre><code> Get.snackbar('GetX Snackbar', 'Yay! Awesome GetX Snackbar');</code></pre>\n\n<p>Run your application and when you click on the “Show Snackbar button” you will see a snackbar on top of your application!</p>\n<p>See how we reduced the number of lines needed to show a snackbar in a Flutter application? Let’s do some more customization on the Snackbar; Let’s make it appear at the bottom of the app. Change the code to this:</p>\n<div>\n<pre><code>Get.snackbar('GetX Snackbar', 'Yay! Awesome GetX Snackbar',snackPosition:SnackPosition.BOTTOM,\n);</code></pre>\n</div>\n\n<p>Save and run your application and the Snackbar will now appear at the bottom of the application. How about we change the background color of the Snackbar as it is at the moment transparent. We will change it to an <code>amberAccent</code> color from the <code>Colors</code> class in Flutter. Update the code to this:</p>\n<div>\n<pre><code>Get.snackbar('GetX Snackbar', 'Yay! Awesome GetX Snackbar',snackPosition:SnackPosition.BOTTOM, backgroundColor: Colors.amberAccent\n);</code></pre>\n</div>\n\n<p>Overall, the button code should look like this:</p>\n<div>\n<pre><code> FlatButton(\n                onPressed: () {\n                  Get.snackbar('GetX Snackbar', 'Yay! Awesome GetX Snackbar',\n                      snackPosition: SnackPosition.BOTTOM,\n                      backgroundColor: Colors.amberAccent);\n                },\n                child: Text('Show Snackbar'))</code></pre>\n</div>\n\n<h3>Dialog</h3>\n<p>GetX provides a simple method for creating AlertDialog in Flutter. Let’s see it in action. Create another button below the previous one:</p>\n<pre><code> FlatButton(\n                onPressed: () {\n                 // TODO: Show alert dialog\n                },\n                child: Text('Show AlertDialog'))</code></pre>\n\n<p>Let’s call GetX to display an alert Dialog:</p>\n<pre><code>Get.defaultDialog();</code></pre>\n\n<p>That will show a default Alert Dialog that is dismissable by tapping outside the Dialog. You can see how in one line of code we have a working alert dialog. Let’s customize it a bit. Let’s change the title and the message:</p>\n<div>\n<pre><code> Get.defaultDialog(\n                      title: 'GetX Alert', middleText: 'Simple GetX alert');</code></pre>\n</div>\n\n<p>Save and run your app and you will see the changes when you hit the “Show AlertDialog” button. We can add confirm and Cancel buttons like so:</p>\n<pre><code>Get.defaultDialog(\n                      title: 'GetX Alert',\n                      middleText: 'Simple GetX alert',\n                      textConfirm: 'Okay',\n                      confirmTextColor: Colors.amberAccent,\n                      textCancel: 'Cancel');</code></pre>\n\n<p>There are a lot of ways to customize the GetX dialog and the API is quite intuitive and simple.</p>\n<h3>Conclusion</h3>\n<p>GetX was created to improve the productivity of Flutter developers as they build out features. Instead of having to search for boilerplate needed to do things like state management, navigation management, and more, GetX provides a simple intuitive API to achieve these activities without sacrificing performance. This article introduces you to GetX and how to get started using it in your Flutter applications.</p>\n<ul>\n<li>You can find the demo <a href=\"https://github.com/DominusKelvin/getx_demo\">here →</a></li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"dad7eb93abef4c5b250323f187f4560497359d8d3580a1d4c70af7c45a3692ea","category":"Tech"}