{"title":"The Humble `<img>` Element And Core Web Vitals","link":"https://smashingmagazine.com/2021/04/humble-img-element-core-web-vitals/","date":1619698500000,"content":"<p>The humble <code>&lt;img&gt;</code> element has gained some superpowers over the years. Given how central it is to image optimization on the web, let’s catch up on what it can do and how it can help improve user experience and the <a href=\"https://web.dev/vitals/\">Core Web Vitals</a>. I’ll be covering image optimization in more depth in Smashing Magazine’s <a href=\"https://www.smashingmagazine.com/2021/04/image-optimization-pre-release/\">new book on Image Optimization</a>.</p>\n<p>Some tips to get us started:</p>\n<ul>\n<li>For a fast <a href=\"https://web.dev/lcp/\">Largest Contentful Paint</a>:<ul>\n<li>Request your key hero image early.</li>\n<li>Use srcset + efficient modern image formats.</li>\n<li>Avoid wasting pixels (compress, don’t serve overly high DPR images).</li>\n<li>Lazy-load offscreen images (reduce network contention for key resources).</li>\n</ul>\n</li>\n<li>For a low <a href=\"https://web.dev/cls/\">Cumulative Layout Shift</a>:<ul>\n<li>Set dimensions (width, height) on your images.</li>\n<li>Use CSS aspect-ratio or aspect ratio boxes to reserve space otherwise.</li>\n</ul>\n</li>\n<li>For low impact to <a href=\"https://web.dev/fid/\">First Input Delay</a>: <ul>\n<li>Avoid images causing network contention with other critical resources like CSS and JS. While not render-blocking, they can indirectly impact render performance.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note</strong>: <em>Modern image components that build on <code>&lt;img&gt;</code>, like <a href=\"https://nextjs.org/docs/api-reference/next/image\">Next.js <code>&lt;Image&gt;</code></a> (for React) and <a href=\"https://image.nuxtjs.org/\">Nuxt image</a> (for Vue) try to bake in as many of these concepts as possible by default. We’ll cover this later. You can of course also do this manually just using the <code>&lt;img&gt;</code> element directly. If using 11ty for your static sites, try the <a href=\"https://github.com/google/eleventy-high-performance-blog\">11ty high-performance blog template</a>.</em></p>\n<h4>How Do Images Impact User Experience And The Core Web Vitals?</h4>\n<p>You may have heard of Core Web Vitals (CWV). It’s an initiative by Google to share unified guidance for quality signals that can be key to delivering a great user experience on the web. CWV is part of a set of <a href=\"https://developers.google.com/search/blog/2020/11/timing-for-page-experience\">page experience signals</a> Google Search will be evaluating for ranking. Images can impact the CWV in a number of ways.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a7ec5e4a-099e-4a1a-a1a3-b7545835520f/26-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>In many modern web experiences, images tend to be the largest visible element when a page completes loading. These include Hero images, images from carousels, stories and banners. <a href=\"https://web.dev/lcp/\">Largest Contentful Paint</a> (LCP) is a Core Web Vitals metric that measures when the largest contentful element (images, text) in a user’s viewport, such as one of these images, becomes visible.</p>\n<p>This allows a browser to determine when <strong>the main content of the page has finished rendering</strong>. When an image is the largest contentful element, how slowly that image loads can impact LCP. In addition to applying image compression (e.g using <a href=\"https://squoosh.app\">Squoosh</a>, <a href=\"https://sharp.pixelplumbing.com/\">Sharp</a>, <a href=\"https://imageoptim.com/mac\">ImageOptim</a> or an <a href=\"https://web.dev/image-cdns/\">image CDN</a>), and using a modern image format, you can tweak the <code>&lt;img&gt;</code> element to serve the most appropriate responsive version of an image or lazy-load it.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0586dfdb-1e83-485b-92c0-ba38b3df2298/9-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Layout shifts can be distracting to users. Imagine you’ve started reading an article when all of a sudden elements shift around the page, throwing you off and requiring you to find your place again. <a href=\"http://web.dev/cls\">Cumulative Layout Shift</a> (CLS, a Core Web Vitals metric) measures the instability of content. The most common causes of CLS include images without dimensions (see below) which can push down content when they load and snap into place; ignoring them means the browser may not be able to reserve sufficient space in advance of them loading.</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/aaa1694e-29b1-456f-9b17-e8f75bc702ac/22-humble-img-element-and-core-web-vitals.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b68950a7-bcf0-4e38-8447-ec97aee9a3e4/22-humble-img-element-and-core-web-vitals-800w.gif\" /></a>Generated using <a href=\"https://defaced.dev/tools/layout-shift-gif-generator/\">Layout Shift GIF Generator</a>. You may also be interested in the <a href=\"https://webvitals.dev/cls/G1hinueOMKWaKLJFJcQW\">CLS Debugger</a>. (<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/aaa1694e-29b1-456f-9b17-e8f75bc702ac/22-humble-img-element-and-core-web-vitals.gif\">Large preview</a>)\n\n<p>It’s possible for images to block a user’s bandwidth and CPU on page load. They can get in the way of how critical resources are loaded, in particular on slow connections and lower-end mobile devices leading to bandwidth saturation. <a href=\"http://web.dev/fid\">First Input Delay</a> (FID) is a Core Web Vitals metric that captures a user’s first impression of a site’s interactivity and responsiveness. By reducing main-thread CPU usage, FID can also be reduced.</p>\n<h4>Lighthouse</h4>\n<p>In this guide, we will be using Lighthouse to identify opportunities to improve the Core Web Vitals. <a href=\"https://github.com/GoogleChrome/lighthouse\">Lighthouse</a> is an open-source, automated tool for improving the quality of web pages. You can find it in the <a href=\"https://developers.google.com/web/tools/chrome-devtools\">Chrome DevTools</a> suite of debugging tools and run it against any web page, public or requiring authentication. You can also find Lighthouse in <a href=\"https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fstore.google.com\">PageSpeed Insights</a>, <a href=\"https://github.com/GoogleChrome/lighthouse-ci\">CI</a> and <a href=\"https://www.webpagetest.org/easy\">WebPageTest</a>. </p>\n<p>Keep in mind that Lighthouse is a lab tool. While great for looking at opportunities to improve your user experience, always try to consult <a href=\"https://web.dev/vitals-field-measurement-best-practices/\">real-world data</a> for a complete picture of what actual users are seeing.</p>\n<h3>The Basics</h3>\n<p>To place an image on a web page, we use the <code>&lt;img&gt;</code> element. This is an empty element — it has <strong>no closing tag</strong> — requiring a minimum of one attribute to be helpful: <code>src</code>, the source. If an image is called <em>donut.jpg</em> and it exists in the same path as your HTML document, it can be embedded as follows:</p>\n<pre><code>&lt;img src=\"donut.jpg\"&gt;</code></pre>\n\n<p>To ensure our image is accessible, we add the <strong><code>alt</code> attribute</strong>. The value of this attribute should be a textual description of the image, and is used as an alternative to the image when it can’t be displayed or seen; for example, a user accessing your page via a screen reader. The above code with an <code>alt</code> specified looks as follows:</p>\n<pre><code>&lt;img src=\"donut.jpg\"\n     alt=\"A delicious pink donut.\"&gt;</code></pre>\n\n<p>Next, we add <strong><code>width</code> and <code>height</code> attributes</strong> to specify the width and height of the image, otherwise known as the image’s dimensions. The dimensions of an image can usually be found by looking at this information via your operating system’s file explorer (<code>Cmd + I</code> on macOS).</p>\n<pre><code>&lt;img src=\"donut.jpg\"\n     alt=\"A delicious pink donut.\"\n     width=\"400\"\n     height=\"400\"&gt;</code></pre>\n\n<p>When <code>width</code> and <code>height</code> are specified on an image, the browser knows how much space to reserve for the image until it is downloaded. Forgetting to include the image’s dimensions <strong>can cause layout shifts</strong>, as the browser is unsure how much space the image will need.</p>\n<p>Modern browsers now set the default aspect ratio of images based on an image’s <code>width</code> and <code>height</code> attributes, so it’s valuable to set them to prevent such layout shifts.</p>\n<h4>Identify The Largest Contentful Paint Element</h4>\n<p>Lighthouse has a “Largest Contentful Paint element” audit that identifies what element was the largest contentful paint. Hovering over the element will highlight it in the main browser window.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb33b855-689f-4bd2-be04-23d1388ffa7d/8-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>If this element is an image, this information is a useful hint you may want to optimize the loading of this image. You might also find this helpful <a href=\"https://gist.github.com/anniesullie/cf2982342337fd1b2be95c2d5fe5ea06\">LCP Bookmarklet</a> by Annie Sullivan useful for quickly identifying the LCP element with a red rectangle in just one click.  </p>\n<p><strong>Note:</strong> The Largest Contentful Paint element candidate <a href=\"https://web.dev/lcp/\">can change</a> through the page load. For this reason, it’s valuable to not just look at what synthetic tooling like Lighthouse may say, but also consult what <a href=\"https://web.dev/debug-web-vitals-in-the-field/\">real users</a> see.</p>\n<p>Hovering over an image in the Chrome DevTools <em>Elements</em> panel will display the dimensions of the image as well as the image’s intrinsic size.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/44a6b541-9296-44b4-a751-36e196c85bea/11-humble-img-element-and-core-web-vitals.png\" /></p>\n<h4>Identify Layout Shifts From Images Without Dimensions</h4>\n<p>To <a href=\"https://web.dev/optimize-cls/#images-without-dimensions\">limit</a> Cumulative Layout Shift being caused by images without dimensions, include width and height size attributes on your images and video elements. This approach ensures that the browser can allocate the correct amount of space in the document while the image is loading. Lighthouse will highlight images without a width and height:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/99f5d069-f622-4d88-abf7-4ef8c6102135/28-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>See <a href=\"https://www.smashingmagazine.com/2020/03/setting-height-width-images-important-again/\">Setting Height And Width On Images Is Important Again</a> for a good write-up on the importance of thinking about image dimensions and aspect ratio.</p>\n<h3>Responsive Images</h3>\n<p>What about switching image resolution? A standard <code>&lt;img&gt;</code> only allows us to supply a single source file to the browser. But with the <code>srcset</code> and <code>sizes</code> attributes, we can provide many additional source images (and hints) so the browser can pick the most appropriate one. This allows us to supply images that are smaller or larger.</p>\n<pre><code>&lt;img src=\"donut-800w.jpg\"\n     alt=\"A delicious pink donut.\"\n     width=\"400\"\n     height=\"400\"\n     srcset=\"donut-400w.jpg 400w,\n             donut-800w.jpg 800w\"\n     sizes=\"(max-width: 640px) 400px,\n            800px\"&gt;</code></pre>\n\n<p>The <code>srcset</code> attribute defines the set of images the browser can select from, as well as the size of each image. Each image string is separated by a comma and includes:</p>\n<ul>\n<li>a source filename (<code>donut-400w.jpg</code>);</li>\n<li>a space;</li>\n<li>and the image’s intrinsic width specified in pixels (<code>400w</code>), or a pixel density descriptor (<code>1x</code>, <code>1.5x</code>, <code>2x</code>, and so on).</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a4fe95fd-8245-4a33-bc8b-dbe0f0b8ee24/4-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>The <code>sizes</code> attribute specifies a set of conditions, such as screen widths, and what image size is best to select when those conditions are met. Above, (<code>max-width:640px</code>) is a media condition asking “if the viewport width is 640 pixels or less,” and <code>400px</code> is the width of the slot, the image is going to fill when the media condition is true. This typically corresponds to the page’s responsive breakpoints.</p>\n<h4>Device Pixel Ratio (DPR) / Pixel Density Capping</h4>\n<p>Device Pixel Ratio (DPR) represents how a CSS pixel is translated to physical pixels on a hardware screen. <a href=\"https://web.dev/choose-the-right-image-format/#implications-of-high-resolution-screens\">High resolution</a> and retina screens use more physical pixels to represent CSS pixels for imagery that is sharper and has more detailed visuals.</p>\n<p>The human eye may not be capable of distinguishing the difference between images that are a 2x-3x DPR vs. an even higher resolution. Serving overly high DPR images is a common problem for sites leveraging <code>&lt;img srcset&gt;</code> and a suite of image sizes.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6dc5f7c1-4ccb-4ba0-96a2-38ba56c259f8/21-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>It may be possible to use DPR-capping to serve your users an image at a 2x or 3x fidelity to prevent large image payloads. Twitter <a href=\"https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\">capped</a> their image fidelity at 2x, resulting in 33% faster timeline image loading times. They found that 2x was a sweet spot of both good performance wins with no degradation in quality metrics. </p>\n<p><strong>Note:</strong> This approach to DPR-capping is currently not possible if using “w” descriptors.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3ebaff10-259a-46d1-8d34-cb680f3c4a1d/13-humble-img-element-and-core-web-vitals.png\" /></p>\n<h4>Identify Images That Can Be Better Sized</h4>\n<p>Lighthouse includes a number of image optimization audits for helping you understand if your images could be better compressed, delivered in a more optimal modern image format, or resized.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/afc46056-132d-4f08-a512-734f3e567f01/1-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Even those images which are responsive (that is, sized relative to the viewport) should have a width and height set. In modern browsers, these attributes establish an aspect ratio that helps prevent layout shifts, even if the absolute sizes are overridden by CSS. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0126a7a6-c948-4009-a696-aca01ee02452/27-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>When not using an image CDN or framework, I like to use <a href=\"https://responsivebreakpoints.com/\">responsivebreakpoints.com</a> to determine the optimal image breakpoints and generate <code>&lt;img&gt;</code> srcset code for my responsive images.</p>\n<h3>Serving Modern Image Formats</h3>\n<p>Art direction allows us to serve different images depending on a user’s display. While responsive images load different sizes of the same image, art direction can load very different images based on the display.</p>\n<p>The browser can choose which image format to display using the <code>&lt;picture&gt;</code> element. The <code>&lt;picture&gt;</code> element supports multiple <code>&lt;source&gt;</code> elements and a single <code>&lt;img&gt;</code> element, which can reference sources for different formats including AVIF, WebP, and eventually JPEG XL.</p>\n<pre><code>&lt;picture&gt;\n    &lt;source srcset=\"puppy.jxl\" type=\"image/jxl\"&gt;\n    &lt;source srcset=\"puppy.avif\" type=\"image/avif\"&gt;\n    &lt;source srcset=\"puppy.webp\" type=\"image/webp\"&gt;\n    &lt;source srcset=\"puppy.jpg\" type=\"image/jpeg\"&gt;\n    &lt;img src=\"puppy.jpg\" alt=\"Cute puppy\"&gt;\n&lt;/picture&gt;</code></pre>\n\n<p>In this example, the browser will begin to parse the sources and will stop when it has found the first supported match. If no match is found, the browser loads the source specified in <code>&lt;img&gt;</code> as the fallback. This approach works well for serving any modern image format not supported in all browsers. Be careful with <strong>ordering <code>&lt;source&gt;</code> elements</strong> as order matters. Don’t place modern sources after legacy formats, but instead put them before. Browsers that understand it will use them and those that don’t will move onto more widely supported frameworks.</p>\n<p>Understanding the myriad of image format options out there today can be a confusing process, but you may find Cloudinary’s <a href=\"https://cloudinary.com/blog/time_for_next_gen_codecs_to_dethrone_jpeg\">comparison of modern image formats</a> helpful:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bdff6efa-91ba-43a1-84c0-96d309bd64bc/12-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>You may also find Malte Ubl’s <a href=\"https://avif-webp-quality-setting.industrialempathy.com/\">AVIF and WebP quality settings picker</a> useful for selecting quality settings to match the quality of a JPEG at a particular given quality setting. </p>\n<h4>Identify Images That Could Be Served In A More Modern Format</h4>\n<p>Lighthouse (below) highlights potential savings from serving images in a next-generation format. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8241f6e4-85b2-4bb8-9e18-d76e9d9ebe40/6-humble-img-element-and-core-web-vitals.png\" /></p>\n<p><strong>Note:</strong> We have an <a href=\"https://github.com/GoogleChrome/lighthouse/issues/12295\">open issue</a> to better highlight the potential savings for AVIF in Lighthouse.</p>\n<p>You might also find value in using image auditing tools such as <a href=\"https://webspeedtest.cloudinary.com/\">Cloudinary’s image analysis tool</a> for a deeper look at image compression opportunities for all the images on a page. As a bonus, you can download compressed versions of suggested image formats such as WebP:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c887b50b-adaf-4f63-9457-b028efb0282f/10-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>I also enjoy using <a href=\"https://squoosh.app/\">Squoosh</a> for its support of bleeding-edge formats, such as JPEG XL as it offers a low-friction way to experiment with modern formats outside of a CLI or CDN.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d3080fb2-5664-4e34-962f-134dfbb39571/18-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>There are multiple ways to approach sizing issues as both srcset and sizes are both usable on <code>&lt;picture&gt;</code> and <code>&lt;img&gt;</code>. when in doubt, use <code>&lt;img&gt;</code> with srcset/sizes for single images that have a simple layout. Use <code>&lt;picture&gt;</code> for serving multiple formats, complex layout and art direction.</p>\n<p>Chrome DevTools allows you to disable modern image formats (<a href=\"https://twitter.com/addyosmani/status/1327174361942552576?lang=en\">demo</a>), like WebP, AVIF or JPEG XL, to test differing fallbacks for them in the <em>Rendering</em> panel:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cce8a527-1562-40fb-8793-15c3dd4a2a9b/3-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>CanIUse has the latest browser support details for <a href=\"https://caniuse.com/webp\">WebP</a>, <a href=\"https://caniuse.com/avif\">AVIF</a> and <a href=\"https://caniuse.com/jpegxl\">JPEG XL</a>.</p>\n\n<h4>Content Negotiation</h4>\n<p>An alternative to manually handling image format selection using <code>&lt;picture&gt;</code> is to rely on the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept\">accept header</a>. This is sent by the client, allowing the server to deliver an image format that is the best fit for the user. CDNs such as <a href=\"https://www.akamai.com/de/de/products/performance/image-and-video-manager.jsp\">Akamai</a>, <a href=\"https://cloudinary.com/\">Cloudinary</a> and <a href=\"https://support.cloudflare.com/hc/en-us/articles/360000607372-Using-Cloudflare-Polish-to-compress-images\">Cloudflare</a> support it.</p>\n<h3>Image Lazy Loading</h3>\n<p>What about offscreen images that are not visible until a user scrolls down the page? In the example below, all the images on the page are “eagerly loaded” (the default in browsers today), causing the user to download 1.1 MB of images. This can cause users’ data plans to take a hit in addition to affecting performance.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4541861a-1fde-4c81-9bde-158d2e274385/16-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Using the <a href=\"https://web.dev/native-lazy-loading/\">loading attribute</a> on <code>&lt;img&gt;</code>, we can control the behavior of image loading. <code>loading=\"lazy\"</code> lazy-loads images, deferring their loading until they reach a calculated distance from the viewport. <code>loading=\"eager\"</code> loads images right away, regardless of their visibility in the viewport. <code>eager</code> is the default so doesn’t need to be explicitly added (that is, just use <code>&lt;img&gt;</code> for eager loading).</p>\n<p>Below is an example of lazy-loading an <code>&lt;img&gt;</code> with a single source:</p>\n<pre><code>&lt;img src=\"donut.jpg\"\n     alt=\"A delicious pink donut.\"\n     loading=\"lazy\"\n     width=\"400\"\n     height=\"400\"&gt;</code></pre>\n\n<p>With native <code>&lt;img&gt;</code> lazy-loading, the earlier example now downloads only about 90 KB of images! Just adding <code>loading=\"lazy\"</code> to our offscreen images has a huge impact. You ideally want to lazy-load all images present <a href=\"https://web.dev/browser-level-image-lazy-loading/#avoid-lazy-loading-images-that-are-in-the-first-visible-viewport\">outside of the initial viewport</a> and avoid it for everything that is within the initial viewport.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ba1ed82b-e5b9-45a8-b8ba-0bcfaf3a7715/7-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Lazy loading also works with images that include <code>srcset</code>:</p>\n<pre><code>&lt;img src=\"donut-800w.jpg\"\n     alt=\"A delicious donut\"\n     width=\"400\"\n     height=\"400\"\n     srcset=\"donut-400w.jpg 400w,\n             donut-800w.jpg 800w\"\n     sizes=\"(max-width: 640px) 400px,\n            800px\"\n     loading=\"lazy\"&gt;</code></pre>\n\n<p>In addition to working on <code>srcset</code>, the loading attribute also works on <code>&lt;img&gt;</code> inside <code>&lt;picture&gt;</code>:</p>\n<div>\n<pre><code>&lt;!-- Lazy-load images in &lt;picture&gt;. \n&lt;img&gt; is the one driving image loading so &lt;picture&gt; and srcset fall off of that --&gt;\n&lt;picture&gt;\n  &lt;source media=\"(min-width: 40em)\" srcset=\"big.jpg 1x, big-hd.jpg 2x\"&gt;\n  &lt;source srcset=\"small.jpg 1x, small-hd.jpg 2x\"&gt;\n  &lt;img src=\"fallback.jpg\" loading=\"lazy\"&gt;\n&lt;/picture&gt;</code></pre>\n</div>\n\n<p>The Lighthouse Opportunities section lists any offscreen or hidden images on a page that can be lazy-loaded as well as the potential savings from doing so.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68cad1af-a26e-449a-b3ec-cc02708844d0/23-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>See <a href=\"https://caniuse.com/loading-lazy-attr\">CanIUse.com</a> for latest browser support for native image lazy-loading.</p>\n\n<h3>Request Your Image Early</h3>\n<p>Help the browser discover your LCP image early so that it can fetch and render it with minimal delay. Where possible, attempt to solve this by better minimizing the request chains to your LCP image so that the browser doesn’t need to first fetch, parse and execute JavaScript or wait for a component to render/hydrate to discover the image.</p>\n<p><code>&lt;link rel=preload&gt;</code> can be used with <code>&lt;img&gt;</code> to allow browsers to discover critical resources you want to load as soon as possible, prior to them being found in HTML. </p>\n<pre><code>&lt;link rel=\"preload\" as=\"image\" href=\"donut.jpg\"&gt;</code></pre>\n\n<p>If you are optimizing LCP, preload can help boost how soon late-discovered hero images (e.g such as those loaded by JavaScript or background hero images in CSS) are fetched. Preload can make a meaningful difference if you need critical images (like Hero images) to be prioritized over the load of other images on a page. </p>\n<p><strong>Note:</strong> Use preload sparingly and <em>always</em> measure its impact in production. If the preload for your image is earlier in the document than it is, this can help browsers discover it (and order relative to other resources). When used incorrectly, preloading can <em>cause your image to delay</em> <a href=\"http://web.dev/fcp\"><em>First Contentful Paint</em></a> (e.g CSS, Fonts) — the opposite of what you want. Also note that for such reprioritization efforts to be effective, it also <a href=\"https://github.com/andydavies/http2-prioritization-issues#cdns--cloud-hosting-services\">depends on servers prioritizing requests correctly</a>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/351c2652-e0f8-4af8-8476-e187c4b607ba/2-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Preload can be used to fetch sources for an <code>&lt;img&gt;</code> of a particular format:</p>\n<div>\n<pre><code>&lt;link rel=\"preload\" as=\"image\" href=\"donut.webp\" type=\"image/webp\"&gt;</code></pre>\n</div>\n\n<p><strong>Note:</strong> This approach only preloads the latest format where supported, however cannot be used to preload multiple supported formats as this would preload both of them.</p>\n<p><a href=\"https://web.dev/preload-responsive-images/\">Preload can also be used to fetch responsive images</a> so the correct source is discovered sooner:</p>\n<pre><code>&lt;link rel=\"preload\" as=\"image\" \n     href=\"donut.jpg\" \n     imagesrcset=\"\n        poster_400px.jpg 400w, \n        poster_800px.jpg 800w, \n        poster_1600px.jpg 1600w\" \n    imagesizes=\"50vw\"&gt;</code></pre>\n\n<p>Take care not to overuse preload (when each resource is considered important, none of them really are). Reserve it for critical resources which the browser’s preload scanner may not be able to quickly find organically.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f9bac55c-65c7-4d01-883f-68d7faa2fb0e/15-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Lighthouse suggests opportunities to apply this optimization in Lighthouse 6.5 and above. </p>\n<p>See <a href=\"https://caniuse.com/link-rel-preload\">CanIUse.com</a> for latest browser support for link rel=preload.</p>\n<h3>Image Decoding</h3>\n<p>Browsers need to decode the images they download in order to turn them into pixels on your screen. However, how browsers handle deferring images can vary. At the time of writing, Chrome and Safari present images and text together – synchronously – if possible. This looks correct visually, but images have to be decoded, which can mean text isn’t shown until this work is done. The <code>decoding</code> attribute on <code>&lt;img&gt;</code> allows you to signal a preference between synchronous and asynchronous image decoding.</p>\n<pre><code>&lt;img src=\"donut-800w.jpg\"\n     alt=\"A delicious donut\"\n     width=\"400\"\n     height=\"400\"\n     srcset=\"donut-400w.jpg 400w,\n             donut-800w.jpg 800w\"\n     sizes=\"(max-width: 640px) 400px,\n            800px\"\n     loading=\"lazy\"\n     decoding=\"async\"&gt;</code></pre>\n\n<p><code>decoding=\"async\"</code> suggests it’s OK for image decoding to be deferred, meaning the browser can rasterize and display content without images while scheduling an asynchronous decode that is off the critical path. As soon as image decoding is complete, the browser can update the presentation to include images. <code>decoding=sync</code> hints that the decode for an image should not be deferred, and <code>decoding=\"auto\"</code> lets the browser do what it determines is best.</p>\n<p><strong>Note</strong>: <em>See <a href=\"https://caniuse.com/mdn-html_elements_img_decoding\">CanIUse.com</a> for the latest browser support for the decoding attribute.</em></p>\n<h4>Placeholders</h4>\n<p>What if you would like to show the user a placeholder while the image loads? The <code>background-image</code> CSS property allows us to set background images on an element, including the <code>&lt;img&gt;</code> tag or any parent container elements. We can combine <code>background-image</code> with <code>background-size: cover</code> to set the size of an element’s background image and scale the image as large as possible without stretching the image.</p>\n<p>Placeholders are often inline, Base64-encoded data URLs which are low-quality image placeholders (LQIP) or SVG image placeholders (SQIP). This allows users to get a very quick preview of the image, even on slow network connections, before the sharper final image loads in to replace it.</p>\n<pre><code>&lt;img src=\"donut-800w.jpg\"\n     alt=\"A delicious donut\"\n     width=\"400\"\n     height=\"400\"\n     srcset=\"donut-400w.jpg 400w,\n             donut-800w.jpg 800w\"\n     sizes=\"(max-width: 640px) 400px,\n            800px\"\n     loading=\"lazy\"\n     decoding=\"async\"\n     style=\"background-size: cover; \n            background-image:\n              url(data:image/svg+xml;base64,[svg text]);\"&gt;</code></pre>\n\n<p><strong>Note:</strong> Given that Base64 data URLs can be quite long, <code>[svg text]</code> is denoted in the example above to improve readability.</p>\n<p>With an inline SVG placeholder, here is how the example from earlier now looks when loaded on a very slow connection. Notice how users are shown a preview right away prior to any full-size images being downloaded:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53961d0b-133f-4141-9a79-aa5c1fc9a37d/29-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>There are a variety of modern solutions for image placeholders (e.g CSS background-color, LQIP, SQIP, <a href=\"https://blurha.sh/\">Blur Hash</a>, Potrace). Which approach makes the most sense for your user experience may depend on how much you’re attempting to offer a preview of the final content, display progress (e.g progressive loading) or just avoid a visual flash when the image finally loads in. I’m personally excited for <a href=\"https://cloudinary.com/blog/time_for_next_gen_codecs_to_dethrone_jpeg\">JPEG XL’s support</a> for full progressive rendering.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b6d56acc-23b9-4140-992f-535397407d56/19-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Ultimately including an inline data URL for your low-quality placeholder image that is served in the initial HTML within the <code>&lt;img&gt;</code>’s styles avoids the need for an additional network request. I’d consider a placeholder size of being &lt;= 1-2KB as being optimal. <a href=\"https://web.dev/lcp/#how-is-an-element's-size-determined\">LCP will take into account the placeholder image’s intrinsic size</a> so ideally aim for the “preview” to match the intrinsic size of the real image being loaded.</p>\n<p><strong>Note:</strong> There is an <a href=\"https://github.com/WICG/largest-contentful-paint/issues/71\">open issue</a> to discuss factoring in progressive loading specifically into the Largest Contentful Paint metric. </p>\n<h3>Lazy-render Offscreen Content</h3>\n<p>Next, let’s discuss the <a href=\"https://web.dev/content-visibility/\">CSS <code>content-visibility</code></a> property, which allows the browser to skip rendering, layout and paint for elements until they are needed. This can help optimize page load performance if a large quantity of your page’s content is offscreen, including content which uses <code>&lt;img&gt;</code> elements. <code>content-visibility:auto</code> can <a href=\"https://www.industrialempathy.com/posts/image-optimizations/#lazy-rendering\">reduce</a> how much CPU work the browser has to do less work upfront, including offscreen image decoding.</p>\n<pre><code>section {\n  content-visibility: auto;\n}</code></pre>\n\n<p>The <code>content-visibility</code> property can take a number of values, however, <code>auto</code> is the one that offers performance benefits. Sections of the page with <code>content-visibility: auto</code> get containment for layout, paint and style containment. Should the element be off-screen, it would also get size containment. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4b998a72-f23c-473c-9c4a-bfac82fade53/31-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Browsers don’t paint the image content for content-visibility affected images, so this approach may introduce some savings. </p>\n<pre><code>section {\n  content-visibility: auto;\n  contain-intrinsic-size: 700px; \n}</code></pre>\n\n<p>You can pair <code>content-visibility</code> with <code>contain-intrinsic-size</code> which provides the natural size of the element if it is impacted by size containment. The <code>700px</code> value in this example approximates the width and height of each chunked section.  </p>\n<p>See <a href=\"https://caniuse.com/css-content-visibility\">CanIUse.com</a> for latest browser support for CSS content-visibility.</p>\n<h3>Next.js Image Component</h3>\n<p>Next.js now includes an <a href=\"https://nextjs.org/docs/api-reference/next/image\">Image component</a> with several of the above best practices baked in. The image component handles image optimization, generating responsive images (automating <code>&lt;img srcset&gt;</code>) and lazy-loading in addition to many other capabilities. This is just one of the optimizations that has come out of the Chrome and Next.js teams <a href=\"https://nextjs.org/blog/next-10#built-in-image-component-and-automatic-image-optimization\">collaborating</a> with sites adopting it seeing up to a 60% better LCP and 100% better CLS.</p>\n<p>In the below Next.js example, the standard <code>&lt;img&gt;</code> element is first used to load 3 donut images downloaded from Unsplash.</p>\n<div>\n<pre><code>import Head from 'next/head';\nexport default function Index() {\n    return (\n        &lt;div&gt;\n            &lt;Head&gt;\n                &lt;title&gt;Create Next App&lt;/title&gt;\n            &lt;/Head&gt;\n\n            &lt;main&gt;\n                &lt;div&gt;\n                    &lt;img src=\"/donut1.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                    &lt;img src=\"/donut2.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                    &lt;img src=\"/donut3.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                &lt;/div&gt;\n            &lt;/main&gt;\n        &lt;/div&gt;\n    );\n}</code></pre>\n</div>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/38c4e66b-2ab3-4327-9577-979744ee7e86/25-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>When this page is loaded with the DevTools network panel open, we see that our images are very large in size (325KB + 4.5MB + 3.6MB = 8.4MB in total), they all load regardless of whether the user can see them and are likely not as optimized as they could be.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9df0857c-602e-4e31-91aa-646287d179a3/14-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>Loading images at these sizes is unnecessary, in particular if our user is on a mobile device. Let’s now use the Next.js image component instead. We import it in from 'next/image' and replace all our <code>&lt;img&gt;</code> references with <code>&lt;Image&gt;</code>. </p>\n<div>\n<pre><code>import Head from 'next/head';\nimport Image from 'next/image';\n\nexport default function Index() {\n    return (\n        &lt;div&gt;\n            &lt;Head&gt;\n                &lt;title&gt;Next.js Image Component&lt;/title&gt;\n            &lt;/Head&gt;\n            &lt;main&gt;\n                &lt;div&gt;\n                    &lt;Image src=\"/donut1.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                    &lt;Image src=\"/donut2.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                    &lt;Image src=\"/donut3.jpeg\" alt=\"Donut\" height={700} width={700} /&gt;\n                &lt;/div&gt;\n            &lt;/main&gt;\n        &lt;/div&gt;\n    );\n}</code></pre>\n</div>\n\n<p>We can reload our page and take a second look at the DevTools network panel. Now only 1 image is being loaded by default (the only one visible in the viewport), it’s significantly smaller than the original (~33KB vs 325KB) and uses a more modern format (WebP).</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7949bff6-332a-447d-a647-441a9bb05e02/20-humble-img-element-and-core-web-vitals.png\" /></p>\n<p><strong>Note:</strong> Next.js will optimize images dynamically upon request and store them in a local cache. The optimized image then gets served for subsequent requests until an expiration is reached.</p>\n<p>Next.js can also generate several versions of the image to serve media to smaller screens at the right size. When loading the page under mobile emulation (a Pixel phone), an even smaller 16KB image gets served for our first image.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/24684a33-bed7-44ab-a87b-11f34803616e/24-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>When a user scrolls down the page, the additional images are lazy-loaded in. Note how no additional configuration or tweaking was needed here — the component just did the right thing by default.</p>\n<a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d2aae589-0b37-422a-8ae0-ef716bc5ef27/30-humble-img-element-and-core-web-vitals.gif\"><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d2aae589-0b37-422a-8ae0-ef716bc5ef27/30-humble-img-element-and-core-web-vitals.gif\" /></a>\n\n<p>The performance optimizations offered by the Next.js image component can help improve Largest Contentful Paint. To learn more about the component, including the different layout modes it supports, check out the <a href=\"https://nextjs.org/docs/api-reference/next/image\">Next.js documentation</a>. A component with similar capabilities is available for <a href=\"https://image.nuxtjs.org/\">Nuxt.js</a>.</p>\n<h4>What Are Examples Of Businesses Improving LCP Via Image Optimizations?</h4>\n<p>Vodafone <a href=\"https://web.dev/vodafone/\">found</a> that a 31% improvement in LCP increased sales by 8%. Their optimizations to improve LCP included resizing their hero image, optimizing SVGs and using media queries to limit loading offscreen images.</p>\n<p>Agrofy <a href=\"https://web.dev/agrofy/\">found</a> that 70% improvement in LCP correlated to a 76% reduction in load abandonment. Their optimizations to LCP included a <a href=\"https://mollar-luciano.medium.com/how-agrofy-optimised-core-web-vitals-and-improved-business-metrics-2f73311bca\">2.5s saving</a> from switching their first large image from being behind JavaScript (client-side hydration) to being directly in the main HTML document.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/56df8cb2-cd85-4ffc-9256-36f191f7eb5f/17-humble-img-element-and-core-web-vitals.png\" /></p>\n<p>French Fashion house <a href=\"https://www.chloe.com/us\">Chloè</a> used Link Preload to preload their 1x and 2x Hero images, which were previously bottlenecked by a render-blocking script. This improved their Largest Contentful Paint by 500ms based on Chrome UX Report data over 28 days.</p>\n<p>Optimizations to Cumulative Layout Shift helped YAHOO! Japan increased its News page views per session by 15%. They determined shifts were caused after their hero images were loaded and snapped in for the first view. They used <a href=\"https://css-tricks.com/aspect-ratio-boxes/\">Aspect Ratio Boxes</a> to reserve space before their image was loaded.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0ab054bc-3d45-4282-8a62-959bb5f1b0b8/5-humble-img-element-and-core-web-vitals.png\" /></p>\n<h3>Lab Data Is Only Part Of The Puzzle. You Also Need Field Data.</h3>\n<p>Before we go, I’d love to share a quick reminder about the importance of looking at the image experience your real users might have. Lab tools like Lighthouse measure performance in a synthetic (emulated mobile) environment limited to page load, while field or <strong>real-world data</strong> (e.g. RUM, <a href=\"https://developers.google.com/web/tools/chrome-user-experience-report/\">Chrome UX Report</a>) are based on real users throughout the lifetime of the page.</p>\n<p>It’s important to <strong>check how realistic your lab results are</strong> by comparing them against typical users in the field. For example, if your lab CLS is much lower than the 75th percentile CLS in the field, you may not be measuring layout shifts as real users are experiencing them.</p>\n<p>CLS is measured during the <strong>full lifespan of a page</strong>, so user behavior (interactions, scrolls, clicks) can have an impact on the elements that are shifting. For images, lab CLS may not see an improvement from fixing missing image dimensions if the images happen to be far down a page requiring a scroll. This is just one place where it’s worthwhile consulting real-user data.</p>\n<p>For LCP it is very possible that the <strong>candidate element can change depending on factors such as load times</strong> (the LCP candidate could initially be a paragraph of text and then a large hero image), personalization or even different screen resolutions. Lighthouse’s LCP audit is a good place to start, but do take a look at what real users see to get the full picture.</p>\n<p>Whenever possible, try to <strong>configure your lab tests</strong> to reflect real-user access and behavior patterns. Philip Walton has an excellent guide on <a href=\"https://web.dev/debug-web-vitals-in-the-field/\">debugging Web Vitals in the field</a> worth checking for more details.</p>\n<h3>Editorial Note: Addy's Book on Image Optimization</h3>\n<p>We’re happy and honored to have teamed up with Addy to publish a dedicated <a href=\"https://www.smashingmagazine.com/2021/04/image-optimization-pre-release/\">book on image optimization</a>, and the book is now finally here. With modern approaches to image compression and image delivery, current and emerging image formats, how browsers load, decode and render images, CDNs, lazy-loading, adaptive media loading and how to optimize for Core Web Vitals. Everything in one, single, 528-pages book. <a href=\"http://provide.smashingmagazine.com/eBooks/image-optimization-sample-chapter.pdf\">Download a free PDF sample</a> (12MB).</p>\n\n    <a href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b41ae541-7618-44f2-81cd-cc681c64d0d0/image-optimization-header.png\">\n    <img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b41ae541-7618-44f2-81cd-cc681c64d0d0/image-optimization-header.png\" />\n    </a>\n\n\n\n\n<p><a href=\"https://www.smashingmagazine.com/printed-books/image-optimization/\">Get the book right away</a> — and thank you for your kind support, everyone! ❤️</p>\n<hr />\n<p>Now that we’ve covered the foundations of the modern <code>&lt;img&gt;</code> tag, check out the <a href=\"https://www.smashingmagazine.com/2021/04/image-optimization-pre-release/\">pre-release of the Image Optimization book</a> to get a deeper understanding of how images can impact performance and UX.</p>\n<p>Throughout the <a href=\"https://www.smashingmagazine.com/printed-books/image-optimization/\">book</a>, we will cover advanced image optimization techniques that expand heavily on the above guidance, as well as how to best use elements like <code>&lt;img&gt;</code> and <code>&lt;picture&gt;</code> to make your images on the web shine.</p>\n<p>You may also be interested in reading Malte Ubl’s guide to <a href=\"https://www.industrialempathy.com/posts/image-optimizations/\">image optimization</a>, Jake Archibald’s guide to the <a href=\"https://jakearchibald.com/2020/avif-has-landed/\">AVIF format</a> and Katie Hempenius’ <a href=\"https://web.dev/authors/katiehempenius/\">excellent</a> guidance on web.dev.</p>\n<p><em>With thanks to Yoav Weiss, Rick Viscomi and Vitaly for their reviews.</em></p>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"048ea7a47d7d3410301e61025080ccf6fb9dcd72a383da313e2dc338794b98cd","category":"Tech"}