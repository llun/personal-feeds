{"title":"Frustrating Design Patterns That Need Fixing: Birthday Picker","link":"https://smashingmagazine.com/2021/05/frustrating-design-patterns-birthday-picker/","date":1620817200000,"content":"<p>You’ve seen them before. Confusing and frustrating design patterns that seem to be chasing you everywhere you go, from one website to another. Perhaps it’s a birthday selector dropdown that always starts in 2021, or a disabled submit button that never communicates what’s actually wrong, or tooltips that — once opened — always cover the input field <em>just</em> when you need to correct a mistake. They are everywhere, and they are annoying, often tossing us from one dead-end to another, in something that seems like a well-orchestrated and poorly designed mousetrap.</p>\n<p>These patterns aren’t malicious nor evil. They don’t have much in common with <a href=\"https://www.smashingmagazine.com/2019/04/privacy-ux-better-cookie-consent-experiences/\">deceptive cookie prompts</a> or mysterious CAPTCHAs in disguise of fire hydrants and crosswalks. They aren’t designed with poor intentions or harm in mind either: nobody wakes up in the morning hoping to increase bounce rates or decrease conversion. It’s just that over the years, some more-or-less random design decisions have become widely accepted and adopted, and hence they are repeated over and over again — often without being questioned or validated by data or usability testing. They’ve become established design patterns. And often quite poor ones. Making their appearance again and again and again every time we speak to users during testing.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/595d0b5d-fe05-4b6f-a048-d609ebbcda03/1-birthday-picker.jpg\" /></p>\n<p>In this series of articles, let’s take a closer look at some of these <strong>frustrating design patterns</strong> and explore <strong>better alternatives</strong>, along with plenty of examples and checklists to keep in mind when building or designing one. These insights are coming from usability tests and user research conducted by yours truly or our colleagues in the community, and of course, they all will be referenced in each of the upcoming posts.</p>\n<p>We’ll start with a humble and seemingly harmless pattern that we all had experienced at some point — the infamous <strong>birthday picker</strong> that happens to be too often inaccessible, slow and difficult to use.</p>\n<h3>Frustrating UX: Birthday Dropdown/Widgets Starting In 2021</h3>\n<p>Every time you apply for a job application, open a bank account or book a flight, you probably will have to type in your date of birth. Obviously, the input is a <em>date</em>, and so it shouldn’t be very surprising to see interfaces using a well-adopted date-picker-calendar-alike widget (native or custom), or a drop-down to ask for that specific input.</p>\n<p>We can probably spot the reasons why these options are often preferred. From the technical standpoint, we want to ensure that the input is correct, and <strong>catch errors early</strong>. Our validation has to be bulletproof enough to validate the input, provide a clear error message and explain what exactly the customer needs to do to fix it. We just don’t have all these issues with a dropdown or a calendar widget. Plus, we can easily prevent any locale or formatting differences by providing only the options that would fit the bill.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f773d7bb-df56-409f-a3fb-aa1e6e0eea09/4-birthday-picker.jpg\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/43d34669-390a-4060-9e84-d9e5feba781a/5-birthday-picker.jpg\" /></p>\n<p>And then there is a question about <strong>default values</strong>. While with dropdowns we often default to no input whatsoever (<code>mm/dd/yyyy</code>), with a date picker we need to provide some starting point for the calendar view. In the latter case, ironically, the “starting” date usually happens to be just around the date of when the form is filled, e.g. <em>May 15th, 2021</em>. This doesn’t appear optimal of course, but what should be the <em>right</em> date? We need to start <em>somewhere,</em> right?</p>\n<p>Well, there really isn’t a right date though. We could start early or late, 3 months ago or tomorrow, but in the case of a birthday picker, all of these options are pure guesswork. And as such, they are somewhat frustrating: without any input, customers might need to scroll all the way from 1901 to the late 1980s, and with some input set, they’ll need to correct it, often jumping decades back and forth. That interaction will require impeccable precision in scrolling — which is totally unnecessary.</p>\n<p>No matter what choice we make, we will be wrong almost all the time. This is likely to be different for a hotel booking website, or a food delivery service, and plenty of other use cases — just not birthday input. This brings us to the conversation about how to objectively evaluate if a form input design is good or not.</p>\n<h3>Evaluating The Quality Of Form Design</h3>\n<p>Design can be seen as a very subjective matter. After all, everybody seems to have their own opinion and preferences about the right approach for a given problem. But unlike any kind of self-expression or art, design is supposed to solve a problem. The question, then, is how well a particular design solves a particular problem. The more obvious, clear, and unambiguous the <a href=\"https://articles.uie.com/design_rendering_intent/\">rendering of designer’s intent</a>, the fewer mistakes customers make, the less they are interrupted, the better the design.</p>\n<p>In my own experience, forms are the most difficult aspect of user experience. There are so many difficult facets from microcopy and form layout to inline validation and error messages; getting everything right often requires surfacing back-end errors properly to the front-end and simplifying a complex underlying structure into a set of predictable and reasonable form fields. This can easily become a frustrating nightmare in legacy applications. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5b63405f-4e59-4d61-8f0e-40864f05978d/6-birthday-picker.png\" /></p>\n<p>So, when it comes to <strong>form design</strong>, in our projects, we always try to measure the quality of a particular solution based on the following 9 attributes:</p>\n<ul>\n<li><strong>Mental model</strong><br />How well does our form design fit into the mental model of the customer? When asking for personal details, we need to ask exactly the minimum of what’s required for us to help our customers get started. We shouldn’t ask for any sensitive or personal details (gender, birthday, phone number) unless we have a good reason for it, and explain it in the UI. </li>\n<li><strong>Complexity</strong><br />How many input elements do we display per page, on mobile and on desktop? If a form contains 70–80 input fields, rather than displaying them all on one page, or use a multi-column layout, it might be a good idea to use a <a href=\"https://design-system.service.gov.uk/patterns/task-list-pages/\">task list pattern</a> to break down complexity into smaller, manageable chunks.</li>\n<li><strong>Speed of input</strong><br />How much time and effort does the customer need to fill in data correctly? For a given input, how many taps/keystrokes/operations are required to complete the form accurately, assuming that no mistakes are done along the way.</li>\n<li><strong>Accessibility</strong><br />When speaking about the speed of input, we need to ensure that we support various modes of interaction, primarily screen reader users and keyboard users. This means properly set labels, large buttons, labels placed above the input field, and errors properly communicated, among many other things.</li>\n<li><strong>Scalability</strong><br />If we ever needed to translate the UI to another language or adapt it for another form factor, how straightforward would it be, and how many issues will it cause? (A typical example of a problematic solution are floating patterns, and we’ll talk about them separately.)</li>\n<li><strong>Severity of interruptions</strong><br />How often do we interrupt customers, be it with loading spinners, early or late inline validation, freezing parts of the UI to adjust the interface based on provided UI (e.g. once a country is selected), the frequency of wrongly pre-filled data, or wrongly auto-corrected data?</li>\n<li><strong>Form success rate</strong><br />How many customers successfully complete a form without a single mistake? If a form is well designed, a vast majority of customers shouldn’t ever see any errors at all. For example, if the browser’s auto-fill works well, the tab order is logical and making edits is easy.</li>\n<li><strong>Speed of recovery</strong><br />How high is the ratio of customers who succeed in discovering the error, fixing it, and moving along to the next step of the form? That’s why we need to track how often error messages appear, and what error messages are most common. That’s also why it’s often a good idea to drop by customer support and check with them first what customers often complain about.</li>\n<li><strong>Form failure rate</strong><br />How many customers abandon the form? This usually happens not only because of the form’s complexity, but also because customers can’t find a way to fix an error due to aggressive validators or disabled “submit” buttons, or they are locked out, or because the form asks too much sensitive and personal information.</li>\n</ul>\n<p>To understand how well a form works, we run <strong>usability studies</strong> with customers accessing the interface on their own machine — be it mobile device, tablet, laptop or desktop — on their own OS, in their own browser. We ask to record the screen, if possible, and use a speak-aloud protocol, to follow where and how and why mistakes happen. We also study how fast the customer is moving from one form field to another, when they pause and think, and when most mistakes happen.</p>\n<p>Obviously, the <strong>sheer number of taps or clicks</strong> doesn’t always suggest that the input has been straightforward or cumbersome. But some modes of input might be more likely to generate errors or cause confusion, and others might be <em>outliers</em>, requiring just <em>way</em> more time compared to other options. That’s what we are looking for in tests.</p>\n<p>When we translate the above considerations to the context of a <strong>birthday input</strong>, we could ask a few questions about how they perform in regards to these questions:</p>\n<ol>\n<li>Do we tap into how users perceive the birthday input?</li>\n<li>Do we avoid unnecessarily complex input?</li>\n<li>Do we optimize for straightforward and fast input?</li>\n<li>Do we ensure the input and error messages are accessible?</li>\n<li>Do we communicate the errors are, how to fix them, and support error recovery?</li>\n<li>Do we avoid interruptions for fixing incorrect pre-filled values?</li>\n<li>Do we ensure that we support various formatting of dates (<code>dd/mm, mm/dd</code>)?</li>\n</ol>\n<p>These considerations might seem like a slightly over-engineered approach to form design, but in complex legacy applications that I tend to work with, forms are often a critical point of interaction, and often the sole reason why some websites exist (e.g. B2B-accounting, checkout, charities, media library) — and often it’s worth it. These considerations also heavily influence decisions around everything from checkboxes to radio buttons, as well as the length of input fields and interaction design such as validation.</p>\n<p>Now, let’s see how we can apply it to the birthday input problem.</p>\n<h3>Designing A Better Birthday Input</h3>\n<p>If somebody asks you for your birthday, you probably will have a particular string of digits in mind. It might be ordered in <code>dd/mm/yyyy</code> or <code>mm/dd/yyyy</code>, but it will be a string of 8 digits that you’ve been repeating in all kinds of documents since a very young age.</p>\n<p>We can tap into this simple model of what a birthday input is with a <strong>simple, single-input field</strong> which would combine all three inputs — day, month, and year. That would mean that the user would just type a string of 8 numbers, staying on the keyboard all the time. </p>\n<p>However, this approach brings up a few issues:</p>\n<ul>\n<li>we need to support auto-formatting and masking,</li>\n<li>we need to explain the position of the day/month input,</li>\n<li>we need to support the behavior of the <code>Backspace</code> button across the input,</li>\n<li>we need to track and hide/show/permanently display the masking, </li>\n<li>we need to support jumps into a specific value (e.g. month),</li>\n<li>we need to minimize rage clicks and navigation <em>within</em> the input to change a specific value on mobile devices,</li>\n<li>If auto-making isn’t used, we need to come up with a set of clean-up and validation rules to support any kind of delimiters.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c616aff8-a308-4a4c-823e-93b03f930698/7-birthday-picker.png\" /></p>\n<p>In his book on <a href=\"https://formdesignpatterns.com/\">Form Design Patterns</a>, Adam Silver suggests that <a href=\"https://design-system.service.gov.uk/components/date-input/\"><strong>using multiple inputs</strong></a> is much easier and more straightforward — both for developers and for customers. We can clearly communicate what each input represents, and we can highlight the specific input with focus styles. Also, validation is much easier, and we can communicate easily what specific part of the input seems to be invalid, and how to fix it.</p>\n<p>We could either automatically move the user from one input to the next when the input is finished, or allow users to move between fields on their own. At the first glance, the former seems better as the input would require just 8 digits, typed one after another. However, when people fix errors, they often need <em>input buffers</em> — space within the input field to correct existing input. For example, it’s common to see people typing in <em>01,</em> realizing that they made a mistake, then changing the input to <em>010,</em> and then removing the first <em>0,</em> just to end up with a reversed (and correct) string — <em>10.</em> </p>\n<p>By avoiding an automatic transition from one field to the next, we might be causing less trouble and making the just UI a bit more predictable and easy to deal with.</p>\n<p>To explain the input, we’d need to provide labels for the day, month and year, and perhaps also show an example of the correct input. <a href=\"https://www.smashingmagazine.com/2021/03/floating-labels-performance-lighthouse/\">The labels shouldn’t be floating labels</a> but could live comfortably above the input field, along with any hints or examples that we might want to display. Plus, every input could be highlighted on focus as well.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/27e28628-4b3a-42c2-a274-da218226f4c8/birthday-picker-8.png\" /></p>\n<p>I absolutely love Adam’s example because it’s perfectly simple, accessible and does the job well across all the attributes we’ve described above. Over years, I couldn’t spot a single problem with this solution throughout years of testing, and it’s not surprising the pattern <a href=\"https://design-system.service.gov.uk/components/date-input/\">being used on Gov.uk</a> as well.</p>\n<h3>When You Need A Date Picker After All</h3>\n<p>While the solution above is probably more than enough for a birthday input, it might not be good enough for more general situations. We might need a date input that’s less literal than a birth day, where customers will have to <em>pick</em> a day rather than <em>provide</em> it (e.g. “<em>first Saturday in July”</em>). For this case, we could enhance the three input fields with a calendar widget that could be optionally used as well. In this situation, a default input could indeed be today’s date or a date in the future that most customers tend to choose in your form. </p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5f1ee5ff-b130-46d6-b5c9-2cf5d3562dd8/9-birthday-picker.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0daea1f0-f4b4-48f1-a540-4f91da6225b3/10-birthday-picker.png\" /></p>\n<p>Adam provides a simple <a href=\"http://nostyle.herokuapp.com/components/memorable-date\">code example</a> for the Memorable date pattern in his <a href=\"http://nostyle.herokuapp.com/components/memorable-date\">NoStyle Design System</a>. It solves plenty of development work and avoids plenty of accessibility issues, and all of that by massively speeding up customers — no tapping around calendar widgets or scrolling around dropdown wheels is necessary.</p>\n<p>And if you’d like to keep one single input along with an accessible date picker, you can also use a <a href=\"http://nostyle.herokuapp.com/components/date-picker\">custom, accessible date picker</a> that works with text inputs as well.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/68d2549f-e4ce-448b-a08a-0940ee3b1018/11-birthday-picker.png\" /></p>\n<h3>Wrapping Up</h3>\n<p>Of course, a good form control depends on the kind of date input that we are expecting. For trip planners, where we expect customers to select a date of arrival, a more flexible input with a calendar look-up might be useful.</p>\n<p>When we ask our customers about their <strong>date of birth</strong> though, we are asking for a very specific date — a very <em>specific string,</em> referring to an exact day, month, and year. In that case, a drop-down is unnecessary. Neither is a calendar look-up, defaulting to a more-or-less random value. If you do need one, <strong>avoid native date pickers and native drop-downs</strong> as much as possible and build a custom solution instead. And rely on three simple input fields, with labels placed above the input field.</p>\n<p>We’ve also published a lengthy opus on <a href=\"https://www.smashingmagazine.com/2017/07/designing-perfect-date-time-picker/\">designing a perfect date and time picker</a>, along with checklists you might want to use to design or build one.</p>\n<h4>Related Articles</h4>\n<p>If you find this article useful, here’s an overview of similar articles we’ve published over the years — and a few more are coming your way.</p>\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2018/02/designing-a-perfect-responsive-configurator/\">Perfect Responsive Configurator</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2017/08/designing-perfect-feature-comparison-table/\">Perfect Feature Comparison</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2017/07/designing-perfect-slider/\">Perfect Slider</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2017/06/designing-perfect-accordion-checklist/\">Perfect Accordion</a></li>\n<li><a href=\"https://www.smashingmagazine.com/the-smashing-newsletter/\">Subscribe to our email newsletter</a> to not miss the next ones.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"40f68da08688048b918d8a5ecd4feb43a0ef6319bf9a36c0ca2a1cf341f3cb50","category":"Tech"}