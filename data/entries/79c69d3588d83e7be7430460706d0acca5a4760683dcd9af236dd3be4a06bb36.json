{"title":"Get Started With React By Building A Whac-A-Mole Game","link":"https://smashingmagazine.com/2021/05/get-started-whac-a-mole-react-game/","date":1620644400000,"content":"<p>I’ve been working with React since ~v0.12 was released. (2014! Wow, where did the time go?) It’s changed a lot. I recall certain “Aha” moments along the way. One thing that’s remained is the mindset for using it. We think about things in a different way as opposed to working with the DOM direct.</p>\n<p>For me, my learning style is to get something up and running as fast as I can. Then I explore deeper areas of the docs and everything included whenever necessary. <strong>Learn by doing, having fun, and pushing things!</strong></p>\n<h3>Aim</h3>\n<p>The aim here is to show you enough React to cover some of those \"Aha\" moments. Leaving you curious enough to dig into things yourself and create your own apps.\nI recommend <a href=\"https://reactjs.org/docs/hello-world.html\">checking out the docs</a> for anything you want to dig into. I won’t be duplicating them.</p>\n<p><em>Please note that you can find all examples in <a href=\"https://codepen.io\">CodePen</a>, but you can also jump to <a href=\"https://github.com/jh3y/whac-a-mole-react\">my Github repo</a> for a fully working game.</em></p>\n<h3>First App</h3>\n<p>You can bootstrap a React app in various ways. Below is an example:</p>\n<pre><code>import React from 'https://cdn.skypack.dev/react'\nimport { render } from 'https://cdn.skypack.dev/react-dom'\n\nconst App = () =&gt; &lt;h1&gt;{`Time: ${Date.now()}`}&lt;/h1&gt;\n\nrender(&lt;App/&gt;, document.getElementById('app')\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ae30bae4-cada-4a88-b7fa-361dee61e533/whac-a-mole-sketch.png\" /></p>\n<h3>Starting Point</h3>\n<p>We’ve learned how to make a component and we can roughly gauge what we need.</p>\n<div>\n <pre><code>import React, { Fragment } from '<a href=\"https://cdn.skypack.dev/react'\">https://cdn.skypack.dev/react'</a>\nimport { render } from '<a href=\"https://cdn.skypack.dev/react-dom'\">https://cdn.skypack.dev/react-dom'</a>\n\nconst Moles = ({ children }) =&gt; &lt;div&gt;{children}&lt;/div&gt;\nconst Mole = () =&gt; &lt;button&gt;Mole&lt;/button&gt;\nconst Timer = () =&gt; &lt;div&gt;Time: 00:00&lt;/div&gt;\nconst Score = () =&gt; &lt;div&gt;Score: 0&lt;/div&gt;\n\nconst Game = () =&gt; (\n  &lt;Fragment&gt;\n    &lt;h1&gt;Whac-A-Mole&lt;/h1&gt;\n    &lt;button&gt;Start/Stop&lt;/button&gt;\n    &lt;Score/&gt;\n    &lt;Timer/&gt;\n    &lt;Moles&gt;\n      &lt;Mole/&gt;\n      &lt;Mole/&gt;\n      &lt;Mole/&gt;\n      &lt;Mole/&gt;\n      &lt;Mole/&gt;\n    &lt;/Moles&gt;\n  &lt;/Fragment&gt;\n)\n\nrender(&lt;Game/&gt;, document.getElementById('app'))\n</code></pre>\n</div>\n\n<h3>Starting/Stopping</h3>\n<p>Before we do anything, we need to be able to start and stop the game. Starting the game will trigger elements like the timer and moles to come to life. This is where we can introduce <strong>conditional rendering</strong>.</p>\n<pre><code>const Game = () =&gt; {\n  const [playing, setPlaying] = useState(false)\n  return (\n    &lt;Fragment&gt;\n      {!playing &amp;&amp; &lt;h1&gt;Whac-A-Mole&lt;/h1&gt;}\n      &lt;button onClick={() =&gt; setPlaying(!playing)}&gt;\n        {playing ? 'Stop' : 'Start'}\n      &lt;/button&gt;\n      {playing &amp;&amp; (\n        &lt;Fragment&gt;\n          &lt;Score /&gt;\n          &lt;Timer /&gt;\n          &lt;Moles&gt;\n            &lt;Mole /&gt;\n            &lt;Mole /&gt;\n            &lt;Mole /&gt;\n            &lt;Mole /&gt;\n            &lt;Mole /&gt;\n          &lt;/Moles&gt;\n        &lt;/Fragment&gt;\n      )}\n    &lt;/Fragment&gt;\n  )\n}\n</code></pre>\n\n<p>We have a state variable of <code>playing</code> and we use that to render elements that we need. In JSX, we can use a condition with <code>&amp;&amp;</code> to render something if the condition is <code>true</code>. Here we say to render the board and its content if we are playing. This also affects the button text where we can use a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">ternary</a>.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bc29ad67-6029-43f3-9469-b406741aa211/react-devtools.png\" /></p>\n<p>Open the demo at <a href=\"https://cdpn.io/jh3y/debug/abpQvPg\">this link</a> and set the extension to highlight renders. Next, you’ll see that <strong>the timer renders as time changes</strong>, but when we whack a mole, all components re-render.</p>\n<h3>Loops in JSX</h3>\n<p>You might be thinking that the way we’re rendering our <code>Mole</code>s is inefficient. And you’d be right to think that! There’s an opportunity for us here to <strong>render these in a loop</strong>.</p>\n<p>With JSX, we tend to use <code>Array.map</code> 99% of the time to render a collection of things. <a href=\"https://codepen.io/smashingmag/pen/VwpLRLd\">For example</a>:</p>\n<div>\n <pre><code>const USERS = [\n  { id: 1, name: 'Sally' },\n  { id: 2, name: 'Jack' },\n]\nconst App = () =&gt; (\n  &lt;ul&gt;\n    {USERS.map(({ id, name }) =&gt; &lt;li key={id}&gt;{name}&lt;/li&gt;)}\n  &lt;/ul&gt;\n)\n</code></pre>\n</div>\n\n<p>The alternative would be to generate the content in a for loop and then render the return from a function.</p>\n<pre><code>return (\n  &lt;ul&gt;{getLoopContent(DATA)}&lt;/ul&gt;\n)\n</code></pre>\n\n<p>What’s that <code>key</code> attribute for? That helps React <strong>determine what changes need to render</strong>. If you can use a unique identifier, then do so! As a last resort, use the index of the item in a collection. (Read <a href=\"https://reactjs.org/docs/lists-and-keys.html\">the docs on lists</a> for more.)</p>\n<p>For our example, we don’t have any data to work with. If you need to generate a collection of things, then here’s a trick you can use:</p>\n<pre><code>new Array(NUMBER_OF_THINGS).fill().map()\n</code></pre>\n\n<p>This could work for you in some scenarios.</p>\n<div>\n <pre><code>return (\n  &lt;Fragment&gt;\n    &lt;h1&gt;Whac-A-Mole&lt;/h1&gt;\n    &lt;button onClick={() =&gt; setPlaying(!playing)}&gt;{playing ? 'Stop' : 'Start'}&lt;/button&gt;\n    {playing &amp;&amp;\n      &lt;Board&gt;\n        &lt;Score value={score} /&gt;\n        &lt;Timer time={TIME_LIMIT} onEnd={() =&gt; console.info('Ended')}/&gt;\n        {new Array(5).fill().map((_, id) =&gt; \n          &lt;Mole key={id} onWhack={onWhack} /&gt;\n        )}\n      &lt;/Board&gt;\n    }\n  &lt;/Fragment&gt;\n)\n</code></pre>\n</div>\n\n<p>Or, if you want a persistent collection, you could use something like <code>uuid</code>:</p>\n<div>\n <pre><code>import { v4 as uuid } from '<a href=\"https://cdn.skypack.dev/uuid'\">https://cdn.skypack.dev/uuid'</a>\nconst MOLE_COLLECTION = new Array(5).fill().map(() =&gt; uuid())\n\n// In our JSX\n{MOLE_COLLECTION.map((id) =&gt; \n  \n)}\n</code></pre>\n</div>\n\n<h3>Ending Game</h3>\n<p>We can only end our game with the Start button. When we do end it, the score remains when we start again. The <code>onEnd</code> for our <code>Timer</code> also does nothing yet.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f075c25f-811f-4d14-844d-117076251094/mole-design.png\" /></p>\n<p>We’re going to bring in a third-party solution to make our moles bob up and down. This is an example of how to bring in <strong>third-party solutions that work with the DOM</strong>. In most cases, we use refs to grab DOM elements, and then we use our solution within an effect.</p>\n<p>We’re going to use <a href=\"https://greensock.com\">GreenSock(GSAP)</a> to make our moles bob. We won’t dig into the GSAP APIs today, but if you have any questions about what they’re doing, please ask me!</p>\n<p>Here’s an updated <code>Mole</code> with <code>GSAP</code>:</p>\n<pre><code>import gsap from 'https://cdn.skypack.dev/gsap'\n\nconst Mole = ({ onWhack }) =&gt; {\n  const buttonRef = useRef(null)\n  useEffect(() =&gt; {\n    gsap.set(buttonRef.current, { yPercent: 100 })\n    gsap.to(buttonRef.current, {\n      yPercent: 0,\n      yoyo: true,\n      repeat: -1,\n    })\n  }, [])\n  return (\n    &lt;div className=\"mole-hole\"&gt;\n      &lt;button\n        className=\"mole\"\n        ref={buttonRef}\n        onClick={() =&gt; onWhack(MOLE_SCORE)}&gt;\n        Mole\n      &lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n\n<p>We’ve added a wrapper to the <code>button</code> which allows us to show/hide the <code>Mole</code>, and we’ve also given our <code>button</code> a <code>ref</code>. Using an effect, we can create a tween (GSAP animation) that moves the button up and down.</p>\n<p>You’ll also notice that we’re using <code>className</code> which is the attribute equal to <code>class</code> in JSX to apply class names. Why don’t we use the <code>className</code> with GSAP? Because if we have many elements with that <code>className</code>, our effect will try to use them all. This is why <code>useRef</code> is a great choice to stick with.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/QWpbQXW\">8. Moving Moles</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<p>Awesome, now we have bobbing <code>Mole</code>s, and our game is complete from a functional sense. They all move exactly the same which isn’t ideal. They should <strong>operate at different speeds</strong>. The points scored should also reduce the longer it takes for a <code>Mole</code> to get whacked.</p>\n<p>Our Mole’s internal logic can deal with how scoring and speeds get updated. Passing the initial <code>speed</code>, <code>delay</code>, and <code>points</code> in as props will make for a more flexible component.</p>\n<div>\n <pre><code>&lt;Mole key={index} onWhack={onWhack} points={MOLE_SCORE} delay={0} speed={2} /&gt;\n</code></pre>\n</div>\n\n<p>Now, for a breakdown of our <code>Mole</code> logic.</p>\n<p>Let’s start with how our points will reduce over time. This could be a good candidate for a <code>ref</code>. We have something that doesn’t affect render whose value could get lost in a closure. We create our animation in an effect and it’s never recreated. On each repeat of our animation, we want to decrease the <code>points</code> value by a multiplier. The points value can have a minimum value defined by a <code>pointsMin</code> prop.</p>\n<pre><code>const bobRef = useRef(null)\nconst pointsRef = useRef(points)\n\nuseEffect(() =&gt; {\n  bobRef.current = gsap.to(buttonRef.current, {\n    yPercent: -100,\n    duration: speed,\n    yoyo: true,\n    repeat: -1,\n    delay: delay,\n    repeatDelay: delay,\n    onRepeat: () =&gt; {\n      pointsRef.current = Math.floor(\n        Math.max(pointsRef.current * POINTS_MULTIPLIER, pointsMin)\n      )\n    },\n  })\n  return () =&gt; {\n    bobRef.current.kill()\n  }\n}, [delay, pointsMin, speed])\n</code></pre>\n\n<p>We’re also creating a <code>ref</code> to keep a reference for our GSAP animation. We will use this when the <code>Mole</code> gets whacked. Note how we also return a function that kills the animation on unmount. If we don’t kill the animation on unmount, the repeat code will keep firing.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/JjWdpQr\">9. Score Reduction</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<p>What will happen when a mole gets whacked? We need a new state for that.</p>\n<pre><code>const [whacked, setWhacked] = useState(false)\n</code></pre>\n\n<p>And instead of using the <code>onWhack</code> prop in the <code>onClick</code> of our <code>button</code>, we can create a new function <code>whack</code>. This will set <code>whacked</code> to <code>true</code> and call <code>onWhack</code> with the current <code>pointsRef</code> value.</p>\n<pre><code>const whack = () =&gt; {\n setWhacked(true)\n onWhack(pointsRef.current)\n}\n\nreturn (\n &lt;div className=\"mole-hole\"&gt;\n    &lt;button className=\"mole\" ref={buttonRef} onClick={whack}&gt;\n      Mole\n    &lt;/button&gt;\n  &lt;/div&gt;\n)\n</code></pre>\n\n<p>The last thing to do is respond to the <code>whacked</code> state in an effect with <code>useEffect</code>. Using the <strong>dependency array</strong>, we can make sure we only run the effect when <code>whacked</code> changes. If <code>whacked</code> is <code>true</code>, we reset the points, pause the animation, and animate the <code>Mole</code> underground. Once underground, we wait for a random delay before restarting the animation. The animation will start speedier using <code>timescale</code> and we set <code>whacked</code> back to <code>false</code>.</p>\n<pre><code>useEffect(() =&gt; {\n  if (whacked) {\n    pointsRef.current = points\n    bobRef.current.pause()\n    gsap.to(buttonRef.current, {\n      yPercent: 100,\n      duration: 0.1,\n      onComplete: () =&gt; {\n        gsap.delayedCall(gsap.utils.random(1, 3), () =&gt; {\n          setWhacked(false)\n          bobRef.current\n            .restart()\n            .timeScale(bobRef.current.timeScale() * TIME_MULTIPLIER)\n        })\n      },\n    })\n  }\n}, [whacked])\n</code></pre>\n\n<p>That gives us:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/MWpwQNy\">10. React to Whacks</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<p>The last thing to do is pass props to our <code>Mole</code> instances that will make them behave differently. But, how we generate these props could cause an issue.</p>\n<pre><code>&lt;div className=\"moles\"&gt;\n  {new Array(MOLES).fill().map((_, id) =&gt; (\n    &lt;Mole\n      key={id}\n      onWhack={onWhack}\n      speed={gsap.utils.random(0.5, 1)}\n      delay={gsap.utils.random(0.5, 4)}\n      points={MOLE_SCORE}\n    /&gt;\n  ))}\n&lt;/div&gt;\n</code></pre>\n\n<p>This would cause an issue because the props would change on every render as we generate the moles. A better solution could be to generate a new <code>Mole</code> array each time we start the game and iterate over that. This way, we can keep the game random without causing issues.</p>\n<pre><code>const generateMoles = () =&gt; new Array(MOLES).fill().map(() =&gt; ({\n  speed: gsap.utils.random(0.5, 1),\n  delay: gsap.utils.random(0.5, 4),\n  points: MOLE_SCORE\n}))\n// Create state for moles\nconst [moles, setMoles] = useState(generateMoles())\n// Update moles on game start\nconst startGame = () =&gt; {\n  setScore(0)\n  setMoles(generateMoles())\n  setPlaying(true)\n  setFinished(false)\n}\n// Destructure mole objects as props\n&lt;div className=\"moles\"&gt;\n  {moles.map(({speed, delay, points}, id) =&gt; (\n    &lt;Mole\n      key={id}\n      onWhack={onWhack}\n      speed={speed}\n      delay={delay}\n      points={points}\n    /&gt;\n  ))}\n&lt;/div&gt;\n</code></pre>\n\n<p>And here’s the result! I’ve gone ahead and added some styling along with a few varieties of moles for our buttons.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/VwpLQod\">11. Functioning Whac-a-Mole</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<p>We now have a fully working “Whac-a-Mole” game built in React. It took us <strong>less than 200 lines of code</strong>. At this stage, you can take it away and make it your own. Style it how you like, add new features, and so on. Or you can stick around and we can put together some extras!</p>\n<h3>Tracking The Highest Score</h3>\n<p>We have a working \"Whac-A-Mole\", but how can we keep track of our highest achieved score? We could use an effect to write our score to <code>localStorage</code> every time the game ends. But, what if persisting things was a common need. We could create a custom hook called <code>usePersistentState</code>. This could be a wrapper around <code>useState</code> that reads/writes to <code>localStorage</code>.</p>\n<pre><code>  const usePersistentState = (key, initialValue) =&gt; {\n  const [state, setState] = useState(\n    window.localStorage.getItem(key)\n      ? JSON.parse(window.localStorage.getItem(key))\n      : initialValue\n  )\n  useEffect(() =&gt; {\n    window.localStorage.setItem(key, state)\n  }, [key, state])\n  return [state, setState]\n}\n</code></pre>\n\n<p>And then we can use that in our game:</p>\n<div>\n <pre><code>const [highScore, setHighScore] = usePersistentState('whac-high-score', 0)\n</code></pre>\n</div>\n\n<p>We use it exactly the same as <code>useState</code>. And we can hook into <code>onWhack</code> to set a new high score during the game when appropriate:</p>\n<pre><code>const endGame = points =&gt; {\n  if (score &gt; highScore) setHighScore(score) // play fanfare!\n}\n</code></pre>\n\n<p>How might we be able to tell if our game result is a new high score? Another piece of state? Most likely.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/NWpqYKK\">12. Tracking High Score</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<h3>Whimsical Touches</h3>\n<p>At this stage, we’ve covered everything we need to. Even how to make your own custom hook. Feel free to go off and make this your own.</p>\n<p>Sticking around? Let’s <strong>create another custom hook</strong> for adding audio to our game:</p>\n<pre><code>const useAudio = (src, volume = 1) =&gt; {\n  const [audio, setAudio] = useState(null)\n  useEffect(() =&gt; {\n    const AUDIO = new Audio(src)\n    AUDIO.volume = volume\n    setAudio(AUDIO)\n  }, [src])\n  return {\n    play: () =&gt; audio.play(),\n    pause: () =&gt; audio.pause(),\n    stop: () =&gt; {\n      audio.pause()\n      audio.currentTime = 0\n    },\n  }\n}\n</code></pre>\n\n<p>This is a rudimentary hook <strong>implementation for playing audio</strong>. We provide an audio <code>src</code> and then we get back the API to play it. We can add noise when we “whac” a mole. Then the decision will be, is this part of <code>Mole</code>? Is it something we pass to <code>Mole</code>? Is it something we invoke in <code>onWhack</code> ?</p>\n<p>These are the types of decisions that come up in component-driven development. We need to keep portability in mind. Also, what would happen if we wanted to <strong>mute the audio?</strong> How could we globally do that? It might make more sense as a first approach to control the audio within the <code>Game</code> component:</p>\n<pre><code>// Inside Game\nconst { play: playAudio } = useAudio('/audio/some-audio.mp3')\nconst onWhack = () =&gt; {\n  playAudio()\n  setScore(score + points)\n}\n</code></pre>\n\n<p>It’s all about design and decisions. If we bring in lots of audio, renaming the <code>play</code> variable could get tedious. Returning an Array from our hook-like <code>useState</code> would allow us to name the variable whatever we want. But, it also might be hard to remember which index of the Array accounts for which API method.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/eYvNMOB\">13. Squeaky Moles</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<h3>That’s It!</h3>\n<p>More than enough to get you started on your React journey, and we got to make something interesting. We sure did cover a lot:</p>\n<ul>\n<li>Creating an app,</li>\n<li>JSX,</li>\n<li>Components and props,</li>\n<li>Creating timers,</li>\n<li>Using refs,</li>\n<li>Creating custom hooks.</li>\n</ul>\n<p>We made a game! And now you can use your new skills to add new features or make it your own.</p>\n<p>Where did I take it? At the time of writing, it’s at this stage so far:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/JjWdLPO\">Whac-a-Mole w/ React &amp;&amp; GSAP</a> by <a href=\"https://codepen.io/jh3y\">@jh3y</a>.</p>\n<h3>Where To Go Next!</h3>\n<p>I hope building “Whac-a-Mole” has motivated you to start your React journey. Where next? Well, here are some links to resources to check out if you’re looking to dig in more — some of which are ones I found useful along the way.</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/\">React Documentation</a></li>\n<li>“<a href=\"https://overreacted.io/making-setinterval-declarative-with-react-hooks/\">Making <code>setInterval</code> Declarative With React Hooks</a>,” Dan Abramov</li>\n<li>“<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data\">How To Fetch Data With React Hooks</a>,” Robin Wieruch</li>\n<li>“<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\">When To <code>useMemo</code> And <code>useCallback</code></a>,” Kent C Dodds</li>\n<li><a href=\"https://www.smashingmagazine.com/search/?q=react\">Read more React articles</a> right here on Smashing Magazine</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"79c69d3588d83e7be7430460706d0acca5a4760683dcd9af236dd3be4a06bb36","category":"Tech"}