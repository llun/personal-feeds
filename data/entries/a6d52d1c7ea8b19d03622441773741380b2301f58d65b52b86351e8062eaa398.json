{"title":"หนังสือน่าสนใจ 100 Go Mistakes","link":"https://www.somkiat.cc/book-100-go-mistakes/","date":1624721425000,"content":"<p><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/06/go-mistakes-150x150.png\" /></p>\n<figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/06/go-mistakes.png\" /></figure>\n\n\n\n<p>วันนี้เห็นหนังสือที่น่าสนใจคือ <strong><a href=\"https://www.manning.com/books/100-go-mistakes-how-to-avoid-them\" target=\"_blank\">100 Go Mistakes: How to Avoid Them</a></strong><br />ทาง email โดยช่วงนี้ลด 40% อีกด้วย<br />ว่าด้วย 100 เรื่องที่มักจะใช้งานผิดพลาดในภาษา Go<br />เพื่อช่วยให้ Go Developer ได้เรียนรู้<br />เพื่อรู้และเข้าใจ รวมทั้งหลีกเลี่ยงความผิดพลาดที่อาจะเกิดขึ้นได้</p>\n\n\n\n<span></span>\n\n\n\n<p>ผู้เขียนหนังสือเล่มนี้ เริ่มจากการเขียนบทความเรื่อง <br /><a href=\"https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65\" target=\"_blank\">The Top 10 Most Common Mistakes I’ve Seen in Go Projects</a></p>\n\n\n\n<p><strong>เนื้อหาในหนังสือเล่มนี้ประกอบไปด้วย</strong></p>\n\n\n\n<p><strong>Basics:</strong></p>\n\n\n\n<ul><li>Unintended variable shadowing</li><li>Ignoring logging side effects</li><li>Comparing values incorrectly</li><li>JSON handling mistakes</li><li>Formatting network addresses for IPv4 solely</li><li>Handling enums incorrectly</li><li>Not using defer</li><li>Ignoring how defer arguments and receivers are evaluated</li><li>Not closing resources</li><li>Creating confusion with octal literals</li><li>Neglecting integer overflows</li><li>Not understanding floating-points</li><li>Not using linters</li></ul>\n\n\n\n<p><strong>Code organization:</strong></p>\n\n\n\n<ul><li>Writing nested code</li><li>Misusing init functions</li><li>Always using getters and setters</li><li>Interface pollution</li><li>Interface on producer-side</li><li>Returning interfaces</li><li>interface{} says nothing</li><li>Not using the functional options pattern</li><li>Project misorganization</li><li>Creating utility packages</li><li>Ignoring package name collisions</li><li>Missing code documentation</li></ul>\n\n\n\n<p><strong>Data structures:</strong></p>\n\n\n\n<ul><li>Not understanding slice length and capacity</li><li>Inaccurate slice initialization</li><li>Creating conflicts using slice append</li><li>Not making slice copy correctly</li><li>Slice and memory leaks</li><li>Being confused about nil vs. empty slice</li><li>Not properly checking if a slice is empty</li><li>Inaccurate map initialization</li></ul>\n\n\n\n<p><strong>Control structures:</strong></p>\n\n\n\n<ul><li>Ignoring that elements are copied in range loops</li><li>Ignoring how arguments are evaluated in range loops</li><li>Ignoring the impacts of using element pointers in range loops</li><li>Making wrong assumptions during map iterations</li><li>Ignoring how the break statement work</li><li>Using defer inside a loop</li><li>Forgetting about the switch fall through behavior</li></ul>\n\n\n\n<p><strong>String:</strong></p>\n\n\n\n<ul><li>Not understanding the concept of rune</li><li>Inaccurate string iteration</li><li>Misusing trim functions</li><li>Under-optimized strings concatenation</li><li>Useless string conversion</li><li>Substring and memory leaks</li></ul>\n\n\n\n<p><strong>Functions and methods:</strong></p>\n\n\n\n<ul><li>Not knowing which type of receiver to use</li><li>Not using named result parameters</li><li>Unintended side-effects with named result parameters</li><li>Returning a nil receiver</li><li>Using a filename as a function input</li></ul>\n\n\n\n<p><strong>Error management:</strong></p>\n\n\n\n<ul><li>Panicking</li><li>Ignoring when to wrap an error</li><li>Comparing an error type inefficiently</li><li>Comparing an error value inefficiently</li><li>Handling an error twice</li><li>Ignoring an error</li><li>Not handling defer errors</li></ul>\n\n\n\n<p><strong>Concurrency:</strong></p>\n\n\n\n<ul><li>Mixing concurrency and parallelism</li><li>Concurrency isn’t always faster</li><li>Misunderstanding Go contexts</li><li>Not understanding what a race condition is</li><li>Append is not always race free</li><li>Goroutines and loop variables</li><li>Channel receive/send and context</li><li>Not using directional channels</li><li>Not using notification channels</li><li>Closing channels inaccurately</li><li>Buffered channel capacity and magic number</li><li>Not using nil channels</li><li>Passing a struct containing a sync field</li><li>Exporting concurrency primitives</li><li>Not using sync.RWMutex</li><li>Misusing sync.WaitGroup</li><li>Forgetting about sync.Cond</li><li>Not using errgroup package</li><li>Not using runtime.NumCPU()</li><li>time.After and memory leak</li><li>Ignoring false sharing</li></ul>\n\n\n\n<p><strong>Testing:</strong></p>\n\n\n\n<ul><li>Forgetting to fail a test</li><li>Not using table-driven tests</li><li>Not using test build flags</li><li>Not using the race option</li><li>Not checking goroutines leaks</li><li>Writing inaccurate benchmarks</li></ul>\n\n\n\n<p><strong>Optimization:</strong></p>\n\n\n\n<ul><li>Byte slice and map key</li><li>Pointers everywhere</li><li>Expecting that a pointer address is constant</li><li>Structure alignment</li><li>Inlining</li></ul>\n\n\n\n<p><strong>Production:</strong></p>\n\n\n\n<ul><li>Using the default http client and server</li><li>Go and Docker</li><li>Not exposing a pprof endpoint</li><li>Generating random numbers in security-sensitive applications</li></ul>\n\n\n\n<p><strong><em>ลองหาอ่านกันดูครับ<br />ต่อการพัฒนาระบบด้วยภาษา Go</em></strong></p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"a6d52d1c7ea8b19d03622441773741380b2301f58d65b52b86351e8062eaa398","category":"Thai"}