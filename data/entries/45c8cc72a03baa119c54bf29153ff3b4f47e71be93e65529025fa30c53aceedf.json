{"title":"[Java] การใช้งาน Sequential และ Parallel Stream","link":"https://www.somkiat.cc/java-ith-sequential-and-parallel-stream/","date":1621850939000,"content":"<p><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/05/cartoon-mice-and-elephant-150x150.png\" /></p>\n<figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/05/cartoon-mice-and-elephant.png\" /></figure>\n\n\n\n<p>ใน Java 8 ขึ้นมานั้น (นานแล้ว)<br />มี <strong><a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/package-summary.html\" target=\"_blank\">Stream API</a></strong> เพิ่มเข้ามา <br />ทำให้ง่ายต่อการเข้าถึงข้อมูลในรูปแบบของ collection<br />โดยไม่ทำการแก้ไขข้อมูลต้นทางหรือต้นฉบับ<br />สามารถทำซ้ำแล้วซ้ำเล่า <br />จะได้ผลเช่นเดิม ใน operation เดิมเสมอ<br />ซึ่งการใช้งานสามารถสร้าง stream ในรูปแบบของ sequential <br />หรือ parallel (ตาม core ของ CPU) ก็ได้</p>\n\n\n\n<span></span>\n\n\n\n<p><strong>คำถามที่น่าสนใจคือ</strong></p>\n\n\n\n<p>เมื่อใดควรใช้ sequential stream ?<br />เมื่อใดควรใช้ parallel stream ?<br /></p>\n\n\n\n<p><strong>ก่อนที่จะเลือกว่าจะใช้อะไรนั้น </strong><br /><strong>ควรทำความเข้าใจแต่ละอย่างก่อนว่าเป็นอย่างไร ?</strong></p>\n\n\n\n<p>พื้นฐานของ Stream คือตัวหุ้มหรือ wrapper ของ data source นั่นเอง<br />ช่วยให้เราสามารถทำงานหรือ operation ต่าง ๆ บน data source ได้อย่างง่าย<br />หรือเรียกว่าการเพิ่ม operation บน data pipeline</p>\n\n\n\n<figure><img src=\"https://www.somkiat.cc/wp-content/uploads/2021/05/Screen-Shot-2564-05-24-at-01.26.59.png\" /></figure>\n\n\n\n<p><strong>Sequential stream คืออะไร </strong></p>\n\n\n\n<p>เป็นค่า default สำหรับ Stream นั่นเอง<br />โดยที่ operation ต่าง ๆ จะทำงานแบบตามลำดับอยู่แล้ว<br />การทำงานแบบ sequential คือ ทำงานบน main thread <br />ดัง code ตัวอย่าง</p>\n\n\n\n[gist id=\"192fab39f7944ccb51789cda080b5a21\" file=\"1.java\"]\n\n\n\n<p><strong>Parallel stream คืออะไร</strong></p>\n\n\n\n<p>เราสามารถแปลงจาก sequential มาเป็น parallel ได้เลย<br />โดยใช้งานผ่าน method parallelStream() หรือ parallel()<br />ซึ่งจะทำการแยก thread ไปทำงานตามแต่ละ core ของ CPU<br />และนำผลที่ได้มารวมกัน<br />ซึ่งใช้เทคนิคของ <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ForkJoinPool.html\" target=\"_blank\">Fork and Join</a><br />ดัง code ตัวอย่าง</p>\n\n\n\n[gist id=\"192fab39f7944ccb51789cda080b5a21\" file=\"2.java\"]\n\n\n\n<p><strong>ลองมาทำ Benchmark ด้วย <a href=\"https://github.com/openjdk/jmh\" target=\"_blank\">JMH (Java Microbenchmark Harness) </a>กัน</strong></p>\n\n\n\n<p>ถึงแม้ว่าการทำงานแบบ parallel จะมีประโยชน์<br />แต่ก็มาพร้อมกับ overhead เช่นกัน<br />ทั้งการจัดการ thread (Fork and Join) <br />ทั้งการแยกและรวมข้อมูล<br />ทั้งการจัดการ memory</p>\n\n\n\n[gist id=\"192fab39f7944ccb51789cda080b5a21\" file=\"3.java\"]\n\n\n\n<p>จะเลือกสิ่งใดต้องเข้าใจ รวมทั้งต้อง benchmark เสมอ</p>\n","author":"somkiat","siteTitle":"cc :: somkiat","siteHash":"3a23a5a4389e1e40c6fbb16520a8cc20df5b3591c25145ce72aaa18b19e48201","entryHash":"45c8cc72a03baa119c54bf29153ff3b4f47e71be93e65529025fa30c53aceedf","category":"Thai"}