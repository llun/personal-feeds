{"title":"Adding A Commenting System To A WYSIWYG Editor","link":"https://smashingmagazine.com/2021/05/commenting-system-wysiwyg-editor/","date":1622199600000,"content":"<p>In recent years, we’ve seen Collaboration penetrate a lot of digital workflows and use-cases across many professions. Just within the Design and Software Engineering community, we see designers collaborate on design artifacts using tools like <a href=\"https://www.figma.com/collaboration/\">Figma</a>, teams doing Sprint and Project Planning using tools like <a href=\"https://www.mural.co/?\">Mural</a> and interviews being conducted using <a href=\"https://coderpad.io/\">CoderPad</a>. All these tools are constantly aiming to bridge the gap between an online and a physical world experience of executing these workflows and making the collaboration experience as rich and seamless as possible.</p>\n<p>For the majority of the Collaboration Tools like these, the ability to share opinions with one another and have discussions about the same content is a must-have. A Commenting System that enables collaborators to annotate parts of a document and have conversations about them is at the heart of this concept. Along with building one for text in a WYSIWYG Editor, the article tries to engage the readers into how we try to weigh the pros and cons and attempt to find a balance between application complexity and user experience when it comes to building features for WYSIWYG Editors or Word Processors in general.</p>\n<h3>Representing Comments In Document Structure</h3>\n<p>In order to find a way to represent comments in a rich text document’s data structure, let’s look at a few scenarios under which comments could be created inside an editor.</p>\n<ul>\n<li>Comments created over text that has no styles on it (basic scenario);</li>\n<li>Comments created over text that may be bold/italic/underlined, and so on;</li>\n<li>Comments that overlap each other in some way (partial overlap where two comments share only a few words or fully-contained where one comment’s text is fully contained within text of another comment);</li>\n<li>Comments created over text inside a link (special because links are nodes themselves in our document structure);</li>\n<li>Comments that span multiple paragraphs (special because paragraphs are nodes in our document structure and comments are applied to text nodes which are paragraph’s children).</li>\n</ul>\n<p>Looking at the above use-cases, it seems like comments in the way they can come up in a rich text document are very similar to character styles (bold, italics etc). They can overlap with each other, go over text in other types of nodes like links and even span multiple parent nodes like paragraphs.</p>\n<p>For this reason, we use the same method to represent comments as we do for character styles, i.e. “Marks” (as they are so called in SlateJS terminology). Marks are just regular properties on nodes — speciality being that Slate’s API around marks (<code>Editor.addMark</code> and <code>Editor.removeMark</code>) handles changing of the node hierarchy as multiple marks get applied to the same range of text. This is extremely useful to us as we deal with a lot of different combinations of overlapping comments.</p>\n<h4>Comment Threads As Marks</h4>\n<p>Whenever a user selects a range of text and tries to insert a comment, technically, they’re starting a new comment thread for that text range. Because we would allow them to insert a comment and later replies to that comment, we treat this event as a new comment thread insertion in the document.</p>\n<p>The way we represent comment threads as marks is that each comment thread is represented by a mark named as <code>commentThread_threadID</code> where <code>threadID</code> is a unique ID we assign to each comment thread.  So, if the same range of text has two comment threads over it, it would have two properties set to the <code>true</code> — <code>commentThread_thread1</code> and <code>commentThread_thread2</code>. This is where comment threads are very similar to character styles since if the same text was bold and italic, it would have both the properties set to <code>true</code> — <code>bold</code> and <code>italic</code>.</p>\n<p>Before we dive into actually setting this structure up, it’s worth looking at how the text nodes change as comment threads get applied to them. The way this works (as it does with any mark) is that when a mark property is being set on the selected text, Slate’s <a href=\"https://github.com/ianstormtaylor/slate/blob/228f4fa94f61f42ca41feae2b3029ebb570e0480/packages/slate/src/create-editor.ts#L92\">Editor.addMark</a> API would split the text node(s) if needed such that in the resulting structure, text nodes are set up in a way that each text node has the exact same value of the mark.</p>\n<p>To understand this better, take a look at the following three examples that show the before-and-after state of the text nodes once a comment thread is inserted on the selected text:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ca21103b-cd8c-4868-8240-db95ceafb0ff/1-structure-uncommented-textt.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8be36e26-f239-40a0-8393-f20875bf32b2/2-structure-partial-overlap.png\" /></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/69f3d6f6-557b-4b43-80c9-0b2db1e490c7/3-structure-thread-links.png\" /></p>\n<h3>Highlighting Commented Text</h3>\n<p>Now that we know how we are going to represent comments in the document structure, let’s go ahead and add a few to the example document from the <a href=\"https://www.smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/\">first article</a> and configure the editor to actually show them as highlighted. Since we will have a lot of utility functions to deal with comments in this article, we create a <code>EditorCommentUtils</code> module that will house all these utils. To start with, we create a function that creates a mark for a given comment thread ID. We then use that to insert a few comment threads in our <code>ExampleDocument</code>.</p>\n<pre><code># src/utils/EditorCommentUtils.js\n\nconst COMMENT_THREAD_PREFIX = \"commentThread_\";\n\nexport function getMarkForCommentThreadID(threadID) {\n  return `${COMMENT_THREAD_PREFIX}${threadID}`;\n}</code></pre>\n\n<p>Below image underlines in red the ranges of text that we have as example comment threads added in the next code snippet. Note that the text ‘Richard McClintock’ has two comment threads that overlap each other. Specifically, this is a case of one comment thread being fully contained inside another.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1f785c2a-4d29-4878-8c17-bce30b0cc6ee/highlight-comment-before.png\" /></p>\n<div>\n<pre><code># src/utils/ExampleDocument.js\nimport { getMarkForCommentThreadID } from \"../utils/EditorCommentUtils\";\nimport { v4 as uuid } from \"uuid\";\n\nconst exampleOverlappingCommentThreadID = uuid();\n\nconst ExampleDocument = [\n   ...\n   {\n        text: \"Lorem ipsum\",\n        [getMarkForCommentThreadID(uuid())]: true,\n   },\n   ...\n   {\n        text: \"Richard McClintock\",\n        // note the two comment threads here.\n        [getMarkForCommentThreadID(uuid())]: true,\n        [getMarkForCommentThreadID(exampleOverlappingCommentThreadID)]: true,\n   },\n   {\n        text: \", a Latin scholar\",\n        [getMarkForCommentThreadID(exampleOverlappingCommentThreadID)]: true,\n   },\n   ...\n];</code></pre>\n</div>\n\n<p>We focus on the UI side of things of a Commenting System in this article so we assign them IDs in the example document directly using the npm package <a href=\"https://www.npmjs.com/package/uuid\">uuid</a>. Very likely that in a production version of an editor, these IDs are created by a backend service.</p>\n<p>We now focus on tweaking the editor to show these text nodes as highlighted. In order to do that, when rendering text nodes, we need a way to tell if it has comment threads on it. We add a util <code>getCommentThreadsOnTextNode</code> for that. We build on the <code>StyledText</code> component that we created in the first article to handle the case where it may be trying to render a text node with comments on. Since we have some more functionality coming that would be added to commented text nodes later, we create a component <code>CommentedText</code> that renders the commented text. <code>StyledText</code> will check if the text node it’s trying to render has any comments on it. If it does, it renders <code>CommentedText</code>. It uses a util <code>getCommentThreadsOnTextNode</code> to deduce that.</p>\n<pre><code># src/utils/EditorCommentUtils.js\n\nexport function getCommentThreadsOnTextNode(textNode) {\n  return new Set(\n     // Because marks are just properties on nodes,\n    // we can simply use Object.keys() here.\n    Object.keys(textNode)\n      .filter(isCommentThreadIDMark)\n      .map(getCommentThreadIDFromMark)\n  );\n}\n\nexport function getCommentThreadIDFromMark(mark) {\n  if (!isCommentThreadIDMark(mark)) {\n    throw new Error(\"Expected mark to be of a comment thread\");\n  }\n  return mark.replace(COMMENT_THREAD_PREFIX, \"\");\n}\n\nfunction isCommentThreadIDMark(mayBeCommentThread) {\n  return mayBeCommentThread.indexOf(COMMENT_THREAD_PREFIX) === 0;\n}</code></pre>\n\n<p>The <a href=\"https://www.smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/\">first article</a> built a component <code>StyledText</code> that renders text nodes (handling character styles and so on). We extend that component to use the above util and render a <code>CommentedText</code> component if the node has comments on it.</p>\n<pre><code># src/components/StyledText.js\n\nimport { getCommentThreadsOnTextNode } from \"../utils/EditorCommentUtils\";\n\nexport default function StyledText({ attributes, children, leaf }) {\n  ...\n\n  const commentThreads = getCommentThreadsOnTextNode(leaf);\n\n  if (commentThreads.size &gt; 0) {\n    return (\n      &lt;CommentedText\n      {...attributes}\n     // We use commentThreads and textNode props later in the article.\n      commentThreads={commentThreads}\n      textNode={leaf}\n      &gt;\n        {children}\n      &lt;/CommentedText&gt;\n    );\n  }\n\n  return &lt;span {...attributes}&gt;{children}&lt;/span&gt;;\n}</code></pre>\n\n<p>Below is the implementation of <code>CommentedText</code> that renders the text node and attaches the CSS that shows it as highlighted.</p>\n<pre><code># src/components/CommentedText.js\n\nimport \"./CommentedText.css\";\n\nimport classNames from \"classnames\";\n\nexport default function CommentedText(props) {\n  const { commentThreads, ...otherProps } = props;\n  return (\n    &lt;span\n      {...otherProps}\n      className={classNames({\n        comment: true,\n      })}\n    &gt;\n      {props.children}\n    &lt;/span&gt;\n  );\n}\n\n# src/components/CommentedText.css\n\n.comment {\n  background-color: #feeab5;\n}</code></pre>\n\n<p>With all of the above code coming together, we now see text nodes with comment threads highlighted in the editor.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0a54ada8-f9fc-4cd6-b3b0-8dbbd9c11b45/highlight-comment-after.png\" /></p>\n<p><strong>Note</strong>: <em>The users currently cannot tell if certain text has overlapping comments on it. The entire highlighted text range looks like a single comment thread. We address that later in the article where we introduce the concept of active comment thread which lets users select a specific comment thread and be able to see its range in the editor.</em></p>\n<h3>UI Storage For Comments</h3>\n<p>Before we add the functionality that enables a user to insert new comments, we first setup a UI state to hold our comment threads. In this article, we use <a href=\"https://recoiljs.org/\">RecoilJS</a> as our state management library to store comment threads, comments contained inside the threads and other metadata like creation time, status, comment author etc. Let’s add Recoil to our application:</p>\n<pre><code>&gt; yarn add recoil</code></pre>\n\n<p>We use Recoil <a href=\"https://recoiljs.org/docs/basic-tutorial/atoms\">atoms</a> to store these two data structures. If you’re not familiar with Recoil, atoms are what hold the application state. For different pieces of application state, you’d usually want to set up different atoms. <a href=\"https://recoiljs.org/docs/api-reference/utils/atomFamily\">Atom Family</a> is a collection of atoms — it can be thought to be a <code>Map</code> from a unique key identifying the atom to the atoms themselves. It’s worth going through <a href=\"https://recoiljs.org/docs/introduction/core-concepts/\">core concepts</a> of Recoil at this point and familiarizing ourselves with them.</p>\n<p>For our use case, we store comment threads as an Atom family and then wrap our application in a <code>RecoilRoot</code> component. <a href=\"https://recoiljs.org/docs/api-reference/core/RecoilRoot\"><code>RecoilRoot</code></a> is applied to provide the context in which the atom values are going to be used. We create a separate module <code>CommentState</code> that holds our Recoil atom definitions as we add more atom definitions later in the article.</p>\n<pre><code># src/utils/CommentState.js\n\nimport { atom, atomFamily } from \"recoil\";\n\nexport const commentThreadsState = atomFamily({\n  key: \"commentThreads\",\n  default: [],\n});\n\nexport const commentThreadIDsState = atom({\n  key: \"commentThreadIDs\",\n  default: new Set([]),\n});</code></pre>\n\n<p>Worth calling out few things about these atom definitions:</p>\n<ul>\n<li>Each atom/atom family is uniquely identified by a <code>key</code> and can be set up with a default value.</li>\n<li>As we build further in this article, we are going to need a way to iterate over all the comment threads which would basically mean needing a way to iterate over <code>commentThreadsState</code> atom family. At the time of writing this article, the way to do that with Recoil is to set up another atom that holds all the IDs of the atom family. We do that with <code>commentThreadIDsState</code> above. Both these atoms would have to be kept in sync whenever we add/delete comment threads.</li>\n</ul>\n<p>We add a <code>RecoilRoot</code> wrapper in our root <code>App</code> component so we can use these atoms later. Recoil’s documentation also provides a helpful <a href=\"https://recoiljs.org/docs/guides/dev-tools/#observing-all-state-changes\">Debugger</a> component that we take as it is and drop into our editor. This component will leave <code>console.debug</code> logs to our Dev console as Recoil atoms are updated in real-time.</p>\n<pre><code># src/components/App.js\n\nimport { RecoilRoot } from \"recoil\";\n\nexport default function App() {\n  ...\n\n  return (\n    &lt;RecoilRoot&gt;\n      &gt;\n         ...\n        &lt;Editor document={document} onChange={updateDocument} /&gt;\n\n    &lt;/RecoilRoot&gt;\n  );\n}</code></pre>\n\n<pre><code># src/components/Editor.js\n\nexport default function Editor({ ... }): JSX.Element {\n  .....\n\n  return (\n    &lt;&gt;\n      &lt;Slate&gt;\n         .....\n      &lt;/Slate&gt;\n      &lt;DebugObserver /&gt;\n   &lt;/&gt;\n);\n\nfunction DebugObserver(): React.Node {\n   // see API link above for implementation.\n}</code></pre>\n\n<p>We also need to need to add code that initializes our atoms with the comment threads that already exist on the document (the ones we added to our example document in the previous section, for instance). We do that at a later point when we build the Comments Sidebar that needs to read all the comment threads in a document.</p>\n<p>At this point, we load our application, make sure there are no errors pointing to our Recoil setup and move forward.</p>\n<h3>Adding New Comments</h3>\n<p>In this section, we add a button to the toolbar that lets the user add comments (viz. create a new comment thread) for the selected text range. When the user selects a text range and clicks on this button, we need to do the below:</p>\n<ol>\n<li>Assign a unique ID to the new comment thread being inserted.</li>\n<li>Add a new mark to Slate document structure with the ID so the user sees that text highlighted.</li>\n<li>Add the new comment thread to Recoil atoms we created in the previous section.</li>\n</ol>\n<p>Let’s add a util function to <code>EditorCommentUtils</code> that does #1 and #2.</p>\n<div>\n<pre><code># src/utils/EditorCommentUtils.js\n\nimport { Editor } from \"slate\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport function insertCommentThread(editor, addCommentThreadToState) {\n    const threadID = uuidv4();\n    const newCommentThread = {\n        // comments as added would be appended to the thread here.\n        comments: [],\n        creationTime: new Date(),\n        // Newly created comment threads are OPEN. We deal with statuses\n        // later in the article.\n        status: \"open\",\n    };\n    addCommentThreadToState(threadID, newCommentThread);\n    Editor.addMark(editor, getMarkForCommentThreadID(threadID), true);\n    return threadID;\n}</code></pre>\n</div>\n\n<p>By using the concept of marks to store each comment thread as its own mark, we’re able to simply use the <code>Editor.addMark</code> API to add a new comment thread on the text range selected. This call alone handles all the different cases of adding comments — some of which  we described in the earlier section — partially overlapping comments, comments inside/overlapping links, comments over bold/italic text, comments spanning paragraphs and so on. This API call adjusts the node hierarchy to create as many new text nodes as needed to handle these cases.</p>\n<p><code>addCommentThreadToState</code> is a callback function that handles step #3 — adding the new comment thread to Recoil atom . We implement that next as a custom callback hook so that it’s re-usable. This callback needs to add the new comment thread to both the atoms — <code>commentThreadsState</code> and <code>commentThreadIDsState</code>. To be able to do this, we use the <a href=\"https://recoiljs.org/docs/api-reference/core/useRecoilCallback\"><code>useRecoilCallback</code></a> hook. This hook can be used to construct a callback which gets a few things that can be used to read/set atom data. The one we’re interested in right now is the <code>set</code> function which can be used to update an atom value as <code>set(atom, newValueOrUpdaterFunction)</code>.</p>\n<div>\n<pre><code># src/hooks/useAddCommentThreadToState.js\n\nimport {\n  commentThreadIDsState,\n  commentThreadsState,\n} from \"../utils/CommentState\";\n\nimport { useRecoilCallback } from \"recoil\";\n\nexport default function useAddCommentThreadToState() {\n  return useRecoilCallback(\n    ({ set }) =&gt; (id, threadData) =&gt; {\n      set(commentThreadIDsState, (ids) =&gt; new Set([...Array.from(ids), id]));\n      set(commentThreadsState(id), threadData);\n    },\n    []\n  );\n}</code></pre>\n</div>\n\n<p>The first call to <code>set</code> adds the new ID to the existing set of comment thread IDs and returns the new <code>Set</code>(which becomes the new value of the atom).</p>\n<p>In the second call, we get the atom for the ID from the atom family — <code>commentThreadsState</code> as <code>commentThreadsState(id)</code> and then set the <code>threadData</code> to be its value. <code>atomFamilyName(atomID)</code> is how Recoil lets us access an atom from its atom family using the unique key. Loosely speaking, we could say that if <code>commentThreadsState</code> was a javascript Map, this call is basically — <code>commentThreadsState.set(id, threadData)</code>. </p>\n<p>Now that we have all this code setup to handle insertion of a new comment thread to the document and Recoil atoms, lets add a button to our toolbar and wire it up with the call to these functions.</p>\n<div>\n<pre><code># src/components/Toolbar.js\n\nimport { insertCommentThread } from \"../utils/EditorCommentUtils\";\nimport useAddCommentThreadToState from \"../hooks/useAddCommentThreadToState\";\n\nexport default function Toolbar({ selection, previousSelection }) {\n  const editor = useEditor();\n  ...\n\n  const addCommentThread = useAddCommentThreadToState();\n\n  const onInsertComment = useCallback(() =&gt; {\n    const newCommentThreadID = insertCommentThread(editor, addCommentThread);\n  }, [editor, addCommentThread]);\n\nreturn (\n    &lt;div className=\"toolbar\"&gt;\n       ...\n      &lt;ToolBarButton\n        isActive={false}\n        label={&lt;i className={<code>bi ${getIconForButton(\"comment\")}</code>} /&gt;}\n        onMouseDown={onInsertComment}\n      /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em>We use <code>onMouseDown</code> and not <code>onClick</code> which would have made the editor lose focus and selection to become <code>null</code>. We’ve discussed that in a little more detail in the link insertion section of the <a href=\"https://www.smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/\">first article</a>.</em></p>\n<p>In the below example, we see the insertion in action for a simple comment thread and an overlapping comment thread with links. Notice how we get updates from Recoil Debugger confirming our state is getting updated correctly. We also verify that new text nodes are created as threads are being added to the document.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/53fa0167-b5b0-4a19-9857-1e34b556dcf9/shortest-length-rule.png\" /></p>\n<p>In the above example, the user inserts the following comment threads in that order:</p>\n<ol>\n<li>Comment Thread #1 over character ‘B’ (length = 1).</li>\n<li>Comment Thread #2 over ‘AB’ (length = 2).</li>\n<li>Comment Thread #3 over ‘BC’ (length = 2).</li>\n</ol>\n<p>At the end of these insertions, because of the way Slate splits the text nodes with marks, we will have three text nodes — one for each character. Now, if the user clicks on ‘B’, going by the shortest length rule, we select thread #1 as it is the shortest of the three in length. If we don’t do that, we wouldn’t have a way to select Comment Thread #1 ever since it is only one-character in length and also a part of two other threads.</p>\n<p>Although this rule makes it easy to surface shorter-length comment threads, we could run into situations where longer comment threads become inaccessible since all the characters contained in them are part of some other shorter comment thread. Let’s look at an example for that.</p>\n<p>Let’s assume we have 100 characters (say, character ‘A’ typed 100 times that is) and the user inserts comment threads in the following order:</p>\n<ol>\n<li>Comment Thread # 1 of range 20,80</li>\n<li>Comment Thread # 2 of range 0,50</li>\n<li>Comment Thread # 3 of range 51,100</li>\n</ol>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6b0cd9e6-0722-4565-abf6-58a32fcb3f70/shortest-length-rule-exception.png\" /></p>\n<p>As you can see in the above example, if we follow the rule we just described here, clicking on any character between #20 and #80, would always select threads #2 or #3 since they are shorter than #1 and hence #1 would not be selectable. Another scenario where this rule can leave us undecided as to which comment thread to select is when there are more than one comment threads of the same shortest length on a text node.</p>\n<p>For such combination of overlapping comments and many other such combinations that one could think of where following this rule makes a certain comment thread inaccessible by clicking on text, we build a Comments Sidebar later in this article which gives user a view of all the comment threads present in the document so they can click on those threads in the sidebar and activate them in the editor to see the range of the comment. We still would want to have this rule and implement it as it should cover a lot of overlap scenarios except for the less-likely examples we cited above. We put in all this effort around this rule primarily because seeing highlighted text in the editor and clicking on it to comment is a more intuitive way of accessing a comment on text than merely using a list of comments in the sidebar.</p>\n<h4>Insertion Rule</h4>\n<p>The rule is:</p>\n<blockquote>“If the text user has selected and is trying to comment on is already fully covered by comment thread(s), don’t allow that insertion.”</blockquote>\n\n<p>This is so because if we did allow this insertion, each character in that range would end up having at least two comment threads (one existing and another the new one we just allowed) making it difficult for us to determine which one to select when the user clicks on that character later.</p>\n<p>Looking at this rule, one might wonder why we need it in the first place if we already have the Shortest Comment Range Rule that allows us to select the smallest text range. Why not allow all combinations of overlaps if we can use the first rule to deduce the right comment thread to show? As some of the examples we’ve discussed earlier, the first rule works for a lot of scenarios but not all of them. With the Insertion Rule, we try to minimize the number of scenarios where the first rule cannot help us and we have to fallback on the Sidebar as the only way for the user to access that comment thread. Insertion Rule also prevents exact-overlaps of comment threads. This rule is commonly implemented by a lot of popular editors.</p>\n<p>Below is an example where if this rule didn’t exist, we would allow the Comment Thread #3 and then as a result of the first rule, #3 would not be accessible since it would become the longest in length.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/4babfb22-4448-4706-8f29-ab11bf43800b/select-comment-thread-example.png\" /></p>\n<p>In this example, let’s assume we don’t wait for intersection to become 0 and just stop when we reach the edge of a comment thread. Now, if the user clicked on #2 and we start traversal in reverse direction, we’d stop at the start of text node #2 itself since that’s the start of the comment thread A. As a result, we might not compute the comment thread lengths correctly for A &amp; B. With the implementation above traversing the farthest edges (text nodes 1,2, and 3), we should get B as the shortest comment thread as expected.</p>\n<p>To see the implementation visually, below is a walkthrough with a slideshow of the iterations. We have two comment threads A and B that overlap each other over text node #3 and the user clicks on the overlapping text node #3.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d4375dda-a6f9-40d7-9f88-bc19ffef04d0/select-comment-thread-range.png\" /></p>\n<p>Now that we have all the code in to make selection of comment threads work, let’s see it in action. To test our traversal code well, we test some straightforward cases of overlap and some edge cases like:</p>\n<ul>\n<li>Clicking on a commented text node at the start/end of the editor.</li>\n<li>Clicking on a commented text node with comment threads spanning multiple paragraphs.</li>\n<li>Clicking on a commented text node right before an image node.</li>\n<li>Clicking on a commented text node overlapping links.</li>\n</ul>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/18412e7f-4e8c-4725-ac02-ee2819725b60/recoil-initialization.png\" /></p>\n<p>Now that our state is correctly initialized, we can start implementing the sidebar. All our comment threads in the UI are stored in the Recoil atom family — <code>commentThreadsState</code>. As highlighted earlier, the way we iterate through all the items in a Recoil atom family is by tracking the atom keys/ids in another atom. We’ve been doing that with <code>commentThreadIDsState</code>.  Let’s add the <code>CommentSidebar</code> component that iterates through the set of ids in this atom and renders a <code>CommentThread</code> component for each.</p>\n<div>\n<pre><code># src/components/CommentsSidebar.js\n\nimport \"./CommentSidebar.css\";\n\nimport {commentThreadIDsState,} from \"../utils/CommentState\";\nimport { useRecoilValue } from \"recoil\";\n\nexport default function CommentsSidebar(params) {\n  const allCommentThreadIDs = useRecoilValue(commentThreadIDsState);\n\n  return (\n    &lt;Card className={\"comments-sidebar\"}&gt;\n      &lt;Card.Header&gt;Comments&lt;/Card.Header&gt;\n      &lt;Card.Body&gt;\n        {Array.from(allCommentThreadIDs).map((id) =&gt; (\n          &lt;Row key={id}&gt;\n            &lt;Col&gt;\n              &lt;CommentThread id={id} /&gt;\n            &lt;/Col&gt;\n          &lt;/Row&gt;\n        ))}\n      &lt;/Card.Body&gt;\n    &lt;/Card&gt;\n  );\n}</code></pre>\n</div>\n\n<p>Now, we implement the <code>CommentThread</code> component that listens to the Recoil atom in the family corresponding to the comment thread it is rendering. This way, as the user adds more comments on the thread in the editor or changes any other metadata, we can update the sidebar to reflect that.</p>\n<p>As the sidebar could grow to be really big for a document with a lot of comments, we hide all comments but the first one when we render the sidebar. The user can use the ‘Show/Hide Replies’ button to show/hide the entire thread of comments.</p>\n<div>\n<pre><code># src/components/CommentSidebar.js\n\nfunction CommentThread({ id }) {\n  const { comments } = useRecoilValue(commentThreadsState(id));\n\n  const [shouldShowReplies, setShouldShowReplies] = useState(false);\n  const onBtnClick = useCallback(() =&gt; {\n    setShouldShowReplies(!shouldShowReplies);\n  }, [shouldShowReplies, setShouldShowReplies]);\n\n  if (comments.length === 0) {\n    return null;\n  }\n\n  const [firstComment, ...otherComments] = comments;\n  return (\n    &lt;Card\n      body={true}\n      className={classNames({\n        \"comment-thread-container\": true,\n      })}\n    &gt;\n      &lt;CommentRow comment={firstComment} showConnector={false} /&gt;\n      {shouldShowReplies\n        ? otherComments.map((comment, index) =&gt; (\n            &lt;CommentRow key={<code>comment-${index}</code>} comment={comment} showConnector={true} /&gt;\n          ))\n        : null}\n      {comments.length &gt; 1 ? (\n        &lt;Button\n          className={\"show-replies-btn\"}\n          size=\"sm\"\n          variant=\"outline-primary\"\n          onClick={onBtnClick}\n        &gt;\n          {shouldShowReplies ? \"Hide Replies\" : \"Show Replies\"}\n        &lt;/Button&gt;\n      ) : null}\n    &lt;/Card&gt;\n  );\n}</code></pre>\n</div>\n\n<p>We’ve reused the <code>CommentRow</code> component from the popover although we added a design treatment using <code>showConnector</code> prop that basically makes all the comments look connected with a thread in the sidebar.</p>\n<p>Now, we render the <code>CommentSidebar</code> in the <code>Editor</code> and verify that it shows all the threads we have in the document and correctly updates as we add new threads or new comments to existing threads.</p>\n<pre><code># src/components/Editor.js\n\nreturn (\n    &lt;&gt;\n      &lt;Slate ... &gt;\n       .....\n        &lt;div className={\"sidebar-wrapper\"}&gt;\n          &lt;CommentsSidebar /&gt;\n            &lt;/div&gt;\n      &lt;/Slate&gt;\n    &lt;/&gt;\n);</code></pre>\n\n\n\n<p>We now move on to implementing a popular Comments Sidebar interaction found in editors:</p>\n<p>Clicking on a comment thread in the sidebar should select/activate that comment thread. We also add a differential design treatment to highlight a comment thread in the sidebar if it’s active in the editor. To be able to do so, we use the Recoil atom — <code>activeCommentThreadIDAtom</code>. Let’s update the <code>CommentThread</code> component to support this.</p>\n<div>\n<pre><code># src/components/CommentsSidebar.js\n\nfunction CommentThread({ id }) {\n\nconst [activeCommentThreadID, setActiveCommentThreadID] = useRecoilState(\n    activeCommentThreadIDAtom\n  );\n\nconst onClick = useCallback(() =&gt; {<br />    setActiveCommentThreadID(id);\n  }, [id, setActiveCommentThreadID]);\n\n  ...\n\n  return (\n    &lt;Card\n      body={true}\n      className={classNames({\n        \"comment-thread-container\": true,\n        \"is-active\": activeCommentThreadID === id,<br />      })}\n      onClick={onClick}\n    &gt;\n    ....\n   &lt;/Card&gt;\n);</code></pre>\n</div>\n\n\n\n<p>If we look closely, we have a bug in our implementation of sync-ing the active comment thread with the sidebar. As we click on different comment threads in the sidebar, the correct comment thread is indeed highlighted in the editor. However, the Comment Popover doesn’t actually move to the changed active comment thread. It stays where it was first rendered. If we look at the implementation of the Comment Popover, it renders itself against the first text node in the editor’s selection. At that point in the implementation, the only way to select a comment thread was to click on a text node so we could conveniently rely on the editor's selection since it was updated by Slate as a result of the click event. In the above <code>onClick</code> event, we don’t update the selection but merely update the Recoil atom value causing Slate’s selection to remain unchanged and hence the Comment Popover doesn’t move.</p>\n<p>A solution to this problem is to update the editor’s selection along with updating the Recoil atom when the user clicks on the comment thread in the sidebar. The steps do this are:</p>\n<ol>\n<li>Find all text nodes that have this comment thread on them that we are going to set as the new active thread.</li>\n<li>Sort these text nodes in the order in which they appear in the document (We use Slate’s <a href=\"https://github.com/ianstormtaylor/slate/blob/f7b6f438ef5ca504eebef39bfc11850ff2c39c3e/packages/slate/src/interfaces/path.ts#L15\"><code>Path.compare</code></a> API for this).</li>\n<li>Compute a selection range that spans from the start of the first text node to the end of the last text node.</li>\n<li>Set the selection range to be the editor’s new selection (using Slate’s <a href=\"https://github.com/ianstormtaylor/slate/blob/e4936c3f32711a646ecdb51d4a75462975861660/packages/slate/src/transforms/selection.ts#L20\"><code>Transforms.select</code></a> API).</li>\n</ol>\n<p>If we just wanted to fix the bug, we could just find the first text node in Step #1 that has the comment thread and set that to be the editor’s selection. However, it feels like a cleaner approach to select the entire comment range as we really are selecting the comment thread.</p>\n<p>Let’s update the <code>onClick</code> callback implementation to include the steps above.</p>\n<div>\n<pre><code>const onClick = useCallback(() =&gt; {\n\n    const textNodesWithThread = Editor.nodes(editor, {\n      at: [],\n      mode: \"lowest\",\n      match: (n) =&gt; Text.isText(n) &amp;&amp; getCommentThreadsOnTextNode(n).has(id),\n    });\n\n    let textNodeEntry = textNodesWithThread.next().value;\n    const allTextNodePaths = [];\n\n    while (textNodeEntry != null) {\n      allTextNodePaths.push(textNodeEntry[1]);\n      textNodeEntry = textNodesWithThread.next().value;\n    }\n\n    // sort the text nodes\n    allTextNodePaths.sort((p1, p2) =&gt; Path.compare(p1, p2));\n\n    // set the selection on the editor\n    Transforms.select(editor, {\n      anchor: Editor.point(editor, allTextNodePaths[0], { edge: \"start\" }),\n      focus: Editor.point(\n        editor,\n        allTextNodePaths[allTextNodePaths.length - 1],\n        { edge: \"end\" }\n      ),\n    });\n\n   // Update the Recoil atom value.\n    setActiveCommentThreadID(id);\n  }, [editor, id, setActiveCommentThreadID]);</code></pre>\n</div>\n\n<p><strong>Note</strong>: <em><code>allTextNodePaths</code> contains the path to all the text nodes. We use the <a href=\"https://github.com/ianstormtaylor/slate/blob/f7b6f438ef5ca504eebef39bfc11850ff2c39c3e/packages/slate/src/interfaces/editor.ts#L213\"><code>Editor.point</code></a> API to get the start and end points at that path. The <a href=\"https://www.smashingmagazine.com/2021/05/building-wysiwyg-editor-javascript-slatejs/\">first article</a> goes through Slate’s Location concepts. They’re also well-documented on Slate’s <a href=\"https://docs.slatejs.org/concepts/03-locations\">documentation</a>.</em></p>\n<p>Let’s verify that this implementation does fix the bug and the Comment Popover moves to the active comment thread correctly. This time, we also test with a case of overlapping threads to make sure it doesn’t break there.</p>\n<p>With the bug fix, we’ve enabled another sidebar interaction that we haven’t discussed yet. If we have a really long document and the user clicks on a comment thread in the sidebar that’s outside the viewport, we’d want to scroll to that part of the document so the user can focus on the comment thread in the editor. By setting the selection above using Slate’s API, we get that for free. Let’s see it in action below.</p>\n<p>With that, we wrap our implementation of the sidebar. Towards the end of the article, we list out some nice feature additions and enhancements we can do to the Comments Sidebar that help elevate the Commenting and Review experience on the editor.</p>\n<h3>Resolving And Re-Opening Comments</h3>\n<p>In this section, we focus on enabling users to mark comment threads as ‘Resolved’ or be able to re-open them for discussion if needed. From an implementation detail perspective, this is the <code>status</code> metadata on a comment thread that we change as the user performs this action. From a user’s perspective, this is a very useful feature as it gives them a way to affirm that the discussion about something on the document has concluded or needs to be re-opened because there are some updates/new perspectives, and so on.</p>\n<p>To enable toggling the status, we add a button to the <code>CommentPopover</code> that allows the user to toggle between the two statuses: <code>open</code> and <code>resolved</code>.</p>\n<div>\n<pre><code># src/components/CommentThreadPopover.js\n\nexport default function CommentThreadPopover({\n  editorOffsets,\n  selection,\n  threadID,\n}) {\n  …\n  const [threadData, setCommentThreadData] = useRecoilState(\n    commentThreadsState(threadID)\n  );\n\n  ...\n\n  const onToggleStatus = useCallback(() =&gt; {\n    const currentStatus = threadData.status;\n    setCommentThreadData((threadData) =&gt; ({\n      ...threadData,\n      status: currentStatus === \"open\" ? \"resolved\" : \"open\",\n    }));\n  }, [setCommentThreadData, threadData.status]);\n\n  return (\n    &lt;NodePopover\n      ...\n      header={\n        &lt;Header\n          status={threadData.status}\n          shouldAllowStatusChange={threadData.comments.length &gt; 0}\n          onToggleStatus={onToggleStatus}\n        /&gt;\n      }\n    &gt;\n      &lt;div className={\"comment-list\"}&gt;\n          ...\n      &lt;/div&gt;\n    &lt;/NodePopover&gt;\n  );\n}\n\nfunction Header({ onToggleStatus, shouldAllowStatusChange, status }) {\n  return (\n    &lt;div className={\"comment-thread-popover-header\"}&gt;\n      {shouldAllowStatusChange &amp;&amp; status != null ? (\n        &lt;Button size=\"sm\" variant=\"primary\" onClick={onToggleStatus}&gt;\n          {status === \"open\" ? \"Resolve\" : \"Re-Open\"}\n        &lt;/Button&gt;\n      ) : null}\n    &lt;/div&gt;\n  );\n}</code></pre>\n</div>\n\n<p>Before we test this, let’s also give the Comments Sidebar a differential design treatment for resolved comments so that the user can easily detect which comment threads are un-resolved or open and focus on those if they want to.</p>\n<div>\n<pre><code># src/components/CommentsSidebar.js\n\nfunction CommentThread({ id }) {\n  ...\n  const { comments, status } = useRecoilValue(commentThreadsState(id));\n\n ...\n  return (\n    &lt;Card\n      body={true}\n      className={classNames({\n        \"comment-thread-container\": true,\n        \"is-resolved\": status === \"resolved\",\n        \"is-active\": activeCommentThreadID === id,\n      })}\n      onClick={onClick}\n    &gt;\n       ...<br />   &lt;/Card&gt;\n  );\n}</code></pre>\n</div>\n\n\n\n<h3>Conclusion</h3>\n<p>In this article, we built the core UI infrastructure for a Commenting System on a Rich Text Editor. The set of functionalities we add here act as a foundation to build a richer Collaboration Experience on an editor where collaborators could annotate parts of the document and have conversations about them. Adding a Comments Sidebar gives us a space to have more conversational or review-based functionalities to be enabled on the product.</p>\n<p>Along those lines, here are some of features that a Rich Text Editor could consider adding on top of what we built in this article:</p>\n<ul>\n<li>Support for <code>@</code> mentions so collaborators could tag one another in comments;</li>\n<li>Support for media types like images and videos to be added to comment threads;</li>\n<li>Suggestion Mode at the document level that allows reviewers to make edits to the document that appear as suggestions for changes. One could refer to this feature in <a href=\"https://support.google.com/docs/answer/6033474?co=GENIE.Platform%3DDesktop&amp;hl=en\">Google Docs</a> or <a href=\"https://support.microsoft.com/en-us/office/track-changes-in-word-197ba630-0f5f-4a8e-9a77-3712475e806a\">Change Tracking</a> in Microsoft Word as examples;</li>\n<li>Enhancements to the sidebar to search conversations by keyword, filter threads by status or comment author(s), and so on.</li>\n</ul>","author":"","siteTitle":"Articles on Smashing Magazine — For Web Designers And Developers","siteHash":"ab069ca35bf300e9db0da36f49701f66485a5b0d2db0471dfeee07cef6204939","entryHash":"d6a66795dd68591ac58d7bc711812082303c97098e44922aca37338b0bceaac5","category":"Tech"}