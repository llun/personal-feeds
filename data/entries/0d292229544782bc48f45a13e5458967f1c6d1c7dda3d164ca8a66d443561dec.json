{"title":"Linus Torvalds weighs in on Rust language in the Linux kernel","link":"https://arstechnica.com/?p=1752194","date":1616707562000,"content":"<div id=\"rss-wrap\">\n<figure class=\"intro-image intro-left\"><img src=\"https://cdn.arstechnica.net/wp-content/uploads/2021/03/GettyImages-919606342-800x795.jpg\" alt=\"Rust coats a pipe in an industrial construction site.\"><p class=\"caption\" style=\"font-size:0.8em\"><a href=\"https://cdn.arstechnica.net/wp-content/uploads/2021/03/GettyImages-919606342.jpg\" class=\"enlarge-link\" data-height=\"1017\" data-width=\"1024\">Enlarge</a> <span class=\"sep\">/</span> No, not <em>that</em> kind of Rust. (credit: <a rel=\"nofollow\" class=\"caption-link\" href=\"https://www.gettyimages.com/detail/news-photo/consett-steelworks-county-durham-1945-1980-cellulose-news-photo/\">Heritage Images via Getty Images</a>)</p>  </figure><div><a name=\"page-1\"></a></div>\n<p>This week, ZDNet's Steven J. Vaughan-Nichols asked Linus Torvalds and Greg Kroah-Hartman about the possibility of new Linux kernel code being written in <a href=\"https://www.rust-lang.org/\">Rust</a>—a high performance but memory-safe language <a href=\"https://research.mozilla.org/rust/\">sponsored</a> by the Mozilla project.</p>\n<h2>C versus Rust</h2>\n<p>As of now, the Linux kernel is written in the <a href=\"https://en.wikipedia.org/wiki/C_(programming_language)\">C</a> programming language—essentially, the same language used to write kernels for Unix and Unix-like operating systems since the <a href=\"https://en.wikipedia.org/wiki/Unix#History\">1970s</a>. The great thing about C is that it's not <a href=\"https://en.wikipedia.org/wiki/Low-level_programming_language\">assembly language</a>—it's considerably easier to read and write, and it's generally much closer to directly portable between hardware architectures. However, C still opens you up to nearly the entire range of catastrophic errors possible in assembly.</p>\n<p>In particular, as a nonmemory-managed language, C opens the programmer up to memory leaks and buffer overflows. When you're done with a variable you've created, you must explicitly destroy it—otherwise, old orphaned variables accumulate until the system crashes. Similarly, you must allocate memory to store data in—and if your attempt to put too much data into too-small an area of RAM, you'll end up overwriting locations you shouldn't.</p></div><p><a href=\"https://arstechnica.com/?p=1752194#p3\">Read 11 remaining paragraphs</a> | <a href=\"https://arstechnica.com/?p=1752194&comments=1\">Comments</a></p>","author":"Jim Salter","siteTitle":"Ars Technica","siteHash":"5b0ddf6e8923e49262a7894cfd77962733e43fbcc565a103b48373820b310636","entryHash":"0d292229544782bc48f45a13e5458967f1c6d1c7dda3d164ca8a66d443561dec","category":"Tech"}