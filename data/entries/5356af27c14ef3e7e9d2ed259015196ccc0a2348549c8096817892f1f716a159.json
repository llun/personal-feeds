{"title":"Building Azure Resources with TypeScript Using the CDK for Terraform","link":"https://www.hashicorp.com/blog/building-azure-resources-with-typescript-using-the-cdk-for-terraform","date":1620921600000,"content":"<p>The <a href=\"https://www.hashicorp.com/blog/announcing-cdk-for-terraform-0-1\">CDK for Terraform</a> is a tool used to define infrastructure using programming languages including TypeScript, Python, Java, and C#. It’s very useful for developers who want to provision with Terraform using a programming language that they’re more familiar with.</p>\n<p>For this post, we'll be working with a client side app in TypeScript, with the goal of deploying the app to Microsoft Azure. If you're not experienced with HCL, or just want to manage your entire coding workflow in one language, can be useful to define that infrastructure in TypeScript as well with Terraform.</p>\n<h2><a href=\"#why-the-cdk-for-terraform-matters\">»</a><a></a>Why the CDK for Terraform Matters</h2>\n<p>HashiCorp Terraform was built around a domain-specific language called the HashiCorp Configuration Language (HCL), so typically, new Terraform users will need to start by learning HCL. There’s also 1:1 mapping between HCL and JSON.</p>\n<p>As software professionals, we have to learn new things constantly, but sometimes we also just want to get started and become productive more quickly with new tools. When I was first exposed to Terraform, I initially wanted to write infrastructure code using a programming language I was already familiar with. HCL was worth learning, but it did take a small amount of time.</p>\n<p>Even though I now realize that there’s a lot of power in having one language (HCL) for expressing all of your organization’s infrastructure, I know that the developers who wear an ops hat as well could really make good use of the CDK for Terraform as they begin their adoption and try to switch context as little as possible.</p>\n<h2><a href=\"#tutorial-prerequisites\">»</a><a></a>Tutorial Prerequisites</h2>\n<ul>\n<li>Download and Install Node.js (<a href=\"https://nodejs.org/en/download/\">link</a>)</li>\n<li>Install TypeScript using <a href=\"https://www.npmjs.com/\">npm</a> (<a href=\"https://www.npmjs.com/package/typescript\">link</a>)</li>\n<li>Terraform open source CLI (<a href=\"https://www.terraform.io/downloads.html\">link</a>)</li>\n</ul>\n<h2><a href=\"#install-the-cdk\">»</a><a></a>Install the CDK</h2>\n<p>The first thing we have to do is install <code>cdktf</code> using npm. You can do this by typing…</p>\n<pre><code>npm install -g cdktf-cli\n</code></pre>\n<p><em>NOTE: You may have to use <code>sudo</code> if on Mac or Linux.</em></p>\n<p>Next let’s set up our folder structure so we can get started.</p>\n<pre><code>mkdir cdk\ncd cdk\n</code></pre>\n<p>Now that we are in our directory we can use the <code>cdktf</code> command to initialize our project.</p>\n<pre><code>cdktf init --template=\"TypeScript\" --local\n</code></pre>\n<p><em>NOTE: The <code>local</code> flag tells <code>cdktf</code> to use Terraform local storage for our state file.</em></p>\n<p>Once the command has been initialized you can list the files in that directory and see we have a good amount going on. If you are familiar with Node.js it will look pretty familiar.</p>\n<h2><a href=\"#configure-needed-providers\">»</a><a></a>Configure Needed Providers</h2>\n<p>Before we start writing code we will download the specific Terraform providers we need.</p>\n<p>In order to do that, we want to open our <code>cdktf.json</code> file and add a provider to the <code>terraformProviders</code> field. Since we are deploying resources to Azure, we will be using the <code>azurerm</code> provider.</p><pre><code>{\n \"language\": \"TypeScript\",\n \"app\": \"npm run --silent compile &amp;&amp; node main.js\",\n \"terraformProviders\": [\"azurerm@~&gt; 2.46.0\"],\n \"terraformModules\": [],\n \"context\": {\n   \"excludeStackIdFromLogicalIds\": \"true\",\n\"allowSepCharsInLogicalIds\": \"true\"\n }\n}</code></pre><p>Next we run the following to fetch our Terraform provider. This will need to be run any time you update this file.</p>\n<pre><code>npm run get\n</code></pre>\n<p>You will notice a new directory in your folder structure <code>.gen</code>. This is where your provider code is located and we will import it into our <code>main.ts</code>.</p>\n<p>Now that we have things set up, let's write some infrastructure code using TypeScript. We will be making these changes in the <code>main.ts</code> file. This snippet provisions a Linux VM and the required supporting infrastructure.</p><pre><code>import { Construct } from 'constructs';\nimport { App, TerraformStack } from 'cdktf';\nimport {AzurermProvider, VirtualNetwork, ResourceGroup, LinuxVirtualMachine, Subnet, NetworkInterface} from \"./.gen/providers/azurerm\"\nclass AzureAppInfra extends TerraformStack {\n constructor(scope: Construct, name: string) {\n   super(scope, name);\nnew AzurermProvider(this, \"AzureRm\", {\n     features: [{}]\n   })\nlet rg = new ResourceGroup(this, \"rg-example\", {\n     name: \"example-resource-group\",\n     location: \"eastus\"\n   })\nlet vnet = new VirtualNetwork(this, \"vnet-example\", {\n     name: \"example-network\",\n     location: rg.location,\n     addressSpace: [\"10.0.0.0/16\"],\n     resourceGroupName: rg.name\n})\nlet subnet = new Subnet(this, \"subnet-example\", {\n     name: \"example-subnet\",\n     resourceGroupName: rg.name,\n     virtualNetworkName: vnet.name ,\n     addressPrefixes: [\"10.0.2.0/24\"]\n   })\nlet network_interface = new NetworkInterface(this, \"ni-example\", {\n     name: \"example-nic\",\n     resourceGroupName: rg.name,\n     location: rg.location,\n     ipConfiguration: [{\n       name: \"internal\",\n       subnetId: subnet.id,\n       privateIpAddressAllocation: \"Dynamic\"\n     }]\n   })\nnew LinuxVirtualMachine(this, 'Web-Server', {\n     name: \"Web-App-1\",\n     resourceGroupName: rg.name,\n     adminUsername: \"devhulk\",\n     size: \"Standard_F2\",\n     location: rg.location,\n     networkInterfaceIds: [\n       network_interface.id\n     ],\n     osDisk: [{\n       caching: \"ReadWrite\",\n       storageAccountType: \"Standard_LRS\"\n     }],\n     sourceImageReference: [{\n       publisher: \"Canonical\",\n       offer: \"UbuntuServer\",\n       sku: \"16.04-LTS\",\n       version: \"latest\"\n     }],\n     adminSshKey: [{username: \"\", publicKey: \"\"}]\n})\n}\n}\nconst app = new App();\nnew AzureAppInfra(app, 'cdk');\napp.synth();</code></pre><p>Next, we’ll run this code to provision the infrastructure.</p>\n<p><em>NOTE: In order to do this successfully you will need to have your Azure credentials configured. I set mine using ENV Variables. If you haven’t done this yet, go <a href=\"https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/guides/service_principal_client_secret#configuring-the-service-principal-in-terraform\">here</a> for instructions.</em></p>\n<h2><a href=\"#running-the-cdk-for-terraform\">»</a><a></a>Running the CDK for Terraform</h2>\n<p>There are two ways to run your <code>terraform cdk</code> code. You can run it directly with the <code>cdktf</code> command or use the <code>terraform cli</code> command to plan and apply the JSON output file under the <code>cdktf.out</code> directory. In this article we will be using the <code>cdktf</code> command directly.</p>\n<p>First we need to run:</p>\n<pre><code>cdktf synth\n</code></pre>\n<p>This will sync any changes made in our <code>main.ts</code> file and update our Terraform config to match.</p>\n<p>Next we run:</p>\n<pre><code>cdktf deploy\n</code></pre>\n<p>And here’s my output:</p><img src=\"https://www.datocms-assets.com/2885/1620761781-cdk-article-code-snip-azure.png\" /><p>And that's it. Afterward you should see your infrastructure provisioned in your environment. In order to clean up your environment you can destroy your infrastructure by running:</p>\n<pre><code>cdktf destroy\n</code></pre>\n<h2><a href=\"#additional-resources\">»</a><a></a>Additional Resources</h2>\n<p>Here are some links that should help you learn more about the CDK for Terraform, get help if you need it, and make more sophisticated deployments with it.</p>\n<p><strong>Helpful Links:</strong></p>\n<ul>\n<li><a href=\"http://discuss.hashicorp.com/c/terraform-core/cdk-for-terraform\">CDK Discuss Forum</a></li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/terraform/cdktf\">Learn Guide</a></li>\n<li><a href=\"https://github.com/hashicorp/terraform-cdk\">Terraform CDK Repo</a></li>\n<li><a href=\"https://github.com/hashicorp/terraform-cdk/tree/main/examples\">Examples</a></li>\n</ul>","author":"Gerald Yerden","siteTitle":"HashiCorp Blog","siteHash":"219aa6310b3388f2335eba49871f4df9581f2c58eaeb5e498363b54e835b7001","entryHash":"5356af27c14ef3e7e9d2ed259015196ccc0a2348549c8096817892f1f716a159","category":"Tech"}