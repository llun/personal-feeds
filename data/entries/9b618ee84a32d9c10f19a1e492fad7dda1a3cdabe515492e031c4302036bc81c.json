{"title":"CNAME Cloaking and Bounce Tracking Defense","link":"https://webkit.org/blog/11338/cname-cloaking-and-bounce-tracking-defense/","date":1605205801000,"content":"<p>This blog post covers several enhancements to Intelligent Tracking Prevention (ITP) in Safari 14 on macOS Big Sur, Catalina, and Mojave, iOS 14, and iPadOS 14 to address our latest discoveries in the industry around tracking.</p>\n<h2>CNAME Cloaking Defense</h2>\n<p>ITP now caps the expiry of cookies set in so-called third-party CNAME-cloaked HTTP responses to 7 days. On macOS, this enhancement is specific to Big Sur.</p>\n<h3>What Is CNAME Cloaking?</h3>\n<p>In the eyes of web browsers, the first party of a website is typically defined by its registrable domain. This means that <code>www.blog.example</code> and <code>comments.blog.example</code> are considered same-site and the same party. If the user loads a webpage from <code>www.blog.example</code>, and that page makes a subresource request to <code>comments.blog.example</code>, that request will carry all cookies that are set to cover the <code>blog.example</code> site, including login cookies and user identity cookies. In addition, the response to that <code>comments.blog.example</code> subresource request can <em>set</em> cookies for <code>blog.example</code>, and those cookies will be first-party cookies.</p>\n<p>Enter CNAMEs. CNAME stands for canonical name record and maps one domain name to another as part of the Domain Name System, or DNS. This means a site owner can configure one of their subdomains, such as <code>sub.blog.example</code>, to resolve to <code>thirdParty.example</code>, before resolving to an IP address. This happens underneath the web layer and is called <em>CNAME cloaking</em> — the <code>thirdParty.example</code> domain is cloaked as <code>sub.blog.example</code> and thus has the same powers as the true first party.</p>\n<h3>CNAME Cloaking and Tracking</h3>\n<p>Cross-site trackers have convinced site owners to set up CNAME cloaking in order to circumvent tracking prevention, such as ITP’s 7-day expiry cap on cookies set in JavaScript. In our blog case, this would be making <code>track.blog.example</code> resolve to <code>tracker.example.</code></p>\n<p>A <a href=\"https://blog.apnic.net/2020/08/04/characterizing-cname-cloaking-based-tracking/\">recent paper</a> from researchers at the Graduate University for Advanced Studies (Sokendai) and the French National Cybersecurity Agency (ANSSI) found 1,762 websites CNAME cloaking 56 trackers in total.</p>\n<h3>CNAME Cloaking and Website Security</h3>\n<p>Site owners who set up CNAME cloaking risk full website takeovers or customer cookie hijacking if the CNAME records aren’t properly managed, for instance if CNAME cloaking isn’t decommissioned when no longer in use. It was <a href=\"https://nakedsecurity.sophos.com/2020/07/07/company-web-names-hijacked-via-outdated-cloud-dns-records/\">recently reported</a> that 250 websites of banks, healthcare companies, restaurant chains, and civil rights groups had been compromised through mismanaged CNAME cloaking. In June this year, Microsoft <a href=\"https://docs.microsoft.com/en-us/azure/security/fundamentals/subdomain-takeover\">documented</a> these attacks and how their cloud customers should prevent them.</p>\n<h3>ITP’s Defense Against CNAME Cloaking Tracking</h3>\n<p>ITP now detects third-party CNAME cloaking requests and caps the expiry of any cookies set in the HTTP response to 7 days. This cap is aligned with ITP’s expiry cap on all cookies created through JavaScript.</p>\n<p>Third-party CNAME cloaking is defined as a first-party subresource that resolves through a CNAME that differs from the first-party domain and differs from the top frame host&#8217;s CNAME, if one exists. Yes, the whole site can be CNAME cloaked, when it uses so called edge servers.</p>\n<p>The best way to explain this is through a table (1p means first-party, 3p means third-party):</p>\n<table>\n<thead>\n<tr>\n<th>1p host, e.g. www.blog.example</th>\n<th>1p subdomain other than the 1p host, e.g. track.blog.example</th>\n<th>Capped cookie expiry?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>No cloaking</td>\n<td>No cloaking</td>\n<td>No cap</td>\n</tr>\n<tr>\n<td>No cloaking</td>\n<td>other.blog.example (1p cloaking)</td>\n<td>No cap</td>\n</tr>\n<tr>\n<td>No cloaking</td>\n<td>tracker.example (3p cloaking)</td>\n<td>7-day cap</td>\n</tr>\n<tr>\n<td>abc123.edge.example (cloaking)</td>\n<td>No cloaking</td>\n<td>No cap</td>\n</tr>\n<tr>\n<td>abc123.edge.example (cloaking)</td>\n<td>abc123.edge.example (matching cloaking)</td>\n<td>No cap</td>\n</tr>\n<tr>\n<td>abc123.edge.example (cloaking)</td>\n<td>other.blog.example (1p cloaking)</td>\n<td>No cap</td>\n</tr>\n<tr>\n<td>abc123.edge.example (cloaking)</td>\n<td>tracker.example (3p cloaking)</td>\n<td>7-day cap</td>\n</tr>\n</tbody>\n</table>\n<h2>SameSite=Strict Cookie Jail for Bounce Trackers</h2>\n<p>In June 2018, we announced an update to ITP to detect and defend against <a href=\"https://webkit.org/blog/8311/intelligent-tracking-prevention-2-0/\">first party bounce trackers</a>. In March 2020, we announced an enhancement to also detect <a href=\"https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/\">delayed bounce tracking</a>. Since then, we have received a report of one specific website engaged in bounce tracking while also being likely to get frequent user interaction. To combat such issues, we proposed to the W3C Privacy Community Group what we call a <a href=\"https://github.com/privacycg/proposals/issues/6\">SameSite=Strict jail</a> as well as other escalations.</p>\n<p>What the SameSite=strict jail does is detect bounce tracking and, at a certain threshold, rewrite all the tracking domain’s cookies to <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite\">SameSite=strict</a>. This means that they will not be sent in cross-site, first-party navigations, and they can no longer be used for simple redirect-based bounce tracking.</p>\n<p>Our implementation is rather relaxed, with the threshold set to 10 unique navigational, first-party redirects (unique in the sense of going to unique domains), and an automatic reset of that counter once the cookies are rewritten to SameSite=strict. This automatically gives the domain a new chance so that they can disengage in bounce tracking and “get out of jail.”</p>\n<p>Our current list of domains we subject to this protection is empty because the domain reported to us has stopped their bounce tracking. But this protection remains in our toolbox.</p>\n<h2>Partitioned Ephemeral IndexedDB</h2>\n<p>Up until now, WebKit has blocked cross-origin IndexedDB. WebKit now allows partitioned and ephemeral third-party IndexedDB in an effort to align with other browsers now that they are interested in storage partitioning too. You can partake in the ongoing standardization effort for storage partitioning on <a href=\"https://github.com/privacycg/storage-partitioning\">GitHub</a>.</p>\n<p>Partitioned means unique IndexedDB instance per first-party site and ephemeral means in-memory-only, i.e. goes away on browser quit.</p>\n<h2>Third-Party Cookie Blocking and Storage Access API In Private Browsing</h2>\n<p>Private Browsing in Safari is based on WebKit’s ephemeral sessions where nothing is persisted to disk. This means ITP would not be able to learn things between launches of Safari. Further, Private Browsing also uses a separate ephemeral session for each new tab the user opens. To uphold this separation between tabs, ITP wouldn’t be able to classify cross-site trackers from the user’s full browsing <em>even in-memory</em>.</p>\n<p>However, full third-party cookie blocking doesn’t need classification and is now enabled by default in Private Browsing. This might seem simple to support but the challenge was to make the Storage Access API work with the aforementioned tab separation. This is how it works: Say <code>identityProvider.example</code> wants to request storage access as third-party on the login page for <code>social.example</code> in Tab A. Interacting with <code>identityProvider.example</code> as a first party website in Tab B will not suffice to allow it to request storage access in Tab A since that would leak state between the separate ephemeral sessions. Thus, the user must interact with <code>identityProvider.example</code> <em>in the same tab</em> as where <code>identityProvider.example</code> later requests storage access as third-party. This makes sure that login flows where two different parties are involved and third-party cookie access is required, is possible in Private Browsing mode.</p>\n<h2>Home Screen Web Application Domain Exempt From ITP</h2>\n<p>Back in March 2020, when we <a href=\"https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/\">announced</a> ITP’s 7-day cap on all script-writeable storage, developers asked about home screen web applications and whether they were exempt from this 7-day cap. We explained how ITP’s counter of “days of use” and capture of user interaction effectively made sure that the first party of home screen web applications would not be subjected to the new 7-day cap. To make this more clear, we have implemented an explicit exception for the first-party domain of home screen web applications to make sure ITP always skips that domain in its website data removal algorithm.</p>\n<p>In addition, the website data of home screen web applications is kept isolated from Safari and thus will not be affected by ITP’s classification of tracking behavior in Safari.</p>\n<h2>Thanks To My Coworkers</h2>\n<p>The above updates to WebKit and ITP would not have been possible without the help from Kate, Jiten, Scott, Tommy, Sihui, and David. Thank you!</p>","author":"","siteTitle":"Blog – WebKit","siteHash":"7f8dbea0b8f53db2e11a2faa08c6dca9954c01638d09a2ce585b77a60d10f7a1","entryHash":"9b618ee84a32d9c10f19a1e492fad7dda1a3cdabe515492e031c4302036bc81c","category":"Tech"}