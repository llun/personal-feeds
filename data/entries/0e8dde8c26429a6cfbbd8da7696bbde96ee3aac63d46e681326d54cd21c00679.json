{"title":"Introducing CloudFront Functions – Run Your Code at the Edge with Low Latency at Any Scale","link":"https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/","date":1620075956000,"content":"<p>With <a href=\"https://aws.amazon.com/cloudfront/\">Amazon CloudFront</a>, you can securely deliver data, videos, applications, and APIs to your customers globally with low latency and high transfer speeds. To offer a customized experience and the lowest possible latency, many modern applications execute some form of logic at the edge. The use cases for applying logic at the edge can be grouped together in two main categories:</p> \n<ul> \n <li>First are the complex, compute-heavy operations that are executed when objects are not in the cache. We <a href=\"https://aws.amazon.com/blogs/aws/coming-soon-lambda-at-the-edge/\">launched</a> <a href=\"https://aws.amazon.com/lambda/edge/\">Lambda@Edge</a> in 2017 to offer a fully programmable, serverless edge computing environment for implementing a wide variety of complex customizations. Lambda@Edge functions are executed in a <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowCloudFrontWorks.html#CloudFrontRegionaledgecaches\">regional edge cache</a> (usually in the <a href=\"https://aws.amazon.com/about-aws/global-infrastructure/regions_az/\">AWS region</a> closest to the CloudFront edge location reached by the client). For example, when you’re streaming video or audio, you can use Lambda@Edge to create and serve the right segments on-the-fly reducing the need for origin scalability. Another common use case is to use Lambda@Edge and <a href=\"https://aws.amazon.com/dynamodb/\">Amazon DynamoDB</a> to translate shortened, user-friendly URLs to full URL landing pages.</li> \n <li>The second category of use cases are simple HTTP(s) request/response manipulations that can be executed by very short-lived functions. For these use cases, you need a flexible programming experience with the performance, scale, and cost-effectiveness that enable you to execute them on every request.</li> \n</ul> \n<p>To help you with this second category of use cases, I am happy to announce the availability of <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-functions.html\"><strong>CloudFront Functions</strong></a>, a new serverless scripting platform that allows you to run lightweight JavaScript code at the <a href=\"https://aws.amazon.com/cloudfront/features/#Global_Edge_Network\">218+ CloudFront edge locations</a> at approximately 1/6th the price of Lambda@Edge.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-where.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-where-1024x532.png\" /></a></p> \n<p>CloudFront Functions are ideal for lightweight processing of web requests, for example:</p> \n<ul> \n <li><strong>Cache-key manipulations and normalization</strong>: Transform HTTP request attributes (such as URL, headers, cookies, and query strings) to construct the cache-key, which is the unique identifier for objects in cache and is used to determine whether an object is already cached. For example, you could cache based on a header that contains the end user’s device type, creating two different versions of the content for mobile and desktop users. By transforming the request attributes, you can also normalize multiple requests to a single cache-key entry and significantly improve your cache-hit ratio.</li> \n <li><strong>URL rewrites and redirects</strong>: Generate a response to redirect requests to a different URL. For example, redirect a non-authenticated user from a restricted page to a login form. URL rewrites can also be used for <a href=\"https://en.wikipedia.org/wiki/A/B_testing\">A/B testing</a>.</li> \n <li><strong>HTTP header manipulation</strong>: View, add, modify, or delete any of the request/response headers. For instance, add <a href=\"https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security\">HTTP Strict Transport Security (HSTS)</a> headers to your response, or copy the client IP address into a new HTTP header so that it is forwarded to the origin with the request.</li> \n <li><strong>Access authorization</strong>: Implement access control and authorization for the content delivered through CloudFront by creating and validating user-generated tokens, such as <a href=\"https://en.wikipedia.org/wiki/HMAC\">HMAC</a> tokens or <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\">JSON web tokens (JWT)</a>, to allow/deny requests.</li> \n</ul> \n<p>To give you the performance and scale that modern applications require, CloudFront Functions uses a new process-based isolation model instead of virtual machine (VM)-based isolation as used by <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> and Lambda@Edge. To do that, we had to enforce some restrictions, such as avoiding network and file system access. Also, functions run for less than one millisecond. In this way, they can handle millions of requests per second while giving you great performance on every function execution. Functions add almost no perceptible impact to overall <a href=\"https://en.wikipedia.org/wiki/Content_delivery_network\">content delivery network (CDN)</a> performance.</p> \n<p>Similar to Lambda@Edge, CloudFront Functions runs your code in response to events generated by CloudFront. More specifically, CloudFront Functions can be triggered after CloudFront receives a request from a viewer (<strong>viewer request</strong>) and before CloudFront forwards the response to the viewer (<strong>viewer response</strong>).</p> \n<p>Lambda@Edge can also be triggered before CloudFront forwards the request to the origin (<strong>origin request</strong>) and after CloudFront receives the response from the origin (<strong>origin response</strong>). You can use CloudFront Functions and Lambda@Edge together, depending on whether you need to manipulate content before, or after, being cached.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-function-and-lambda-edge-2.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-function-and-lambda-edge-2-1024x454.png\" /></a></p> \n<p>If you need some of the capabilities of Lambda@Edge that are not available with CloudFront Functions, such as network access or a longer execution time, you can still use Lambda@Edge before and after content is cached by CloudFront.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-only-lambda-egde.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-only-lambda-egde-1024x413.png\" /></a></p> \n<p>To help you understand the difference between CloudFront Functions and Lambda@Edge, here’s a quick comparison:</p> \n<table> \n <tbody> \n  <tr> \n   <td></td> \n   <td><strong>CloudFront Functions</strong></td> \n   <td><strong>Lambda@Edge</strong></td> \n  </tr> \n  <tr> \n   <td>Runtime support</td> \n   <td>JavaScript<br /> (ECMAScript 5.1 compliant)</td> \n   <td>Node.js, Python</td> \n  </tr> \n  <tr> \n   <td>Execution location</td> \n   <td>218+ CloudFront<br /> Edge Locations</td> \n   <td>13 CloudFront<br /> Regional Edge Caches</td> \n  </tr> \n  <tr> \n   <td>CloudFront triggers supported</td> \n   <td>Viewer request<br /> Viewer response</td> \n   <td>Viewer request<br /> Viewer response<br /> Origin request<br /> Origin response</td> \n  </tr> \n  <tr> \n   <td>Maximum execution time</td> \n   <td>Less than 1 millisecond</td> \n   <td>5 seconds (viewer triggers)<br /> 30 seconds (origin triggers)</td> \n  </tr> \n  <tr> \n   <td>Maximum memory</td> \n   <td>2MB</td> \n   <td>128MB (viewer triggers)<br /> 10GB (origin triggers)</td> \n  </tr> \n  <tr> \n   <td>Total package size</td> \n   <td>10 KB</td> \n   <td>1 MB (viewer triggers)<br /> 50 MB (origin triggers)</td> \n  </tr> \n  <tr> \n   <td>Network access</td> \n   <td>No</td> \n   <td>Yes</td> \n  </tr> \n  <tr> \n   <td>File system access</td> \n   <td>No</td> \n   <td>Yes</td> \n  </tr> \n  <tr> \n   <td>Access to the request body</td> \n   <td>No</td> \n   <td>Yes</td> \n  </tr> \n  <tr> \n   <td>Pricing</td> \n   <td>Free tier available;<br /> charged per request</td> \n   <td>No free tier; charged per request<br /> and function duration</td> \n  </tr> \n </tbody> \n</table> \n<p>Let’s see how this works in practice.</p> \n<p><span><strong>Using CloudFront Functions From the Console<br /> </strong></span>I want to customize the content of my website depending on the country of origin of the viewers. To do so, I use a CloudFront distribution that I created using an S3 bucket as origin. Then, I create a <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-location\">cache policy to include</a> the <code>CloudFront-Viewer-Country</code> header (that contains the two-letter country code of the viewer’s country) in the cache key. CloudFront Functions can see CloudFront-generated headers (like the <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-location\">CloudFront geolocation</a> or <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-device\">device detection headers</a>) only if they are included in an origin policy or cache key policy.</p> \n<p>In the <a href=\"https://console.aws.amazon.com/cloudfront/\">CloudFront console</a>, I select <strong>Functions</strong> on the left bar and then <strong>Create function</strong>. I give the function a name and <strong>Continue</strong>.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-create.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-create-1024x298.png\" /></a></p> \n<p>From here, I can follow the lifecycle of my function with these steps:</p> \n<ol> \n <li><strong> Build</strong> the function by providing the code.</li> \n <li><strong>Test</strong> the function with a sample payload.</li> \n <li><strong>Publish</strong> the function from the development stage to the live stage.</li> \n <li><strong>Associate</strong> the function with one or more CloudFront distributions.</li> \n</ol> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-build.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-build-1024x402.png\" /></a></p> \n<p>1. In the <strong>Build</strong> tab, I can access two stages for each function: a <strong>Development</strong> stage for tests, and a <strong>Live</strong> stage that can be used by one or more CloudFront distributions. With the development stage selected, I type the code of my function and <strong>Save</strong>:</p> \n<pre><code>function handler(event) {\n  var request = event.request;\n  var supported_countries = ['de', 'it', 'fr'];\n  if (request.uri.substr(3,1) != '/') {\n    var headers = request.headers;\n    var newUri;\n    if (headers['cloudfront-viewer-country']) {\n      var countryCode = headers['cloudfront-viewer-country'].value.toLowerCase();\n      if (supported_countries.includes(countryCode)) {\n        newUri = '/' + countryCode + request.uri;\n      }\n    }\n    if (newUri === undefined) {\n      var defaultCountryCode = 'en';\n      newUri = '/' + defaultCountryCode + request.uri;\n    }\n    var response = {\n      statusCode: 302,\n      statusDescription: 'Found',\n      headers: {\n        \"location\": { \"value\": newUri }\n      }\n    }\n    return response;\n  }\n  return request;\n}</code></pre> \n<p>The function looks at the content of the <code>CloudFront-Viewer-Country</code> header set by CloudFront. If it contains one of the supported countries, and the URL does not already contain a country prefix, it adds the country at the beginning of the URL path. Otherwise, it lets the request pass through without changes.</p> \n<p>2. In the <strong>Test</strong> tab, I select the event type (<strong>Viewer Request</strong>), the Stage (<strong>Development</strong>, for now) and a sample event.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-test-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-test-1-1024x294.png\" /></a></p> \n<p>Below, I can customize the <strong>Input</strong> event by selecting the HTTP method, and then editing the path of the URL, and optionally the client IP to use. I can also add custom headers, cookies, or query strings. In my case, I leave all the default values and add the <code>CloudFront-Viewer-Country</code> header with the value of <code>FR</code> (for France). Optionally, instead of using the visual editor, I can customize the input event by editing the JSON payload that is passed to the function.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/07/cloudfront-functions-test-input-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/07/cloudfront-functions-test-input-1-1024x681.png\" /></a></p> \n<p>I click on the <strong>Test</strong> button and look at the <strong>Output</strong>. As expected, the request is being redirected (HTTP status code <code>302</code>). In the <strong>Response headers</strong>, I see that the <strong>location</strong> where the request is being redirected starts with <code>/fr/</code> to provide custom content for viewers based in France. If something doesn’t go as expected in my tests, I can look at the <strong>Function Logs</strong>. I can also use <code>console.log()</code> in my code to add more debugging information.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-test-output-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-test-output-1-1024x490.png\" /></a></p> \n<p>In the <strong>Output</strong>, just above the HTTP status, I see the <strong>Compute utilization</strong> for this execution. Compute utilization is a number between 0 and 100 that indicates the amount of time that the function took to run as a percentage of the maximum allowed time. In my case, a compute utilization of 21 means that the function completed in 21% of the maximum allowed time.</p> \n<p>3. I run more tests using different configurations of URL and headers, then I move to the <strong>Publish</strong> tab to copy the function from the development stage to the live stage. Now, the function is ready to be associated with an existing distribution.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-publish.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/01/cloudfront-functions-publish-1024x279.png\" /></a></p> \n<p>4. In the <strong>Associate</strong> tab, I select the <strong>Distribution</strong>, the <strong>Event type</strong> (Viewer Request or Viewer Response) and the <strong>Cache behavior</strong> (I only have the <strong>Default (*)</strong> cache behavior for my distribution). I click <strong>Add association</strong> and confirm in the dialog.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-associate-1.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-associate-1-1024x440.png\" /></a></p> \n<p>Now, I see the function association at the bottom of the <strong>Associate</strong> tab.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-associated-distributions.png\"><img src=\"https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/08/cloudfront-functions-associated-distributions-1024x257.png\" /></a></p> \n<p>To test this configuration from two different locations, I start two <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud (EC2)</a> instances, one in the <span>US East (N. Virginia)</span> Region and one in the <span>Europe (Paris)</span> Region. I <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html\">connect using SSH</a> and use <a href=\"https://curl.se/\">cURL</a> to get an object from the CloudFront distribution. Previously, I have uploaded two objects to the S3 bucket that is used as the origin for the distribution: one, for customers based in France, using the <code>fr/</code> prefix, and one, for customers not in a supported country, using the <code>en/</code> prefix.</p> \n<p>I list the two objects using the <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (CLI)</a>:</p> \n<div> \n <pre><code>$ aws s3 ls --recursive s3://BUCKET\n2021-04-01 13:54:20         13 en/doc.txt\n2021-04-01 13:54:20          8 fr/doc.txt</code></pre> \n</div> \n<p>In the EC2 instance in the <span>US East (N. Virginia)</span> Region, I run this command to download the object:</p> \n<div> \n <pre><code><strong>[us-east-1]</strong>$ curl -L https://d2wj2l15gt32vo.cloudfront.net/doc.txt \nGood morning</code></pre> \n</div> \n<p>Then I run the same command in the <span>Europe (Paris)</span> Region:</p> \n<div> \n <pre><code><strong>[eu-west-3]</strong>$ curl -L https://d2wj2l15gt32vo.cloudfront.net/doc.txt\nBonjour</code></pre> \n</div> \n<p>As expected, I am getting different results from the same URL. I am using the <code>-L</code> option so that cURL is following the redirect it receives. In this way, each command is executing two HTTP requests: the first request receives the HTTP redirect from the CloudFront function, the second request follows the redirect and is not modified by the function because it contains a custom path in the URL (<code>/en/</code> or <code>/fr/</code>).</p> \n<p>To see the actual location of the redirect and all HTTP response headers, I use cURL with the <code>-i</code> option. These are the response headers for the EC2 instance running in the US; the function is executed at an edge location in Virginia:</p> \n<div> \n <pre><code><strong>[us-east-1]</strong>$ curl -i https://d2wj2l15gt32vo.cloudfront.net/doc.txt \nHTTP/2 302 \nserver: CloudFront\ndate: Thu, 01 Apr 2021 14:39:31 GMT\ncontent-length: 0\nlocation: /en/doc.txt\nx-cache: FunctionGeneratedResponse from cloudfront\nvia: 1.1 cb0868a0a661911b98247aaff77bc898.cloudfront.net (CloudFront)\nx-amz-cf-pop: IAD50-C2\nx-amz-cf-id: TuaLKKg3YvLKN85fzd2qfcx9jOlfMQrWazpOVmN7NgfmmcXc1wzjmA==</code></pre> \n</div> \n<p>And these are the response headers for the EC2 instance running in France; this time, the function is executed in an edge location near Paris:</p> \n<div> \n <pre><code><strong>[eu-west-3]</strong>$ curl -i https://d2wj2l15gt32vo.cloudfront.net/doc.txt\nHTTP/2 302 \nserver: CloudFront\ndate: Thu, 01 Apr 2021 14:39:26 GMT\ncontent-length: 0\nlocation: /fr/doc.txt\nx-cache: FunctionGeneratedResponse from cloudfront\nvia: 1.1 6fa25eadb94abd73b5efc56a89b2d829.cloudfront.net (CloudFront)\nx-amz-cf-pop: CDG53-C1\nx-amz-cf-id: jzWcbccJiTDRj22TGwsn_</code></pre> \n</div> \n<p><span><strong>Availability and Pricing<br /> </strong></span><a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-functions.html\">CloudFront Functions</a> is available today and you can use it with new and existing distributions. You can use CloudFront Functions with the <a href=\"https://console.aws.amazon.com\">AWS Management Console</a>, <a href=\"https://aws.amazon.com/cli/\">AWS Command Line Interface (CLI)</a>, <a href=\"https://aws.amazon.com/tools/\">AWS SDKs</a>, and <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a>. With CloudFront Functions, you pay by the number of invocations. You can get started with CloudFront Functions for free as part of the <a href=\"https://aws.amazon.com/free/\">AWS Free Usage Tier</a>. For more information, please see the <a href=\"https://aws.amazon.com/cloudfront/pricing/\">CloudFront pricing</a> page.</p> \n<p><span><strong>AWS for the Edge</strong></span><br /> <span>Amazon CloudFront</span> and AWS edge networking capabilities are part of the <a href=\"https://aws.amazon.com/edge/\">AWS for the Edge</a> portfolio. AWS edge services improve performance by moving compute, data processing, and storage closer to end-user devices. This includes deploying AWS managed services, APIs, and tools to locations outside AWS data centers, and even onto customer-owned infrastructure and devices.</p> \n<p>AWS offers you a consistent experience and portfolio of capabilities from the edge to the cloud. Using AWS, you have access to the broadest and deepest capabilities for edge use cases, like edge networking, hybrid architectures, connected devices, 5G, and multi-access edge computing.</p> \n<p><strong><a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-functions.html\">Start using CloudFront Functions today to add custom logic at the edge for your applications.</a></strong></p> \n<p>— <a href=\"https://twitter.com/danilop\">Danilo</a></p>","author":"Danilo Poccia","siteTitle":"AWS News Blog","siteHash":"6093e072e4117ec22616e844cb857d03ca62c57a411a8affc77cb5e8b6b15bf6","entryHash":"0e8dde8c26429a6cfbbd8da7696bbde96ee3aac63d46e681326d54cd21c00679","category":"Tech"}